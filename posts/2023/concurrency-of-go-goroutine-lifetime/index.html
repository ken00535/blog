<!DOCTYPE html><html domain="blog.kenwsc.com" ga-id="GTM-MM4P38S" lang="zh-TW"><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1" name="viewport"><meta content="Backend,Golang" name="keywords"><link href="/img/favicon/favicon.png?hash=b6fc65e341" rel="icon" type="image/png"><meta content="#5789d3" name="theme-color"><title>Goroutine 的併發治理：掌握生命週期</title><meta content="Goroutine 的併發治理：掌握生命週期" property="og:title"><meta content="Goroutine 的併發治理：掌握生命週期" name="twitter:title"><meta content="summary_large_image" name="twitter:card"><meta content="從併發的角度來看，Goroutine 跟 Thread 的概念很類似，都是將任務交給一個執行單元來處理。然而不同的是，Goroutine 將調度放在用戶態，因此更加輕量，也能避免多餘的 Context Switch。我們可以說，Go 的併發處理是由語言原生支援，有著更好的開發者體驗，但也因此更容易忘記底層仍存在著輕量成本，當這些成本積沙成塔，就會造成 Out of Memory。這篇文章會從 Goroutine 的生命週期切入，試著說明在併發的情境中，應該如何保持 Goroutine 的正常運作。..." name="description"><meta content="從併發的角度來看，Goroutine 跟 Thread 的概念很類似，都是將任務交給一個執行單元來處理。然而不同的是，Goroutine 將調度放在用戶態，因此更加輕量，也能避免多餘的 Context Switch。我們可以說，Go 的併發處理是由語言原生支援，有著更好的開發者體驗，但也因此更容易忘記底層仍存在著輕量成本，當這些成本積沙成塔，就會造成 Out of Memory。這篇文章會從 Goroutine 的生命週期切入，試著說明在併發的情境中，應該如何保持 Goroutine 的正常運作。..." name="twitter:description"><meta content="從併發的角度來看，Goroutine 跟 Thread 的概念很類似，都是將任務交給一個執行單元來處理。然而不同的是，Goroutine 將調度放在用戶態，因此更加輕量，也能避免多餘的 Context Switch。我們可以說，Go 的併發處理是由語言原生支援，有著更好的開發者體驗，但也因此更容易忘記底層仍存在著輕量成本，當這些成本積沙成塔，就會造成 Out of Memory。這篇文章會從 Goroutine 的生命週期切入，試著說明在併發的情境中，應該如何保持 Goroutine 的正常運作。..." property="og:description"><meta content="article" property="og:type"><meta content="https://blog.kenwsc.com/posts/2023/concurrency-of-go-goroutine-lifetime/" property="og:url"><meta content="Ken Chen's Blog" property="og:site_name"><meta content="https://blog.kenwsc.com/img/posts/2023/concurrency-of-go-goroutine-lifetime/cover.png" property="og:image"><meta content="https://blog.kenwsc.com/img/posts/2023/concurrency-of-go-goroutine-lifetime/cover.png" name="twitter:image"><meta content="hsZQwAip9iIbys-i4PJp_MfpNiA6w6RB0hYdWLiLUuk" name="google-site-verification"><link href="https://blog.kenwsc.com/posts/2023/concurrency-of-go-goroutine-lifetime/" rel="canonical"><meta content="always" name="referrer"><link href="/feed/feed.xml" rel="alternate" type="application/atom+xml" title="Ken Chen's Blog"><link href="/" rel="preconnect" crossorigin=""><script async="" src="/js/min.js?hash=7f26b2ece8" defer=""></script><script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({ 'gtm.start': new Date().getTime(), event: 'gtm.js' });
            var f = d.getElementsByTagName(s)[0];
            var j = d.createElement(s);
            var dl = l != 'dataLayer' ? '&l=' + l : '';
            j.async = true;
            j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
            f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-MM4P38S');</script><script csp-hash="">if (/Mac OS X/.test(navigator.userAgent))document.documentElement.classList.add('apple')</script><style>:root{--primary-color: #5789d3;--primary-dark-color: #ffd349;--fgColor: #2f2f2f;--bgColor: linear-gradient(to top, #efefef, #ffffff);--primary: var(--primary-color);--primary-dark: var(--primary-dark-color);--fg: var(--fgColor);--bg: var(--bgColor);--progressColor: #ffd349;--main-width: calc(100vw - 3em)}main img{content-visibility:auto}article *{scroll-margin-top:50px}header nav{z-index:1;position:fixed;top:0;left:0;width:100vw;background:#fff;font-weight:200;text-align:right;padding:0}@media (min-width:37.5em){:root{--main-width: calc(37.5em - 3em)}}dialog,share-widget{position:fixed;opacity:.9}share-widget{right:20px;bottom:20px;width:50px;height:50px;border-radius:50%;overflow:hidden;box-shadow:2px 3px 5px 2px rgba(0,0,0,.2)}@media screen and (max-width:376px){share-widget{display:none}}share-widget div{margin-left:50%;transform:translateX(-50%);width:20px;height:20px;background-image:url(/img/share.svg);background-repeat:no-repeat;background-position:center;background-size:contain}.apple share-widget div{background-image:url(/img/share-apple.svg)}share-widget button{margin:0;padding:0;width:100%;height:100%;transition:.3s}share-widget button:active{transform:scale(1.2)}dialog{background-color:var(--primary-dark);z-index:1000;font-size:14px}dl{clear:both;display:block!important;margin:0 0 1.5em}#reading-progress{z-index:1;background-color:var(--progressColor);width:100vw;position:absolute;left:0;bottom:0;height:2px;transform:translate(-100vw,0);will-change:transform;pointer-events:none}#posts li{margin-bottom:.5em}html{line-height:1.15;-webkit-text-size-adjust:100%;font-family:"Open Sans",-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans","Helvetica Neue",Helvetica,Arial,"Noto Sans TC","PingFang TC","Hiragino Sans GB","Heiti TC","Microsoft YaHei","Microsoft Jhenghei",sans-serif;--font-family: "Open Sans", -apple-system, system-ui, BlinkMacSystemFont,
    "Segoe UI", Roboto, "Noto Sans", "Helvetica Neue", Helvetica, Arial,
    "Noto Sans TC", "PingFang TC", "Hiragino Sans GB", "Heiti TC",
    "Microsoft YaHei", "Microsoft Jhenghei", sans-serif}body.lock{overflow:hidden}a{background-color:transparent;text-underline-offset:2px;text-decoration:none;color:var(--primary)}b{font-weight:700}img{border-style:none;max-width:100%;height:auto;margin:0 auto}button,input,select{font-family:inherit;font-size:100%;line-height:1.15}.article-footer img,body,input,select{margin:0}button,input{overflow:visible}button,select{text-transform:none}[type=button],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}h2{font-size:2.5em;line-height:1.2;margin-bottom:.6em;line-height:2.4rem;margin-bottom:1.36rem;font-size:1.728rem}body,p,pre,ul{font-size:1em}p,pre,ul{margin-bottom:1.5em}body,p,pre,ul{font-size:1rem;line-height:1.6}p,pre,ul{margin-bottom:1.36rem}@media (min-width:600px){h2{font-size:2.0097rem;line-height:2.52rem}body,p,pre,ul{font-size:1.1rem;line-height:1.6}h2,p,pre,ul{margin-bottom:1.496rem}}@media (min-width:1200px){h2{font-size:1.75rem}body,p,pre,ul{font-size:1.2rem;line-height:1.6}h2,p,pre,ul{margin-bottom:1.632rem}}code,pre{overflow-x:auto}pre{font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace}pre code:not([class]){overflow-x:scroll}code{border-radius:.3em;color:#e33671;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:90%}h1,h2{font-family:var(--font-family)}a:hover{text-decoration:underline}button,input,select{border-radius:.3em;max-width:100%}input{padding:.75em}button+label,input+label,label+*,select+label{page-break-before:always}input,select{margin-bottom:1.5em;display:inline}button,label{display:inline-block}button{background:#f2f2f2;color:#191919;cursor:pointer;padding:.75em 1.5em;text-align:center;margin:0 .75em 1.5em 0}button:hover{background:#d9d9d9;color:#000}button:not([disabled]){background:#f9c412;color:#181818;background:var(--primary)}button:not([disabled]):hover{background:#ba9005;color:#000;background:var(--primary-dark)}input[type=file],input[type=number],input[type=range],input[type=time],input[type=url],select{border:1px solid #595959;padding:.75em}*{border:0;box-sizing:border-box}body{font-family:var(--font-family);background:var(--bg);color:var(--fg)}section{margin-left:auto;margin-right:auto;width:900px}header label{display:block}article,header{max-width:100%;width:42.5em;margin:0 auto}header{padding:4.5em 24px 0;text-align:center;display:flex;align-items:center;flex-direction:column}header p,ul{margin-top:0}header nav label{color:#000;cursor:pointer;margin:0;font-style:normal;text-align:right}main{max-width:70rem;margin:0 auto;min-height:60vh}article{padding:1.5em;word-break:break-word}li dl,li ul{margin-bottom:0}code[class*=language-],pre[class*=language-]{color:#ccc;background:0 0;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#2d2d2d}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.comment{color:#999}.token.punctuation{color:#ccc}.token.boolean,.token.function,.token.number{color:#f08d49}.token.property{color:#f8c555}.token.builtin,.token.keyword{color:#cc99cd}.token.string,.token.variable{color:#7ec699}.token.operator,.token.url{color:#67cdcc}.token.bold{font-weight:700}.token.inserted{color:green}::-webkit-scrollbar-thumb:hover{background:var(--primary)}.w-full{width:100%}body.dark{--fg: var(--bgColor);--bg: var(--fgColor);--primary: var(--primary-dark-color)}@media (prefers-color-scheme:dark){body.dark{--fg: var(--bgColor);--bg: var(--fgColor);--primary: var(--primary-dark-color)}}h1{font-size:32px;line-height:1.25;margin:.67em 0;text-align:left}header aside{font-size:16px;color:#4b4b4b}#nav,.menu__btn{position:relative}.menu__btn{display:inline-block;width:24px;height:24px}.menu__btn span{opacity:0;width:1px;height:1px;overflow:hidden;display:block}.menu__btn::after,.menu__btn::before{content:"";position:absolute;top:51%;left:50%;height:2px;width:17px;background-color:#2d2d2d;border-radius:.1rem}.menu__btn::before{transform:translate(-50%,-50%);box-shadow:0 .3rem 0 #2d2d2d,0 -.3rem 0 #2d2d2d}.menu__btn::after{display:none;transform:translate(-50%,-50%) rotate(90deg)}.menu__btn.menu__btn--close{z-index:9;transform:rotate(45deg)}.menu__btn.menu__btn--close::before{box-shadow:none}.menu__btn.menu__btn--close::after{display:block}#nav{height:68px;z-index:2;align-items:center}.nav__links{display:none;flex-direction:column;position:fixed;z-index:3;top:0;left:0;right:0;bottom:0;padding:86px 48px 0;background-image:linear-gradient(to top,#efefef,#fff),linear-gradient(to bottom,#f9f9f9,#f9f9f9)}#nav,.nav__links--open{display:flex}.nav__links a{text-align:left;width:100%;padding:.5rem 0;transition:all .3s ease-out;font-weight:700;text-decoration:none;color:var(--fg)}.nav__links a:hover{color:var(--primary-color)}footer{margin-top:48px;font-size:14px;padding:24px;border-top:1px solid #ccc;text-align:center}.copyright{display:inline-block}footer>*{margin:.5em}.footer-logos{display:flex;align-items:center;justify-content:center}.footer-logos a:not(:first-child){margin-left:32px}.post-tags{display:flex;gap:0 16px;flex-wrap:wrap}.post-tag:not(body){text-decoration:none;background-color:#f5f5f5;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:20px;color:#4a4a4a;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;font-size:.75rem;height:2em;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;line-height:1.5;padding-left:.75em;padding-right:.75em;white-space:nowrap}.post-tag:hover{text-decoration:none;background:#ccc}.direct-link{display:none}.post-avatar{display:flex;align-items:center;height:36px}.post-avatar__time{font-size:13px}.article-footer{margin-top:40px;border-bottom:1px solid #ccc;padding-bottom:52px}.article-footer a{float:right;display:flex;align-items:center;color:var(--fg);font-weight:700;margin-left:4px}@media (min-width:768px){h1{font-size:48px}header aside{font-size:20px}header nav a:first-of-type{margin-left:auto}header nav a:last-of-type{margin-right:1.5em}.menu__btn{display:none}#nav,footer{max-width:1168px}#nav{height:80px;margin:0 auto}.nav__links{display:flex;flex-direction:row;position:static;padding:0;background-image:none}.nav__links a{text-align:center;margin-left:56px}footer{display:flex;flex-direction:row-reverse;justify-content:space-between;align-items:center;margin-left:auto;margin-right:auto}}</style></head><body><header><nav><div id="nav"><div class="nav__links"><a href="/" title="Homepage">Home</a> <a href="/archive/">Archive</a> <a href="/tags/">Tags</a> <a href="/about/">About</a></div></div><div id="reading-progress" aria-hidden="true"></div></nav><h1 class="w-full">Goroutine 的併發治理：掌握生命週期</h1><aside class="w-full"><div class="post-avatar"><div class="post-avatar__time">Ken Chen | 06 Jan 2023 <a href="/tags/go/" class="post-tag">Go</a> <a href="/tags/concurrency/" class="post-tag">Concurrency</a></div></div></aside><dialog id="message"></dialog></header><main><article><div id="post-page"></div><p>從併發的角度來看，Goroutine 跟 Thread 的概念很類似，都是將任務交給一個執行單元來處理。然而不同的是，Goroutine 將調度放在用戶態，因此更加輕量，也能避免多餘的 Context Switch。我們可以說，Go 的併發處理是由語言原生支援，有著更好的開發者體驗，但也因此更容易忘記底層仍存在著輕量成本，當這些成本積沙成塔，就會造成 Out of Memory。這篇文章會從 Goroutine 的生命週期切入，試著說明在併發的情境中，應該如何保持 Goroutine 的正常運作。</p><h2 id="goroutine-%E7%9A%84%E8%B3%87%E6%BA%90%E4%BD%BF%E7%94%A8%E9%87%8F"><a href="#goroutine-%E7%9A%84%E8%B3%87%E6%BA%90%E4%BD%BF%E7%94%A8%E9%87%8F" class="direct-link">#</a> Goroutine 的資源使用量</h2><p>讓我們看個最簡單的例子，假設現在同時開 3M 個 Goroutine 來執行任務</p><pre class="language-go"><code class="language-go"><span class="token keyword">var</span> n <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">1e6</span><br><br><span class="token keyword">var</span> ch <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">byte</span><span class="token punctuation">)</span><br><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<br><br><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span>wg <span class="token operator">*</span>sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token operator">&lt;-</span>ch<br><span class="token punctuation">}</span><br><br><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><br><br>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><br>        <span class="token keyword">go</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">&</span>wg<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>每個 Goroutine 都有自己的 stack，也會需要一些配置放在 heap，天下沒有白吃的午餐，第一個問題是，一個 Goroutine 會消耗多少資源？的確，我們知道 Goroutine 相對 Thread 更為輕量，但這是個比較級的說法，當要評估系統效能時，會需要具體的數字，好在 Go 標準包的 runtime package 可以監控 Goroutine 的數量跟記憶體的使用情況</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><br><br>    <span class="token keyword">var</span> m0 runtime<span class="token punctuation">.</span>MemStats<br>    runtime<span class="token punctuation">.</span><span class="token function">ReadMemStats</span><span class="token punctuation">(</span><span class="token operator">&</span>m0<span class="token punctuation">)</span><br><br>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><br>        <span class="token keyword">go</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token operator">&</span>wg<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br>    runtime<span class="token punctuation">.</span><span class="token function">Gosched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    runtime<span class="token punctuation">.</span><span class="token function">GC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br><br>    <span class="token keyword">var</span> m1 runtime<span class="token punctuation">.</span>MemStats<br>    runtime<span class="token punctuation">.</span><span class="token function">ReadMemStats</span><span class="token punctuation">(</span><span class="token operator">&</span>m1<span class="token punctuation">)</span><br><br>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br><br>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Number of goroutines: %d\n"</span><span class="token punctuation">,</span> runtime<span class="token punctuation">.</span><span class="token function">NumGoroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Per goroutine:\n"</span><span class="token punctuation">)</span><br>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"  Memory: %.2f bytes\n"</span><span class="token punctuation">,</span> <span class="token function">float64</span><span class="token punctuation">(</span>m1<span class="token punctuation">.</span>Sys<span class="token operator">-</span>m0<span class="token punctuation">.</span>Sys<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">float64</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>這裡用 m0 紀錄啟動 Goroutine 前的記憶體使用量，再用 m1 紀錄啟動 Goroutine 後的記憶體使用量。執行後可以得到答案</p><pre class="language-bash"><code class="language-bash">Number of goroutines: <span class="token number">3000001</span><br>Per goroutine:<br>  Memory: <span class="token number">2731.46</span> bytes<br>  Time:   <span class="token number">2.083068</span> µs</code></pre><p>每個 Goroutine 的初始大小大約是 2.7KB。可能有人會好奇，這 2.7KB 怎麼來的？就讓我們捲起袖子進一步往下追，如果寫個最簡單的 Goroutine 程式</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>查看它的 assembly code，可以得到</p><pre class="language-bash"><code class="language-bash">go tool compile -N -l -S main.go<br><br>0x0014 00020 <span class="token punctuation">(</span>main.go:6<span class="token punctuation">)</span>        LEAQ    main.main.func1·f<span class="token punctuation">(</span>SB<span class="token punctuation">)</span>, AX<br>0x001b 00027 <span class="token punctuation">(</span>main.go:6<span class="token punctuation">)</span>        PCDATA  <span class="token variable">$1</span>, <span class="token variable">$0</span><br>0x001b 00027 <span class="token punctuation">(</span>main.go:6<span class="token punctuation">)</span>        NOP<br>0x0020 00032 <span class="token punctuation">(</span>main.go:6<span class="token punctuation">)</span>        CALL    runtime.newproc<span class="token punctuation">(</span>SB<span class="token punctuation">)</span><br>0x0025 00037 <span class="token punctuation">(</span>main.go:9<span class="token punctuation">)</span>        MOVL    <span class="token variable">$1000000000</span>, AX<br>0x002a 00042 <span class="token punctuation">(</span>main.go:9<span class="token punctuation">)</span>        CALL    time.Sleep<span class="token punctuation">(</span>SB<span class="token punctuation">)</span><br>0x002f 00047 <span class="token punctuation">(</span>main.go:10<span class="token punctuation">)</span>       MOVQ    <span class="token number">8</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span>, BP<br>0x0034 00052 <span class="token punctuation">(</span>main.go:10<span class="token punctuation">)</span>       ADDQ    <span class="token variable">$16</span>, SP</code></pre><p>Goroutine 關鍵字所在的 L6 會編譯成對 runtime.newproc 的調用，繼續往下查，runtime.newproc 的程式碼是</p><pre class="language-go"><code class="language-go"><span class="token comment">// Create a new g running fn.</span><br><span class="token comment">// Put it on the queue of g's waiting to run.</span><br><span class="token comment">// The compiler turns a go statement into a call to this.</span><br><span class="token keyword">func</span> <span class="token function">newproc</span><span class="token punctuation">(</span>fn <span class="token operator">*</span>funcval<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    gp <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    pc <span class="token operator">:=</span> <span class="token function">getcallerpc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token function">systemstack</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        newg <span class="token operator">:=</span> <span class="token function">newproc1</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> gp<span class="token punctuation">,</span> pc<span class="token punctuation">)</span><br><br>        _p_ <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token function">runqput</span><span class="token punctuation">(</span>_p_<span class="token punctuation">,</span> newg<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><br><br>        <span class="token keyword">if</span> mainStarted <span class="token punctuation">{</span><br>            <span class="token function">wakep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>runtime.newproc 會再調用 runtime.newproc1，裡面相關的段落有</p><pre class="language-go"><code class="language-go"><span class="token comment">// Create a new g in state _Grunnable, starting at fn. callerpc is the</span><br><span class="token comment">// address of the go statement that created this. The caller is responsible</span><br><span class="token comment">// for adding the new g to the scheduler.</span><br><span class="token keyword">func</span> <span class="token function">newproc1</span><span class="token punctuation">(</span>fn <span class="token operator">*</span>funcval<span class="token punctuation">,</span> callergp <span class="token operator">*</span>g<span class="token punctuation">,</span> callerpc <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token operator">*</span>g <span class="token punctuation">{</span><br>  <span class="token comment">//...</span><br>    newg <span class="token operator">:=</span> <span class="token function">gfget</span><span class="token punctuation">(</span>_p_<span class="token punctuation">)</span><br>    <span class="token keyword">if</span> newg <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><br>        newg <span class="token operator">=</span> <span class="token function">malg</span><span class="token punctuation">(</span>_StackMin<span class="token punctuation">)</span><br>        <span class="token function">casgstatus</span><span class="token punctuation">(</span>newg<span class="token punctuation">,</span> _Gidle<span class="token punctuation">,</span> _Gdead<span class="token punctuation">)</span><br>        <span class="token function">allgadd</span><span class="token punctuation">(</span>newg<span class="token punctuation">)</span> <span class="token comment">// publishes with a g->status of Gdead so GC scanner doesn't look at uninitialized stack.</span><br>    <span class="token punctuation">}</span><br>  <span class="token comment">//...</span><br><span class="token punctuation">}</span></code></pre><p><code>gfget</code> 會嘗試從空閒的 Goroutine 隊列中，取出可以使用的 Goroutine，「空閒」跟「隊列」牽涉到 Go 的排程器設計，有空再另外談，我們現在關心的是資源配置，如果 <code>gfget</code> 拿不到 Goroutine，就會用 <code>malg</code> 來分配記憶體，可以看到這裡使用常數 <code>_StackMin</code> 當參數，它的值是 2KB</p><pre class="language-go"><code class="language-go"><span class="token comment">// The minimum size of stack used by Go code</span><br>_StackMin <span class="token operator">=</span> <span class="token number">2048</span></code></pre><p>當然 Goroutine 還有一些其他的配置，但佔用最多的就是 stack，讓我們來想想，假設每個 stack 的配置空間是 2KB，1000 個 Goroutine 就至少需要吃掉 2MB 的記憶體空間。</p><p>1000 個併發才 2MB，難怪會被說是輕量。這個數字聽起來很 ok，現在的記憶體動輒 16G 以上，即使是最低階的 AWS EC2 t2.nano，也是 0.5GB 起跳，區區 2MB 根本不放在眼裡。但問題是，有沒有想過，這些資源什麼時間點會被釋放呢？通常我們使用 Goroutine，會搭配 for 跟 select 來監聽 input，讓 Goroutine 保持 listen 的狀態，例如</p><pre class="language-go"><code class="language-go"><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">for</span> <span class="token punctuation">{</span><br>    <span class="token keyword">select</span> <span class="token punctuation">{</span><br>      <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span><br>        <span class="token comment">// do something</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>而很不幸的，這個寫法中，因為資源一直保持活躍，它不會被釋放。假設每次呼叫 func 都會創建 Goroutine，但它又不會被釋放，這就造成了 Memory Leak。Go 是有 GC 的語言，開發者不用花太多精神去管理資源的生命週期，但這不代表它不會洩漏，對 Goroutine 的不當使用就是一項 Memory Leak 的常見原因。</p><h2 id="%E4%BD%BF%E7%94%A8-context-%E7%AE%A1%E7%90%86-goroutine-%E4%B8%8A%E4%B8%8B%E6%96%87"><a href="#%E4%BD%BF%E7%94%A8-context-%E7%AE%A1%E7%90%86-goroutine-%E4%B8%8A%E4%B8%8B%E6%96%87" class="direct-link">#</a> 使用 Context 管理 Goroutine 上下文</h2><p>Memory Leak 的主要問題在於「該釋放的資源沒被釋放」，本質上，它是資源生命週期管理的問題，Goroutine 的資源在什麼時間點會被釋放呢？當 Goroutine 執行完畢時，它會呼叫 <code>runtime.goexit1</code></p><pre class="language-go"><code class="language-go"><span class="token comment">// Finishes execution of the current goroutine.</span><br><span class="token keyword">func</span> <span class="token function">goexit1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> raceenabled <span class="token punctuation">{</span><br>        <span class="token function">racegoend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">if</span> trace<span class="token punctuation">.</span>enabled <span class="token punctuation">{</span><br>        <span class="token function">traceGoEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br>    <span class="token function">mcall</span><span class="token punctuation">(</span>goexit0<span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p><code>runtime.goexit1</code> 又會再輾轉呼叫到 <code>gfput</code></p><pre class="language-go"><code class="language-go"><span class="token comment">// Put on gfree list.</span><br><span class="token comment">// If local list is too long, transfer a batch to the global list.</span><br><span class="token keyword">func</span> <span class="token function">gfput</span><span class="token punctuation">(</span>_p_ <span class="token operator">*</span>p<span class="token punctuation">,</span> gp <span class="token operator">*</span>g<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token comment">//...</span><br>    <span class="token keyword">if</span> stksize <span class="token operator">!=</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>startingStackSize<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token comment">// non-standard stack size - free it.</span><br>        <span class="token function">stackfree</span><span class="token punctuation">(</span>gp<span class="token punctuation">.</span>stack<span class="token punctuation">)</span><br>        gp<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>lo <span class="token operator">=</span> <span class="token number">0</span><br>        gp<span class="token punctuation">.</span>stack<span class="token punctuation">.</span>hi <span class="token operator">=</span> <span class="token number">0</span><br>        gp<span class="token punctuation">.</span>stackguard0 <span class="token operator">=</span> <span class="token number">0</span><br>    <span class="token punctuation">}</span><br>    _p_<span class="token punctuation">.</span>gFree<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>gp<span class="token punctuation">)</span><br>    _p_<span class="token punctuation">.</span>gFree<span class="token punctuation">.</span>n<span class="token operator">++</span>cont<br>  <span class="token comment">//...</span><br><span class="token punctuation">}</span></code></pre><p>從程式碼可以看到，<code>gfput</code> 會釋放 stack，然後將 Goroutine 放到 Free List 中，等待下次使用。我們可以理解成，當 Goroutine 執行完畢後，它的資源就會被回收。</p><p>因此要管理 Goroutine 的生命週期，要訣就是讓它可以依照調用者的意思來脫離無窮迴圈。實作上，調用者會傳入一個 channel 當 input，Goroutine 監聽這個 input，只要有訊號出現，就結束 Goroutine 的執行</p><pre class="language-go"><code class="language-go"><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">{</span><br>        <span class="token keyword">select</span> <span class="token punctuation">{</span><br>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>finishCh<span class="token punctuation">:</span><br>            <span class="token keyword">return</span><br>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>dataCh<span class="token punctuation">:</span><br>            <span class="token comment">// Do something</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>但如果直接用原生的 channel 來管理 Goroutine 結束訊號，會變得非常麻煩。舉個例子，G1 會生出一個 G2，G2 會生出一個 G3，他們之間是 G1 -> G2 -> G3 的關係，現在希望上游取消時，下游也跟著取消，你可以理解成父資源的釋放也要讓子資源跟著釋放，因此 G1 需要創建一個 channel，然後傳給 G2, G3，同理，G2 也需要創建自己的 channel，傳給 G3，而 G3 會類似這樣</p><pre class="language-go"><code class="language-go"><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">{</span><br>        <span class="token keyword">select</span> <span class="token punctuation">{</span><br>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>g1Ch<span class="token punctuation">:</span><br>            <span class="token keyword">return</span><br>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>g2Ch<span class="token punctuation">:</span><br>            <span class="token keyword">return</span><br>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>dataCh<span class="token punctuation">:</span><br>            <span class="token comment">// Do something</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>可想而知這會讓併發的開發變得麻煩，好在 Go 有內建的 context 包，可以讓開發者更容易管理 Goroutine 間的上下文關係。</p><p>Context 是個 interface，有 4 個 func，其中我們主要關心 <code>Done()</code>，這個 func 會傳回一個 channel，當 context 被取消時，這個 channel 會送出 <code>struct{}</code> 作為訊號</p><pre class="language-go"><code class="language-go"><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">{</span><br>        <span class="token keyword">select</span> <span class="token punctuation">{</span><br>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>            <span class="token keyword">return</span><br>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>dataCh<span class="token punctuation">:</span><br>            <span class="token comment">// Do something</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span></code></pre><p>你可能會覺得奇怪，Context 的 interface 中沒有 Cancel 這個 func，「取消」context 是什麼意思？這項設計反映了 Go 的 less is more 哲學，因為取消通常跟業務場景密切關聯，像是，有些人可能希望在取消的指令中放進更多資訊，因此 Go 不將具體的 Cancel 放在標準包中，只提供了 <code>Done()</code>，讓各家去實作，儘管如此，因為併發控制是非常常見的情境，Go 也有提供 <code>WithCancel</code> 讓開發者開箱即用。</p><p>對 <code>WithCancel</code> 的使用通常是</p><pre class="language-go"><code class="language-go">ctx<span class="token punctuation">,</span> cancel <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithCancel</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">{</span><br>        <span class="token keyword">select</span> <span class="token punctuation">{</span><br>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>            <span class="token keyword">return</span><br>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>dataCh<span class="token punctuation">:</span><br>            <span class="token comment">// Do something</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><br><span class="token comment">// if you want to cancel goroutine</span><br><span class="token keyword">if</span> IsExecption <span class="token punctuation">{</span><br>    <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>當調用 <code>WithCancel</code> 傳回的 cancel func 後，<code>ctx.Done</code> 就會送出結束訊號。它的原理是什麼？為什麼能簡化原本的 channel？事實上，Goroutine 間的調用關係可以理解成一個樹狀結構，假設每個 Goroutine 都持有各自的 context，那麼，context 間也能理解成是樹狀結構</p><p align="center"><picture><source sizes="(max-width: 758px) 100vw, 758px" srcset="/img/posts/2023/concurrency-of-go-goroutine-lifetime/context_tree-1920w.webp 1920w, /img/posts/2023/concurrency-of-go-goroutine-lifetime/context_tree-1280w.webp 1280w, /img/posts/2023/concurrency-of-go-goroutine-lifetime/context_tree-840w.webp 840w, /img/posts/2023/concurrency-of-go-goroutine-lifetime/context_tree-320w.webp 320w" type="image/webp"><source sizes="(max-width: 758px) 100vw, 758px" srcset="/img/posts/2023/concurrency-of-go-goroutine-lifetime/context_tree-1920w.png 1920w, /img/posts/2023/concurrency-of-go-goroutine-lifetime/context_tree-1280w.png 1280w, /img/posts/2023/concurrency-of-go-goroutine-lifetime/context_tree-840w.png 840w, /img/posts/2023/concurrency-of-go-goroutine-lifetime/context_tree-320w.png 320w" type="image/png"><img height="331" src="/img/posts/2023/concurrency-of-go-goroutine-lifetime/context_tree-1920w.png" width="321" decoding="async" loading="lazy" style="background-size:cover;background-image:url(&#34;data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http%3A//www.w3.org/2000/svg' xmlns%3Axlink='http%3A//www.w3.org/1999/xlink' viewBox='0 0 321 331'%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='.5'%3E%3C/feGaussianBlur%3E%3CfeComponentTransfer%3E%3CfeFuncA type='discrete' tableValues='1 1'%3E%3C/feFuncA%3E%3C/feComponentTransfer%3E%3C/filter%3E%3Cimage filter='url(%23b)' preserveAspectRatio='none' height='100%25' width='100%25' xlink%3Ahref='data%3Aimage/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA9ElEQVQYlS1Oy0rDQBS9SU1a/Z18g1v/waWfUegfCC58ILrKQtwIrlxYaJKZkFAfqE0zVQlNNCEz0YpgRDky0gsHzovDpfE8poVaEAANqyzLvKqqsq7rrvZo+v5Az82jcX5z8l9SSu02TXOgueu6ROIjoRqlDs2NzfW15RI5jrPatq25nP41uQiG3mQU5Zja+VNhFUXhSymvKMOE9HER8HDGxgAM7ICklIGs5T0BX53jZNA7zbbts/le9/C23/vEyLjYvzTDOLSJCxYFqRcL8M5g64hY6oVcMAZkRvJyR8Rn/nWQetEbXi39DxM+0xr4WfmGoj8DvrIOdqknZgAAAABJRU5ErkJggg=='%3E%3C/image%3E%3C/svg%3E&#34;)"></picture></p><p>如果希望上游的 Context，像是 context 2 取消後，下游的 context 4, 5 也能跟著取消，直覺解法是使用 DFS，讓 context 2 的 cancel 遞迴呼叫下層的 cancel。</p><p>來看看 <code>WithCancel</code> 怎麼實現這個概念。<code>WithCancel</code> 會傳入一個 parent Context</p><pre class="language-go"><code class="language-go"><span class="token comment">// A cancelCtx can be canceled. When canceled, it also cancels any children</span><br><span class="token comment">// that implement canceler.</span><br><span class="token keyword">type</span> cancelCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span><br>    Context<br><br>    mu       sync<span class="token punctuation">.</span>Mutex            <span class="token comment">// protects following fields</span><br>    done     atomic<span class="token punctuation">.</span>Value          <span class="token comment">// of chan struct{}, created lazily, closed by first cancel call</span><br>    children <span class="token keyword">map</span><span class="token punctuation">[</span>canceler<span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// set to nil by the first cancel call</span><br>    err      <span class="token builtin">error</span>                 <span class="token comment">// set to non-nil by the first cancel call</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">func</span> <span class="token function">WithCancel</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>ctx Context<span class="token punctuation">,</span> cancel CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> parent <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><br>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"cannot create context from nil parent"</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br>    c <span class="token operator">:=</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><br>    <span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token operator">&</span>c<span class="token punctuation">)</span><br>    <span class="token keyword">return</span> <span class="token operator">&</span>c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// newCancelCtx returns an initialized cancelCtx.</span><br><span class="token keyword">func</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">)</span> cancelCtx <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> cancelCtx<span class="token punctuation">{</span>Context<span class="token punctuation">:</span> parent<span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>這個 parent context 會在 <code>newCancelCtx</code> 中被包進 cancelCtx 這個 struct，cancelCtx 同時實現了 Context 跟 canceler 的 interface，因此它也具有 cancel func。仔細觀察它的字段，Context 用來儲存上游 Context，children 則用來儲存下游 Context，對 cancelCtx 來說，它同時兼具了往上或往下查找的能力。</p><p>當執行 <code>propagateCancel</code> 時，<code>parentCancelCtx</code> 會在樹結構中向上搜尋，直到找到另一個 cancelCtx，然後將當前的 Context 掛進 parent context 的 children 中</p><pre class="language-go"><code class="language-go"><span class="token comment">// propagateCancel arranges for child to be canceled when parent is.</span><br><span class="token keyword">func</span> <span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> child canceler<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">//...</span><br>    <span class="token keyword">if</span> p<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token function">parentCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span><br>        <span class="token comment">//...</span><br>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>children <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><br>                p<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span>canceler<span class="token punctuation">]</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><br>            <span class="token punctuation">}</span><br>            p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span><br>        <span class="token comment">//...</span><br>    <span class="token punctuation">}</span><br>    <span class="token comment">//...</span><br><span class="token punctuation">}</span></code></pre><p>當 <code>WithCancel</code> 的 <code>cancel</code> 被執行時，它會呼叫 cancelCtx 的 cancel func</p><pre class="language-go"><code class="language-go"><span class="token comment">// cancel closes c.done, cancels each of c's children, and, if</span><br><span class="token comment">// removeFromParent is true, removes c from its parent's children.</span><br><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>cancelCtx<span class="token punctuation">)</span> <span class="token function">cancel</span><span class="token punctuation">(</span>removeFromParent <span class="token builtin">bool</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">//...</span><br>    d<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> c<span class="token punctuation">.</span>done<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><br>    <span class="token keyword">if</span> d <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><br>        c<span class="token punctuation">.</span>done<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span>closedchan<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        <span class="token function">close</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">for</span> child <span class="token operator">:=</span> <span class="token keyword">range</span> c<span class="token punctuation">.</span>children <span class="token punctuation">{</span><br>        <span class="token comment">// NOTE: acquiring the child's lock while holding parent's lock.</span><br>        child<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br>    <span class="token comment">//...</span><br>    <span class="token keyword">if</span> removeFromParent <span class="token punctuation">{</span><br>        <span class="token function">removeChild</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> c<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>這邊做三件事，關閉 channel，取消所有 child Context，以及從 parent Context 中移除自己。完成這些事情後，所有 select ctx.Done() 的 Goroutine 都可以被釋放，而 context 本身也因為不再有人引用，會自動被 GC 回收。這裡有另一個常見的 Memory Leak，如果使用了 cancelContext，但卻沒有執行 cancel 指令的話，它會持續掛在 parent Context 底下而不會被回收掉，因此記得在離開 func 前，無論 Goroutine 是否有完成任務，都要執行 cancel()。</p><p>雖然程式碼看起來有些複雜，但原理很漂亮，利用 tree 做個雙向連結，就能有效管理 Goroutine 的生命週期，可能也是因為太好用了，基本上大家都用標準包的 Context，不太會看到自己實現 cancel 的例子。</p><h2 id="%E6%90%B6%E5%8D%A0%E5%BC%8F%E8%A8%AD%E8%A8%88"><a href="#%E6%90%B6%E5%8D%A0%E5%BC%8F%E8%A8%AD%E8%A8%88" class="direct-link">#</a> 搶占式設計</h2><p>依照 CSP 的理論，Goroutine 內會是循序操作，這就意味著，雖然 Goroutine 會用 select 來監聽結束訊號，但如果當訊號發出時，Goroutine 正在忙碌中，它會將手中的任務忙完才會關閉 Goroutine。這是個好的特性，能確保 Goroutine 的關閉都是 Graceful，有經過妥善處理，但另一方面也引伸出一些新問題，例如，如果 Goroutine 的忙碌時間太久，久到沒辦法用 ctx.Done 來關閉的話呢？</p><pre class="language-go"><code class="language-go"><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">{</span><br>        <span class="token keyword">select</span> <span class="token punctuation">{</span><br>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>            <span class="token keyword">return</span><br>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>dataCh<span class="token punctuation">:</span><br>            <span class="token function">DoLongTimeJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span></code></pre><p>我們來看看 fasthttp 怎麼處理</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">clientDoDeadline</span><span class="token punctuation">(</span>req <span class="token operator">*</span>Request<span class="token punctuation">,</span> resp <span class="token operator">*</span>Response<span class="token punctuation">,</span> deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> c clientDoer<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span><br>    timeout <span class="token operator">:=</span> <span class="token operator">-</span>time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>deadline<span class="token punctuation">)</span><br>    <span class="token comment">//...</span><br>    <span class="token keyword">var</span> ch <span class="token keyword">chan</span> <span class="token builtin">error</span><br>    <span class="token comment">//...</span><br>    <span class="token keyword">var</span> mu sync<span class="token punctuation">.</span>Mutex<br>    <span class="token keyword">var</span> timedout<span class="token punctuation">,</span> responded <span class="token builtin">bool</span><br>    <span class="token comment">//...</span><br>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token comment">//...</span><br>        errDo <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>reqCopy<span class="token punctuation">,</span> respCopy<span class="token punctuation">)</span><br>        mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">{</span><br>            <span class="token keyword">if</span> <span class="token operator">!</span>timedout <span class="token punctuation">{</span><br>                <span class="token comment">//...</span><br>                ch <span class="token operator">&lt;-</span> errDo<br>                responded <span class="token operator">=</span> <span class="token boolean">true</span><br>            <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br>        mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token comment">//...</span><br>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br><br>    tc <span class="token operator">:=</span> <span class="token function">AcquireTimer</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><br>    <span class="token keyword">var</span> err <span class="token builtin">error</span><br>    <span class="token keyword">select</span> <span class="token punctuation">{</span><br>    <span class="token keyword">case</span> err <span class="token operator">=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span><br>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>tc<span class="token punctuation">.</span>C<span class="token punctuation">:</span><br>        mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>        <span class="token punctuation">{</span><br>            <span class="token keyword">if</span> responded <span class="token punctuation">{</span><br>                err <span class="token operator">=</span> <span class="token operator">&lt;-</span>ch<br>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>                timedout <span class="token operator">=</span> <span class="token boolean">true</span><br>                err <span class="token operator">=</span> ErrTimeout<br>            <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br>        mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br>    <span class="token comment">//...</span><br><span class="token punctuation">}</span></code></pre><p>這個 func 用來處理帶有 timeout 的請求，我們將焦點擺在，fasthttp 是怎麼處理請求時間大於 timeout 的問題？func 主要分成兩塊，一塊是 select，會等待請求完成，或者請求超時；另一塊是 Goroutine，會執行請求，並將結果傳給 select 監聽的 channel。因為 select 會阻塞等待結果或超時，這就達到了類似搶占式的效果，只要一超時，func 就立刻返回，不會再等待。</p><p>那 Goroutine 呢？這裡的 Goroutine 像是用後即棄的資源，它在超時後依然會繼續執行，只是 final statement 的操作都不會放在裡面，不影響 Graceful shutdown。假設 Goroutine 在很久後的某個時間點執行完畢，它看到被放生了，就會默默自行關閉。這給了我們一個提示：重要的不僅是知道 Goroutine 何時關閉，也要知道 Goroutine 關閉前需要處置哪些資源。</p><h2 id="%E5%9F%B7%E8%A1%8C%E6%9C%9F%E9%96%93%E7%9A%84%E7%95%B0%E5%B8%B8%E7%8B%80%E6%B3%81"><a href="#%E5%9F%B7%E8%A1%8C%E6%9C%9F%E9%96%93%E7%9A%84%E7%95%B0%E5%B8%B8%E7%8B%80%E6%B3%81" class="direct-link">#</a> 執行期間的異常狀況</h2><p>前面的例子都在討論怎麼讓 Goroutine 能夠關閉，不要永久佔用資源，但另一方面，Goroutine 也可能因為種種原因突然關閉，例如程式設計不當，存取了 nil address，或是沒設計好 critical section 導致 concurrency access，當然，還有重複關閉 channel。</p><p>為了保證 Goroutine 的錯誤不會造成系統崩潰，通常會在 Goroutine 中放入 recover，確保它能留下錯誤訊息然後結束</p><pre class="language-go"><code class="language-go"><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> err <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><br>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"panic"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>另外，Goroutine 也可能在執行期間出現 Dead Lock，導致任務無法正常執行，像這樣無法正常運作的 Goroutine 稱為 unhealthy，要如何確認 Goroutine 是不是 healthy 呢？最簡單的方式，就是定期打 heartbeat 出來，只要 heartbeat 有正常送出，代表 Goroutine 仍然在正常運行。</p><p>讓我們看個例子，底下是由 <a href="https://github.com/kat-co/concurrency-in-go-src" rel="noopener noreferrer" target="_blank"><em>Concurrency In Go</em></a> 中取出的簡化版本</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> timeout <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<br>    dataCh <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><br>    heartbeat <span class="token operator">:=</span> <span class="token function">doWork</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> timeout<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> dataCh<span class="token punctuation">)</span><br>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><br>        dataCh <span class="token operator">&lt;-</span> i<br>        <span class="token keyword">select</span> <span class="token punctuation">{</span><br>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>heartbeat<span class="token punctuation">:</span><br>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"receive heartbeat"</span><span class="token punctuation">)</span><br>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">:</span><br>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"worker goroutine is not healthy!"</span><span class="token punctuation">)</span><br>            <span class="token keyword">return</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>這個範例會透過 <code>dataCh</code> 將資料傳給 <code>doWork</code> 內的 Goroutine 處理，同時在外面定期接收一個 1s 的 heartbeat，如果 2s 沒收到，就判定 Goroutine unhealthy，印出錯誤訊息。</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">doWork</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> pulseInterval time<span class="token punctuation">.</span>Duration<span class="token punctuation">,</span> dataCh <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><br>    heartbeat <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><br>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        pulse <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Tick</span><span class="token punctuation">(</span>pulseInterval<span class="token punctuation">)</span><br>        sendPulse <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>            <span class="token keyword">select</span> <span class="token punctuation">{</span><br>            <span class="token keyword">case</span> heartbeat <span class="token operator">&lt;-</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">:</span><br>            <span class="token keyword">default</span><span class="token punctuation">:</span><br>            <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br>        <span class="token keyword">for</span> <span class="token punctuation">{</span><br>            <span class="token keyword">select</span> <span class="token punctuation">{</span><br>            <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">// &lt;1></span><br>                <span class="token keyword">return</span><br>            <span class="token keyword">case</span> <span class="token operator">&lt;-</span>pulse<span class="token punctuation">:</span>  <span class="token comment">// &lt;2></span><br>                <span class="token function">sendPulse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>            <span class="token keyword">case</span> i <span class="token operator">:=</span> <span class="token operator">&lt;-</span>dataCh<span class="token punctuation">:</span>  <span class="token comment">// &lt;3></span><br>                fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"processing %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><br>                <span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">5</span> <span class="token punctuation">{</span><br>                    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span> <span class="token comment">// assume dead lock</span><br>                <span class="token punctuation">}</span><br>            <span class="token punctuation">}</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token keyword">return</span> heartbeat<br><span class="token punctuation">}</span></code></pre><p><code>doWork</code> 內會建立 heartbeat channel 並放入閉包中。閉包內有三種 input：(1) 收到 Done 就結束 Goroutine；(2) 收到 timer 的提醒就送出 heartbeat；(3) 收到 data 就進行處理。從 CSP input/output 的觀點來看，加上 heartbeat 就是替 Goroutine 多添上 1 個 input 跟 1 個 output。而因為 CSP 循序執行的特性，如果 (3) 處理太久，將阻塞其他 input 的進行，變相阻止了 (2) 的 output 的輸出，外面監聽的程式就能知道 Goroutine 已經 dead lock 了。</p><p>來執行一下</p><pre class="language-bash"><code class="language-bash"><span class="token operator">></span> go run main.go<br><br>processing <span class="token number">0</span><br>receive heartbeat<br>processing <span class="token number">1</span><br>receive heartbeat<br>processing <span class="token number">2</span><br>receive heartbeat<br>processing <span class="token number">3</span><br>receive heartbeat<br>processing <span class="token number">4</span><br>receive heartbeat<br>processing <span class="token number">5</span><br>worker goroutine is not healthy<span class="token operator">!</span></code></pre><p>前面五個任務都正常運作，到第六個任務時，刻意讓 Goroutine 進入長時間睡眠，外頭監聽的 select 遲遲沒收到 heartbeat，就印出錯誤訊息並結束程式。</p><h2 id="%E5%B0%8F%E7%B5%90"><a href="#%E5%B0%8F%E7%B5%90" class="direct-link">#</a> 小結</h2><p>這篇談的細節比較多，但核心概念都是「如何控制 Goroutine 的狀態」，在設計併發時，盡可能把握住幾個原則</p><ul><li>每個 Goroutine 都要有結束條件</li><li>每個 Goroutine 都要有 recover 來捕捉 panic</li><li>關閉 Goroutine 前，注意相關的資源是不是都有釋放</li><li>Goroutine 的處理任務盡可能簡單，讓它能保持無狀態</li></ul><p>雖然像 heartbeat 這類技巧能更全面監控 Goroutine 的運行，但多少違反了簡單原則，在導入時要特別小心。如果有注意到的話，前面範例中的 heartbeat 不是直接用 time.Tick，而是包了一個 func 來送出，這是因為 receiver 要是沒有好好接收，反而會變成另一個 dead lock，塞住 Goroutine 的執行。</p><p>總之 Goroutine 不是免費的，我曾經遇過因為太方便開了一堆，結果峰值流量衝進來，直接打掛服務，最後還是要用 ratelimit 跟 Worker Pool 來控制數量。也希望看完這篇後，大家都能避免無意間埋下 OOM 的地雷。</p><h2 id="reference"><a href="#reference" class="direct-link">#</a> Reference</h2><ul><li><a href="https://tpaschalis.me/goroutines-size/" rel="noopener noreferrer" target="_blank">What is a goroutine? And what is their size?</a></li><li><a href="https://go.dev/src/runtime/stack.go#L950" rel="noopener noreferrer" target="_blank">Source file src/runtime/stack.go</a></li><li><a href="https://zhuanlan.zhihu.com/p/389029496" rel="noopener noreferrer" target="_blank">Goroutine 的数量有上限吗？</a></li><li><a href="https://github.com/kat-co/concurrency-in-go-src" rel="noopener noreferrer" target="_blank">GitHub - kat-co/concurrency-in-go-src</a></li><li><a href="https://segmentfault.com/a/1190000039294140" rel="noopener noreferrer" target="_blank">深度解析go context实现原理及其源码</a></li><li><a href="https://go.dev/talks/2012/concurrency.slide#1" rel="noopener noreferrer" target="_blank">Go Concurrency Patterns</a></li></ul><div class="article-footer"></div><div><p style="font-weight: bold;">標籤</p><div class="post-tags"><a href="/tags/go/" class="post-tag">Go</a> <a href="/tags/concurrency/" class="post-tag">Concurrency</a></div><p style="font-weight: bold;">其他文章</p><ul><li><a href="/posts/2022/store-config-in-the-environment-golang-practice/">配置存放於環境：Go 應用的配置實踐</a></li><li><a href="/posts/2022/go-dependency-injection-by-fx/">用 Fx 來替 Go 依賴注入吧</a></li><li><a href="/posts/2020/use-protobuf-in-golang/">一種更緊湊的數據格式：Protobuf 入門</a></li><li><a href="/posts/2019/use-commitizen-to-write-graceful-git-comment/">輕鬆上手約定式提交：Commitizen 初體驗</a></li><li><a href="/posts/2019/use-ansible-to-update-end-devices/">配置即代碼：Ansible 入門</a></li></ul></div><p style="font-weight: bold;">評論</p><script async="" src="https://utteranc.es/client.js" crossorigin="anonymous" id="utterance-script" issue-term="title" label="utterance" repo="ken00535/blog" theme="github-light"></script><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Goroutine 的併發治理：掌握生命週期","image":["https://blog.kenwsc.com/img/posts/2023/concurrency-of-go-goroutine-lifetime/context_tree-1920w.png"],"author":{"@type":"Person","name":""},"publisher":{"@type":"Organization","name":"Ken Chen&#39;s Blog","url":"https://blog.kenwsc.com","logo":{"@type":"ImageObject","url":"https://blog.kenwsc.com/img/favicon/favicon.png","width":512,"height":512}},"url":"https://blog.kenwsc.com/posts/2023/concurrency-of-go-goroutine-lifetime/","mainEntityOfPage":"https://blog.kenwsc.com/posts/2023/concurrency-of-go-goroutine-lifetime/","datePublished":"2023-01-06","dateModified":"2023-01-19","description":"從併發的角度來看，Goroutine 跟 Thread 的概念很類似，都是將任務交給一個執行單元來處理。然而不同的是，Goroutine 將調度放在用戶態，因此更加輕量，也能避免多餘的 Context Switch。我們可以說，Go..."}</script></article></main><footer><div class="footer-logos"><a href="https://medium.com/@ken00535" rel="noopener noreferrer" target="_blank"><img height="50" src="/img/icons/icon_social media_medium.svg" width="50" alt="medium"></a><a href="https://www.linkedin.com/in/ken00535" rel="noopener noreferrer" target="_blank"><img height="30" src="/img/icons/icon_social media_linkedln.svg" width="30" alt="linkedin"></a><a href="https://blog.kenwsc.com/feed/feed.xml" rel="noreferrer noopener" target="_blank"><img height="30" src="/img/icons/rss-feed.svg" width="30" alt="rss feed"></a></div><div class="copyright">© 2023 Ken Chen's Blog, Powered by <a href="https://github.com/google/eleventy-high-performance-blog" rel="noopener noreferrer" target="_blank">eleventy-high-performance-blog</a></div></footer><script>// light/dark theme switch
      // disable dark mode for now
      const menuBtn = document.querySelector('.menu__btn')
      menuBtn.addEventListener('click', function() {
        document.querySelector('body').classList.toggle('lock')
        menuBtn.classList.toggle('menu__btn--close');
        document.querySelector('.nav__links').classList.toggle('nav__links--open')
      })</script></body></html>