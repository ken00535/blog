<!DOCTYPE html><html domain="blog.kenwsc.com" ga-id="G-G76M9XJCKN" lang="zh-TW"><head><meta charset="utf-8"><meta content="width=device-width,initial-scale=1" name="viewport"><meta content="Backend,Golang" name="keywords"><link href="/img/favicon/favicon.png?hash=b6fc65e341" rel="icon" type="image/png"><meta content="#5789d3" name="theme-color"><title>如何優雅包裝錯誤：聊聊 Go 的 error</title><meta content="如何優雅包裝錯誤：聊聊 Go 的 error" property="og:title"><meta content="如何優雅包裝錯誤：聊聊 Go 的 error" name="twitter:title"><meta content="summary_large_image" name="twitter:card"><meta content="錯誤處理是 Golang 最常被討論的一個點。這有幾個因素，首先，這跟它「錯誤是值」的設計理念有關，開發者需要在業務流程中穿插錯誤處理，違反關注點分離的原則，當然會引發爭議。另外，在 1.13 前，Golang 標準 errors 庫的表現力有限，當需求較為複雜時，需要開發者自行發明錯誤處理輔助函式。這讓人不禁好奇，Golang 的錯誤處理設計原則是什麼？有沒有比較好的實踐？或者說，我們能不能找到一種方式，優雅地處理錯誤？…" name="description"><meta content="錯誤處理是 Golang 最常被討論的一個點。這有幾個因素，首先，這跟它「錯誤是值」的設計理念有關，開發者需要在業務流程中穿插錯誤處理，違反關注點分離的原則，當然會引發爭議。另外，在 1.13 前，Golang 標準 errors 庫的表現力有限，當需求較為複雜時，需要開發者自行發明錯誤處理輔助函式。這讓人不禁好奇，Golang 的錯誤處理設計原則是什麼？有沒有比較好的實踐？或者說，我們能不能找到一種方式，優雅地處理錯誤？…" name="twitter:description"><meta content="錯誤處理是 Golang 最常被討論的一個點。這有幾個因素，首先，這跟它「錯誤是值」的設計理念有關，開發者需要在業務流程中穿插錯誤處理，違反關注點分離的原則，當然會引發爭議。另外，在 1.13 前，Golang 標準 errors 庫的表現力有限，當需求較為複雜時，需要開發者自行發明錯誤處理輔助函式。這讓人不禁好奇，Golang 的錯誤處理設計原則是什麼？有沒有比較好的實踐？或者說，我們能不能找到一種方式，優雅地處理錯誤？…" property="og:description"><meta content="article" property="og:type"><meta content="https://blog.kenwsc.com/posts/2022/go-error-handling/" property="og:url"><meta content="Ken Chen's Blog" property="og:site_name"><meta content="https://blog.kenwsc.com/img/posts/2022/go-error-handling/cover.png" property="og:image"><meta content="https://blog.kenwsc.com/img/posts/2022/go-error-handling/cover.png" name="twitter:image"><meta content="hsZQwAip9iIbys-i4PJp_MfpNiA6w6RB0hYdWLiLUuk" name="google-site-verification"><link href="https://blog.kenwsc.com/posts/2022/go-error-handling/" rel="canonical"><meta content="always" name="referrer"><link href="/feed/feed.xml" rel="alternate" type="application/atom+xml" title="Ken Chen's Blog"><link href="/" rel="preconnect" crossorigin=""><script async="" src="/js/min.js?hash=7f26b2ece8" defer=""></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-G76M9XJCKN"></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-G76M9XJCKN');</script><script csp-hash="">if (/Mac OS X/.test(navigator.userAgent))document.documentElement.classList.add('apple')</script><style>:root{--primary-color: #5789d3;--primary-dark-color: #ffd349;--fgColor: #2f2f2f;--bgColor: linear-gradient(to top, #efefef, #ffffff);--primary: var(--primary-color);--primary-dark: var(--primary-dark-color);--fg: var(--fgColor);--bg: var(--bgColor);--progressColor: #ffd349;--main-width: calc(100vw - 3em)}main img{content-visibility:auto}article *{scroll-margin-top:50px}header nav{z-index:1;position:fixed;top:0;left:0;width:100vw;background:#fff;font-weight:200;text-align:right;padding:0}@media (min-width:37.5em){:root{--main-width: calc(37.5em - 3em)}}dialog,share-widget{position:fixed;opacity:.9}share-widget{right:20px;bottom:20px;width:50px;height:50px;border-radius:50%;overflow:hidden;box-shadow:2px 3px 5px 2px rgba(0,0,0,.2)}@media screen and (max-width:376px){share-widget{display:none}}share-widget div{margin-left:50%;transform:translateX(-50%);width:20px;height:20px;background-image:url(/img/share.svg);background-repeat:no-repeat;background-position:center;background-size:contain}.apple share-widget div{background-image:url(/img/share-apple.svg)}share-widget button{margin:0;padding:0;width:100%;height:100%;transition:.3s}share-widget button:active{transform:scale(1.2)}dialog{background-color:var(--primary-dark);z-index:1000;font-size:14px}#reading-progress{z-index:1;background-color:var(--progressColor);width:100vw;position:absolute;left:0;bottom:0;height:2px;transform:translate(-100vw,0);will-change:transform;pointer-events:none}#posts li{margin-bottom:.5em}button,html{line-height:1.15}html{-webkit-text-size-adjust:100%;font-family:"Open Sans",-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans","Helvetica Neue",Helvetica,Arial,"Noto Sans TC","PingFang TC","Hiragino Sans GB","Heiti TC","Microsoft YaHei","Microsoft Jhenghei",sans-serif;--font-family: "Open Sans", -apple-system, system-ui, BlinkMacSystemFont,
    "Segoe UI", Roboto, "Noto Sans", "Helvetica Neue", Helvetica, Arial,
    "Noto Sans TC", "PingFang TC", "Hiragino Sans GB", "Heiti TC",
    "Microsoft YaHei", "Microsoft Jhenghei", sans-serif}.article-footer img,body{margin:0}body.lock{overflow:hidden}a{background-color:transparent;text-underline-offset:2px;text-decoration:none;color:var(--primary)}b{font-weight:700}img{border-style:none;max-width:100%;height:auto;margin:0 auto}button{font-family:inherit;font-size:100%;overflow:visible;text-transform:none}[type=button],button{-webkit-appearance:button}[type=button]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}h2{font-size:2.5em;line-height:1.2;margin-bottom:.6em;line-height:2.4rem;margin-bottom:1.36rem;font-size:1.728rem}body,p,pre,ul{font-size:1em}p,pre,ul{margin-bottom:1.5em}body,p,pre,ul{font-size:1rem;line-height:1.6}p,pre,ul{margin-bottom:1.36rem}@media (min-width:600px){h2{font-size:2.0097rem;line-height:2.52rem}body,p,pre,ul{font-size:1.1rem;line-height:1.6}h2,p,pre,ul{margin-bottom:1.496rem}}@media (min-width:1200px){h2{font-size:1.75rem}body,p,pre,ul{font-size:1.2rem;line-height:1.6}h2,p,pre,ul{margin-bottom:1.632rem}}code,pre{overflow-x:auto}pre{font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace}pre code:not([class]){overflow-x:scroll}button,code{border-radius:.3em}code{color:#e33671;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:90%}h1,h2{font-family:var(--font-family)}a:hover{text-decoration:underline}@media (max-width:767px){x:-moz-any-link{display:table-cell}}button{max-width:100%;background:#f2f2f2;color:#191919;cursor:pointer;padding:.75em 1.5em;text-align:center;margin:0 .75em 1.5em 0}button+label,label+*{page-break-before:always}button,label{display:inline-block}button:hover{background:#d9d9d9;color:#000}button:not([disabled]){background:#f9c412;color:#181818;background:var(--primary)}button:not([disabled]):hover{background:#ba9005;color:#000;background:var(--primary-dark)}*{border:0;box-sizing:border-box}body{font-family:var(--font-family);background:var(--bg);color:var(--fg)}header label{display:block}article,header{max-width:100%;width:42.5em;margin:0 auto}header{padding:4.5em 24px 0;text-align:center;display:flex;align-items:center;flex-direction:column}header p,ul{margin-top:0}header nav label{color:#000;cursor:pointer;margin:0;font-style:normal;text-align:right}main{max-width:70rem;margin:0 auto;min-height:60vh}article{padding:1.5em;word-break:break-word}li ul{margin-bottom:0}blockquote{padding:0 1.5em;margin:1.5em 0 1.5em 1.5em;border-left:4px solid var(--primary)}blockquote footer{background:0 0;display:block;color:#ccc;padding:.75em 0;font-size:90%;text-align:start}code[class*=language-],pre[class*=language-]{color:#ccc;background:0 0;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#2d2d2d}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.comment{color:#999}.token.punctuation{color:#ccc}.token.boolean,.token.function,.token.number{color:#f08d49}.token.class-name,.token.property{color:#f8c555}.token.builtin,.token.keyword{color:#cc99cd}.token.string{color:#7ec699}.token.entity,.token.operator,.token.url{color:#67cdcc}.token.bold{font-weight:700}.token.entity{cursor:help}.token.inserted{color:green}::-webkit-scrollbar-thumb:hover{background:var(--primary)}.w-full{width:100%}body.dark{--fg: var(--bgColor);--bg: var(--fgColor);--primary: var(--primary-dark-color)}@media (prefers-color-scheme:dark){body.dark{--fg: var(--bgColor);--bg: var(--fgColor);--primary: var(--primary-dark-color)}}h1{font-size:32px;line-height:1.25;margin:.67em 0;text-align:left}header aside{font-size:16px;color:#4b4b4b}#nav,.menu__btn{position:relative}.menu__btn{display:inline-block;width:24px;height:24px}.menu__btn span{opacity:0;width:1px;height:1px;overflow:hidden;display:block}.menu__btn::after,.menu__btn::before{content:"";position:absolute;top:51%;left:50%;height:2px;width:17px;background-color:#2d2d2d;border-radius:.1rem}.menu__btn::before{transform:translate(-50%,-50%);box-shadow:0 .3rem 0 #2d2d2d,0 -.3rem 0 #2d2d2d}.menu__btn::after{display:none;transform:translate(-50%,-50%) rotate(90deg)}.menu__btn.menu__btn--close{z-index:9;transform:rotate(45deg)}.menu__btn.menu__btn--close::before{box-shadow:none}.menu__btn.menu__btn--close::after{display:block}#nav{height:68px;z-index:2;align-items:center}.nav__links{display:none;flex-direction:column;position:fixed;z-index:3;top:0;left:0;right:0;bottom:0;padding:86px 48px 0;background-image:linear-gradient(to top,#efefef,#fff),linear-gradient(to bottom,#f9f9f9,#f9f9f9)}#nav,.nav__links--open{display:flex}.nav__links a{text-align:left;width:100%;padding:.5rem 0;transition:all .3s ease-out;font-weight:700;text-decoration:none;color:var(--fg)}.nav__links a:hover{color:var(--primary-color)}footer{margin-top:48px;font-size:14px;padding:24px;border-top:1px solid #ccc;text-align:center}.copyright{display:inline-block}footer>*{margin:.5em}.footer-logos{display:flex;align-items:center;justify-content:center}.footer-logos a:not(:first-child){margin-left:32px}.post-tags{display:flex;gap:0 16px;flex-wrap:wrap}.post-tag:not(body){text-decoration:none;background-color:#f5f5f5;-webkit-box-align:center;-ms-flex-align:center;align-items:center;border-radius:20px;color:#4a4a4a;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;font-size:.75rem;height:2em;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;line-height:1.5;padding-left:.75em;padding-right:.75em;white-space:nowrap}.post-tag:hover{text-decoration:none;background:#ccc}.direct-link{display:none}.post-avatar{display:flex;align-items:center;height:36px}.post-avatar__time{font-size:13px}.article-footer{margin-top:40px;border-bottom:1px solid #ccc;padding-bottom:52px}.article-footer a{float:right;display:flex;align-items:center;color:var(--fg);font-weight:700;margin-left:4px}@media (min-width:768px){h1{font-size:48px}header aside{font-size:20px}header nav a:first-of-type{margin-left:auto}header nav a:last-of-type{margin-right:1.5em}.menu__btn{display:none}#nav,footer{max-width:1168px}#nav{height:80px;margin:0 auto}.nav__links{display:flex;flex-direction:row;position:static;padding:0;background-image:none}.nav__links a{text-align:center;margin-left:56px}footer{display:flex;flex-direction:row-reverse;justify-content:space-between;align-items:center;margin-left:auto;margin-right:auto}}</style></head><body><header><nav><div id="nav"><div class="nav__links"><a href="/" title="Homepage">Home</a> <a href="/archive/">Archive</a> <a href="/tags/">Tags</a> <a href="/about/">About</a></div></div><div id="reading-progress" aria-hidden="true"></div></nav><h1 class="w-full">如何優雅包裝錯誤：聊聊 Go 的 error</h1><aside class="w-full"><div class="post-avatar"><div class="post-avatar__time">Ken Chen | 16 Oct 2022 <a href="/tags/go/" class="post-tag">Go</a> <a href="/tags/devops/" class="post-tag">DevOps</a></div></div></aside><dialog id="message"></dialog></header><main><article><div id="post-page"></div><p>錯誤處理是 Golang 最常被討論的一個點。這有幾個因素，首先，這跟它「錯誤是值」的設計理念有關，開發者需要在業務流程中穿插錯誤處理，違反關注點分離的原則，當然會引發爭議。另外，在 1.13 前，Golang 標準 errors 庫的表現力有限，當需求較為複雜時，需要開發者自行發明錯誤處理輔助函式。這讓人不禁好奇，Golang 的錯誤處理設計原則是什麼？有沒有比較好的實踐？或者說，我們能不能找到一種方式，優雅地處理錯誤？</p><h2 id="%E9%8C%AF%E8%AA%A4%E8%88%87%E7%95%B0%E5%B8%B8"><a href="#%E9%8C%AF%E8%AA%A4%E8%88%87%E7%95%B0%E5%B8%B8" class="direct-link">#</a> 錯誤與異常</h2><p>先來看看不同人的觀點，Robert Martin 在討論到錯誤處理時，是如此建議的</p><blockquote><p>使用異常替代返回錯誤碼，錯誤處理代碼就能從主路徑代碼中分離出來，得到簡化</p></blockquote><p>他給出的例子是</p><pre class="language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span><br>    <span class="token function">deletePage</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    registry<span class="token punctuation">.</span><span class="token function">deleteReference</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    configKeys<span class="token punctuation">.</span><span class="token function">deleteKey</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">makeKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>Martin 指的是 Try Catch 模型。在 Try Catch 中，錯誤由函式中拋出，並在上層的處理函式中接住，進行處理。如 Robert Martin 講的，Try Catch 的主路徑跟錯誤處理代碼分開在不同區塊，這樣的好處是能讓責任明確。</p><p>而 Golang 的錯誤處理方式則是</p><pre class="language-go"><code class="language-go">f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"filename.ext"</span><span class="token punctuation">)</span><br><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><br>    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><span class="token comment">// do something with the open *File f</span></code></pre><p>很明顯的，主路徑跟錯誤處理會放在同一個區塊，可讀性沒有 Try Catch 來好。Rob Pike 對這問題曾經發表過一些意見</p><blockquote><p>In other languages, one might use a try-catch block or other such mechanism to handle errors. Therefore, the programmer thinks, when I would have used a try-catch in my old language, I will just type if err != nil in Go. Over time the Go code collects many such snippets, and the result feels clumsy.</p></blockquote><p>這段話講的有些曖昧，大致來說，Rob Pike 認為這問題的關鍵是，開發者使用了舊的習慣來開發 Golang，也就是說，他認為問題的解法應該要在應用端，而不是語言。</p><p>說曖昧的原因是，Pike 沒正面回答，為什麼 Golang 不支援 Try Catch？是 Try Catch 有什麼問題，或者只是 Golang 的設計者沒想到？我猜想，有個可能的原因是，Golang 嘗試區分出異常與錯誤。依照 Java 的定義，錯誤指該問題超出應用程式的處理能力，是執行期不該出現的狀況，例如 Out of Memory；而異常則是指不符合預期的情況，像是在資料庫中找不到特定的資料。對於前者，程式通常會立刻停止執行；而後者，程式會嘗試處理，給出當下可接受的回應。</p><p>在 Java 的模型中，錯誤跟異常使用同樣的方式來處理，當開發者需要明確處理異常時，他會指定 Exception 的類型，如果該類型沒有被上層的處理函式 Catch，就會繼續往上拋，直到程式錯誤。因此，這背後隱含一個邏輯，沒有被明確處理的異常就是錯誤，並帶來一個問題，由於 Exception 可以不斷上拋，使得開發者必須有意識地使用 Try Catch，否則會破壞分層原則。</p><p>相較於 Java，Golang 的設計理念更多取徑於 C 語言，C 語言常見的錯誤處理長這樣</p><pre class="language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">_shutdown_mib_modules</span><span class="token punctuation">(</span><span class="token keyword">int</span> majorID<span class="token punctuation">,</span> <span class="token keyword">int</span> minorID<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>serve<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>client<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// do something</span><br>    <span class="token keyword">return</span> SNMPERR_SUCCESS<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>在 C 語言的慣例中，錯誤會用 status code 回傳，通常 0 是正常，而其他值代表不同的 error。在這裡，「值」是很重要的概念，儘管 C 語言是因為語言限制，被迫把 error 當值回傳，但 Golang 有意識地繼承了這項設計。 對Golang 來講，error 僅僅是一種回傳值，不會採取不同的方式來處理，而對於執行期發生的嚴重錯誤，則走 panic / recover 的機制</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">mayPanic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"a problem"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> r <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> r <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><br>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Recovered. Error:\n"</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token function">mayPanic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"After mayPanic()"</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>藉由這項設計，Golang 在語言的層次上區分錯誤與異常，並要求開發者在函式返回的當下，立刻顯式處理。</p><h2 id="error-%E7%9A%84%E5%AF%A6%E7%8F%BE%E6%96%B9%E5%BC%8F"><a href="#error-%E7%9A%84%E5%AF%A6%E7%8F%BE%E6%96%B9%E5%BC%8F" class="direct-link">#</a> error 的實現方式</h2><p>明白設計原則後，緊接而來的問題是，Golang 中的 error 是什麼？它又是如何實現？用最通俗的話來講，error 是實作 Error() 接口的結構，這是另一項設計理念「鴨子型別」的展現。對開發者來講，最簡單的方式，是使用標準庫的 errors.New 來產生 error</p><pre class="language-go"><code class="language-go"><span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"this is error"</span><span class="token punctuation">)</span></code></pre><p>底層的實作則是</p><pre class="language-go"><code class="language-go"><span class="token keyword">package</span> errors<br><br><span class="token comment">// New returns an error that formats as the given text.</span><br><span class="token comment">// Each call to New returns a distinct error value even if the text is identical.</span><br><span class="token keyword">func</span> <span class="token function">New</span><span class="token punctuation">(</span>text <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> <span class="token operator">&</span>errorString<span class="token punctuation">{</span>text<span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// errorString is a trivial implementation of error.</span><br><span class="token keyword">type</span> errorString <span class="token keyword">struct</span> <span class="token punctuation">{</span><br>    s <span class="token builtin">string</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>errorString<span class="token punctuation">)</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> e<span class="token punctuation">.</span>s<br><span class="token punctuation">}</span></code></pre><p>可以看到 errorString 本質上是個 struct，裡面帶有 text 字段儲存錯誤訊息。也因為 errors.New 回傳的是 pointer of struct，即使 text 的內容相同，兩個 error 也會被當成是不同的 error。</p><p>既然每個 error 都是不同的，那要如何確認錯誤類型呢？原理很簡單，只要同樣類型的 error 是來自同一個實例即可，例如，我們可以用 Sentinel Error 的方式，在包內部預先定義需要的 error，要使用時直接回傳，在標準庫內部常常可以看到類似的做法，像是 io.EOF</p><pre class="language-go"><code class="language-go"><span class="token keyword">var</span> EOF <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"EOF"</span><span class="token punctuation">)</span></code></pre><p>還記得「錯誤是值」嗎？開發者可以用處理值的方式來處理 error</p><pre class="language-go"><code class="language-go">data<span class="token punctuation">,</span> err <span class="token operator">:=</span> io<span class="token punctuation">.</span><span class="token function">ReadAll</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><br><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span><br>    <span class="token comment">// error handling</span><br><span class="token punctuation">}</span></code></pre><p>這裡確實能感受到 Golang 跟 C 語言的系譜關係。</p><h2 id="%E9%8C%AF%E8%AA%A4%E4%B8%8A%E4%B8%8B%E6%96%87"><a href="#%E9%8C%AF%E8%AA%A4%E4%B8%8A%E4%B8%8B%E6%96%87" class="direct-link">#</a> 錯誤上下文</h2><p>當我們將目光拉回開發應用場景，要求 error 資訊中需要有上下文（也就是，錯誤中包含哪些錯誤）時，我們會發現 Golang 1.13 前的標準 errors 庫能力有限，需要開發者自行實現。在 “Working with Errors in Go 1.13” 中，Damien Neil 跟 Jonathan Amsterdam 詳細說明了這個狀況</p><blockquote><p>Frequently a function passes an error up the call stack while adding information to it, like a brief description of what was happening when the error occurred. A simple way to do this is to construct a new error that includes the text of the previous one</p></blockquote><pre class="language-go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"decompress %v: %v"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> err<span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>要知道上下文，只要將前面 error 的 Message 提取出來，放入新的 Message 即可。然而，也如 Damien Neil 跟 Jonathan Amsterdam 提到的，單純將資訊放在字串，會有資訊劣化的問題，如果開發者想追蹤上下文中是否存在特定的 error，改成嵌入會是更好的方式</p><pre class="language-go"><code class="language-go"><span class="token keyword">type</span> QueryError <span class="token keyword">struct</span> <span class="token punctuation">{</span><br>    Query <span class="token builtin">string</span><br>    Err   <span class="token builtin">error</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">if</span> e<span class="token punctuation">,</span> ok <span class="token operator">:=</span> err<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>QueryError<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token operator">&&</span> e<span class="token punctuation">.</span>Err <span class="token operator">==</span> ErrPermission <span class="token punctuation">{</span><br>    <span class="token comment">// query failed because of a permission problem</span><br><span class="token punctuation">}</span></code></pre><p>有人可能會問了，假如是多層嵌套的話，也需要一層一層來拆嗎？顯然的，需要有一個更簡便的方式，幫助我們返回底層錯誤，換句話說，需要把 error 的包裝跟拆裝標準化，讓我們可以用遞迴的方式來拆解 error。為了處理這問題，Golang 在 1.13 後，引入了 Unwrap function</p><pre class="language-go"><code class="language-go"><span class="token comment">// Unwrap returns the result of calling the Unwrap method on err, if err's</span><br><span class="token comment">// type contains an Unwrap method returning error.</span><br><span class="token comment">// Otherwise, Unwrap returns nil.</span><br><span class="token keyword">func</span> <span class="token function">Unwrap</span><span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span><br>    u<span class="token punctuation">,</span> ok <span class="token operator">:=</span> err<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">interface</span> <span class="token punctuation">{</span><br>        <span class="token function">Unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span><br>    <span class="token punctuation">}</span><span class="token punctuation">)</span><br>    <span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span><br>        <span class="token keyword">return</span> <span class="token boolean">nil</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">return</span> u<span class="token punctuation">.</span><span class="token function">Unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>Unwrap 檢查該 error 是否實作 Unwrap interface，如果有，就調用 Unwrap ，拆出下一層的 error。</p><p>既然有拆就有包，實作上要怎麼方便的包裝錯誤呢？自行將 error 嵌入自定義結構也是個選擇，但由於這個場景非常常見，Golang 1.13 在語言的標準庫中實現了包裝，用法是</p><pre class="language-go"><code class="language-go"><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><br>    <span class="token comment">// Return an error which unwraps to err.</span><br>    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"decompress %v: %w"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> err<span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>當參數 %w 出現，返回的 error 會自動帶上 Unwrap func，它的內部是包裝過的 wrapError</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Errorf</span><span class="token punctuation">(</span>format <span class="token builtin">string</span><span class="token punctuation">,</span> a <span class="token operator">...</span>any<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span><br>    p <span class="token operator">:=</span> <span class="token function">newPrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    p<span class="token punctuation">.</span>wrapErrs <span class="token operator">=</span> <span class="token boolean">true</span><br>    p<span class="token punctuation">.</span><span class="token function">doPrintf</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> a<span class="token punctuation">)</span><br>    s <span class="token operator">:=</span> <span class="token function">string</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>buf<span class="token punctuation">)</span><br>    <span class="token keyword">var</span> err <span class="token builtin">error</span><br>    <span class="token keyword">if</span> p<span class="token punctuation">.</span>wrappedErr <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><br>        err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        err <span class="token operator">=</span> <span class="token operator">&</span>wrapError<span class="token punctuation">{</span>s<span class="token punctuation">,</span> p<span class="token punctuation">.</span>wrappedErr<span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br>    p<span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token keyword">return</span> err<br><span class="token punctuation">}</span></code></pre><p>如此，就完成包裝拆裝的標準介面了。</p><p>當要追蹤 error 的上下文中是否包含特定的 error，我們可以先比較最外層的 error，如果不同，使用 Unwrap 拆裝後，再比較下一層的 error。Golang 1.13 同樣實現了 <a href="http://errors.Is" rel="noopener noreferrer" target="_blank">errors.Is</a> function 來簡化操作</p><pre class="language-go"><code class="language-go"><span class="token comment">// Similar to:</span><br><span class="token comment">// if err == ErrNotFound { … }</span><br><span class="token keyword">if</span> errors<span class="token punctuation">.</span><span class="token function">Is</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> ErrNotFound<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// something wasn't found</span><br><span class="token punctuation">}</span></code></pre><p>它的實現是不停的比較跟拆包</p><pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Is</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> target <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> target <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><br>        <span class="token keyword">return</span> err <span class="token operator">==</span> target<br>    <span class="token punctuation">}</span><br>    isComparable <span class="token operator">:=</span> reflectlite<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Comparable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token keyword">for</span> <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> isComparable <span class="token operator">&&</span> err <span class="token operator">==</span> target <span class="token punctuation">{</span><br>            <span class="token keyword">return</span> <span class="token boolean">true</span><br>        <span class="token punctuation">}</span><br>        <span class="token keyword">if</span> x<span class="token punctuation">,</span> ok <span class="token operator">:=</span> err<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">{</span> <span class="token function">Is</span><span class="token punctuation">(</span><span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token operator">&&</span> x<span class="token punctuation">.</span><span class="token function">Is</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>            <span class="token keyword">return</span> <span class="token boolean">true</span><br>        <span class="token punctuation">}</span><br>        <span class="token keyword">if</span> err <span class="token operator">=</span> <span class="token function">Unwrap</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><br>            <span class="token keyword">return</span> <span class="token boolean">false</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>有意思的是，在比較過程中，它不單單看 err == target，還允許開發者自定相等的條件 Is(error) bool。</p><h2 id="%E5%91%BC%E5%8F%AB%E5%A0%86%E7%96%8A"><a href="#%E5%91%BC%E5%8F%AB%E5%A0%86%E7%96%8A" class="direct-link">#</a> 呼叫堆疊</h2><p>Golang 1.13 上下文問題的提案是參考<a href="https://github.com/pkg/errors" rel="noopener noreferrer" target="_blank">社群方案</a></p><p>但不知道為什麼，Golang 標準庫只採用跟上下文有關的部分，有時候我們需要更多細節，像是為了追蹤 error 產生的位置，讓開發者能快速定位錯誤，還需要 Call Stack 資訊，這時要動用另一個標準庫 runtime</p><pre class="language-go"><code class="language-go"><span class="token keyword">const</span> depth <span class="token operator">=</span> <span class="token number">32</span><br><span class="token keyword">var</span> pcs <span class="token punctuation">[</span>depth<span class="token punctuation">]</span><span class="token builtin">uintptr</span><br>runtime<span class="token punctuation">.</span><span class="token function">Callers</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> pcs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>透過呼叫 runtime.Callers，可以取得 Call Stack。回想剛剛要加入上下文資訊時，用的方式是在 struct 內嵌入 error 的字段；同樣的道理，要加入 Call Stack，也只要再多嵌入一個 stack 字段</p><pre class="language-go"><code class="language-go"><span class="token keyword">type</span> withStack <span class="token keyword">struct</span> <span class="token punctuation">{</span><br>    <span class="token builtin">error</span><br>    <span class="token operator">*</span>stack<br><span class="token punctuation">}</span></code></pre><p>stack 是個 pointer array，存放取得的 Call Stack 資訊。儘管標準庫沒有實現上述的內容，但 pkg/errors 有幫忙做好了</p><pre class="language-go"><code class="language-go"><span class="token comment">// customized message</span><br>err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">Wrapf</span><span class="token punctuation">(</span><span class="token string">"error num is: %d"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><br><br><span class="token comment">// just wrap call stack</span><br>err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">WithStack</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span></code></pre><p>我們可以透過 WithStack func 來理解 pkg/errors 的實作方式</p><pre class="language-go"><code class="language-go"><span class="token comment">// WithStack annotates err with a stack trace at the point WithStack was called.</span><br><span class="token comment">// If err is nil, WithStack returns nil.</span><br><span class="token keyword">func</span> <span class="token function">WithStack</span><span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><br>        <span class="token keyword">return</span> <span class="token boolean">nil</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">return</span> <span class="token operator">&</span>withStack<span class="token punctuation">{</span><br>        err<span class="token punctuation">,</span><br>        <span class="token function">callers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>簡單明瞭，直接將 callers 塞進去。也印出來看看效果</p><pre class="language-go"><code class="language-go">err <span class="token operator">:=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"some error"</span><span class="token punctuation">)</span><br>err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">WithStack</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><br>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><pre class="language-bash"><code class="language-bash"><span class="token comment"># console</span><br>$ go run main.go <br>some error</code></pre><p>咦？怎麼好像沒看到 Call Stack？這是因為 Call Stack 的資訊只是用來除錯，不會放在錯誤訊息 Error() 中，所以要印時要用 %+v</p><pre class="language-go"><code class="language-go">err <span class="token operator">:=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"some error"</span><span class="token punctuation">)</span><br>err <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">WithStack</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><br>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%+v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span></code></pre><pre class="language-bash"><code class="language-bash"><span class="token comment"># console</span><br>$ go run main.go <br>some error<br>main.main<br>        ken/playground/error_demo/main.go:47<br>runtime.main<br>        ken/go/src/runtime/proc.go:250<br>runtime.goexit<br>        ken/go/src/runtime/asm_amd64.s:1571</code></pre><p>如果有使用 Sentry 的話，也能在 issue 中看到 Call Stack 的資訊，對除錯很有幫助，會知道錯誤發生在哪一行、前面經過哪些路徑，加上必要的參數，就能輕鬆完成錯誤定位</p><p><picture><source sizes="(max-width: 758px) 100vw, 758px" srcset="/img/posts/2022/go-error-handling/error-1-1920w.webp 1920w, /img/posts/2022/go-error-handling/error-1-1280w.webp 1280w, /img/posts/2022/go-error-handling/error-1-840w.webp 840w, /img/posts/2022/go-error-handling/error-1-320w.webp 320w" type="image/webp"><source sizes="(max-width: 758px) 100vw, 758px" srcset="/img/posts/2022/go-error-handling/error-1-1920w.png 1920w, /img/posts/2022/go-error-handling/error-1-1280w.png 1280w, /img/posts/2022/go-error-handling/error-1-840w.png 840w, /img/posts/2022/go-error-handling/error-1-320w.png 320w" type="image/png"><img alt="" height="582" src="/img/posts/2022/go-error-handling/error-1-1920w.png" width="1328" decoding="async" loading="lazy" style="background-size:cover;background-image:url(&#34;data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http%3A//www.w3.org/2000/svg' xmlns%3Axlink='http%3A//www.w3.org/1999/xlink' viewBox='0 0 1328 582'%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='.5'%3E%3C/feGaussianBlur%3E%3CfeComponentTransfer%3E%3CfeFuncA type='discrete' tableValues='1 1'%3E%3C/feFuncA%3E%3C/feComponentTransfer%3E%3C/filter%3E%3Cimage filter='url(%23b)' preserveAspectRatio='none' height='100%25' width='100%25' xlink%3Ahref='data%3Aimage/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAFCAIAAAD+GJp4AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjUlEQVQImSXEiw6CMAxA0f3/LxqByUOIyta1a/fowKA3J9e4gOAh51xVtbVrx692nOcRY0lSDaDsOzlHABJCQkzMVURFlFklaUpqtgXvt/dkg+2D7cB28Bjw0uNkaRziOrOJkpwPHjAgI3EgBowYRXLNRXNtuarZfRyXz9+yuem5z6t7OfZUPRVPBWL5AurkqjNDP5/hAAAAAElFTkSuQmCC'%3E%3C/image%3E%3C/svg%3E&#34;)"></picture></p><h2 id="%E9%A0%98%E5%9F%9F-error-%E8%88%87-api-error"><a href="#%E9%A0%98%E5%9F%9F-error-%E8%88%87-api-error" class="direct-link">#</a> 領域 error 與 API error</h2><p>接著來看題應用題。假設你跟我一樣是個後端應用開發的工程師，希望在 API 的 Error Response 中放入錯誤的詳細訊息，像是哪個參數錯誤，好讓對接的前端工程師可以用錯誤訊息進行初步判斷，但卻又不希望過度曝露系統資訊，例如完整的錯誤上下文。我們可以怎麼做？</p><p>這是個開發者體驗設計問題，具體而言，要達成的目標是：降低前端工程師的開發成本，降低後端系統除錯成本，以及隱藏不必要的資訊。因此我們從系統的角度來看，如果套用分層的概念，領域層級的 error 跟 API 層級的 error 應該要放在不同層</p><p><picture><source sizes="(max-width: 758px) 100vw, 758px" srcset="/img/posts/2022/go-error-handling/error-2-1920w.webp 1920w, /img/posts/2022/go-error-handling/error-2-1280w.webp 1280w, /img/posts/2022/go-error-handling/error-2-840w.webp 840w, /img/posts/2022/go-error-handling/error-2-320w.webp 320w" type="image/webp"><source sizes="(max-width: 758px) 100vw, 758px" srcset="/img/posts/2022/go-error-handling/error-2-1920w.png 1920w, /img/posts/2022/go-error-handling/error-2-1280w.png 1280w, /img/posts/2022/go-error-handling/error-2-840w.png 840w, /img/posts/2022/go-error-handling/error-2-320w.png 320w" type="image/png"><img alt="" height="542" src="/img/posts/2022/go-error-handling/error-2-1920w.png" width="805" decoding="async" loading="lazy" style="background-size:cover;background-image:url(&#34;data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http%3A//www.w3.org/2000/svg' xmlns%3Axlink='http%3A//www.w3.org/1999/xlink' viewBox='0 0 805 542'%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='.5'%3E%3C/feGaussianBlur%3E%3CfeComponentTransfer%3E%3CfeFuncA type='discrete' tableValues='1 1'%3E%3C/feFuncA%3E%3C/feComponentTransfer%3E%3C/filter%3E%3Cimage filter='url(%23b)' preserveAspectRatio='none' height='100%25' width='100%25' xlink%3Ahref='data%3Aimage/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAGCAIAAACepSOSAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfUlEQVQImR2NwQ6DIBBE+f8P7LVpQmpVFGqFdYGZbXBOL+/wxtm91rGkMId1TqvUahzS0QyA1vZa/H5+/Tb9pJBG0mnrorUDpIkoSYJFtIi66wganqqtg3pdAFqHxLds3kmc9POorTfwzGUkyCPtcVtdzjmmdH/byHEgQAB/XUycszHKJWoAAAAASUVORK5CYII='%3E%3C/image%3E%3C/svg%3E&#34;)"></picture></p><p>領域層級的 error 用來描述符合系統使用情境的錯誤；API 層級的 error 則專注於接口設計，以 gin 當範例，兩個的關係是</p><pre class="language-go"><code class="language-go"><span class="token comment">// httpErr represents an error that occurred while handling a request.</span><br><span class="token keyword">type</span> httpErr <span class="token keyword">struct</span> <span class="token punctuation">{</span><br>    Message <span class="token builtin">string</span> <span class="token string">`json:"message"`</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// ErrorHandler responds error response according to given error.</span><br><span class="token keyword">func</span> <span class="token function">ErrorHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> gin<span class="token punctuation">.</span>HandlerFunc <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    c<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Errors<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span><br>        <span class="token keyword">return</span><br>    <span class="token punctuation">}</span><br>    err <span class="token operator">:=</span> c<span class="token punctuation">.</span>Errors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><br>    <span class="token keyword">var</span> status <span class="token builtin">int</span><br>    <span class="token keyword">switch</span> <span class="token punctuation">{</span><br>    <span class="token keyword">case</span> errors<span class="token punctuation">.</span><span class="token function">Is</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> entity<span class="token punctuation">.</span>ErrInvalidInput<span class="token punctuation">)</span><span class="token punctuation">:</span><br>        status <span class="token operator">=</span> http<span class="token punctuation">.</span>StatusBadRequest<br>    <span class="token keyword">case</span> errors<span class="token punctuation">.</span><span class="token function">Is</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> entity<span class="token punctuation">.</span>ErrUnauthorized<span class="token punctuation">)</span><span class="token punctuation">:</span><br>        status <span class="token operator">=</span> http<span class="token punctuation">.</span>StatusUnauthorized<br>    <span class="token keyword">case</span> errors<span class="token punctuation">.</span><span class="token function">Is</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> entity<span class="token punctuation">.</span>ErrPermissionDenied<span class="token punctuation">)</span><span class="token punctuation">:</span><br>        status <span class="token operator">=</span> http<span class="token punctuation">.</span>StatusForbidden<br>    <span class="token keyword">default</span><span class="token punctuation">:</span><br>        status <span class="token operator">=</span> http<span class="token punctuation">.</span>StatusInternalServerError<br>    <span class="token punctuation">}</span><br>    c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>status<span class="token punctuation">,</span> httpErr<span class="token punctuation">{</span>Message<span class="token punctuation">:</span> err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>上面的設計有個小問題，httpErr 直接使用 err.Error() 當 Error Response Body，如果 err 是透過 Wrap 來包裝，Error() 可能會有上下文資訊，像是違反哪條資料庫的 Constraint，而這資訊是我們不想曝露給外部調用者的。因此如果可以，應該要對 entity.Error 再進行一次包裝，讓它分開上下文與原始 error 的資訊。</p><p>我們可以照抄 pkg/errors 的方法，但多出一個 Message function，用來提供外界訊息</p><pre class="language-go"><code class="language-go"><span class="token keyword">type</span> AppError <span class="token keyword">struct</span> <span class="token punctuation">{</span><br>    cause   <span class="token builtin">error</span><br>    message <span class="token builtin">string</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>AppError<span class="token punctuation">)</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> <span class="token string">"app error: "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>message <span class="token operator">+</span> <span class="token string">":"</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>cause<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>AppError<span class="token punctuation">)</span> <span class="token function">Message</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> e<span class="token punctuation">.</span>message<br><span class="token punctuation">}</span><br><br><span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>AppError<span class="token punctuation">)</span> <span class="token function">Unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> w<span class="token punctuation">.</span>cause <span class="token punctuation">}</span><br><br><span class="token keyword">func</span> <span class="token function">Wrapf</span><span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">,</span> format <span class="token builtin">string</span><span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><br>        <span class="token keyword">return</span> <span class="token boolean">nil</span><br>    <span class="token punctuation">}</span><br>    err <span class="token operator">=</span> <span class="token operator">&</span>Error<span class="token punctuation">{</span><br>        cause<span class="token punctuation">:</span>   err<span class="token punctuation">,</span><br>        message<span class="token punctuation">:</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">return</span> errors<span class="token punctuation">.</span><span class="token function">WithStack</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>在 gin 的 Middleware，先使用 <a href="http://errors.As" rel="noopener noreferrer" target="_blank">errors.As</a>() 來型別斷言，再調用 Message()，修改成</p><pre class="language-go"><code class="language-go">err <span class="token operator">:=</span> errors<span class="token punctuation">.</span><span class="token function">Unwrap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Errors<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><br><span class="token keyword">var</span> appErr entity<span class="token punctuation">.</span>AppError<br><span class="token keyword">if</span> errors<span class="token punctuation">.</span><span class="token function">As</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> <span class="token operator">&</span>appErr<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">var</span> status <span class="token builtin">int</span><br>    <span class="token keyword">switch</span> <span class="token punctuation">{</span><br>    <span class="token keyword">case</span> errors<span class="token punctuation">.</span><span class="token function">Is</span><span class="token punctuation">(</span>appErr<span class="token punctuation">,</span> entity<span class="token punctuation">.</span>ErrInvalidInput<span class="token punctuation">)</span><span class="token punctuation">:</span><br>        status <span class="token operator">=</span> http<span class="token punctuation">.</span>StatusBadRequest<br>    <span class="token keyword">case</span> errors<span class="token punctuation">.</span><span class="token function">Is</span><span class="token punctuation">(</span>appErr<span class="token punctuation">,</span> entity<span class="token punctuation">.</span>ErrUnauthorized<span class="token punctuation">)</span><span class="token punctuation">:</span><br>        status <span class="token operator">=</span> http<span class="token punctuation">.</span>StatusUnauthorized<br>    <span class="token keyword">case</span> errors<span class="token punctuation">.</span><span class="token function">Is</span><span class="token punctuation">(</span>appErr<span class="token punctuation">,</span> entity<span class="token punctuation">.</span>ErrPermissionDenied<span class="token punctuation">)</span><span class="token punctuation">:</span><br>        status <span class="token operator">=</span> http<span class="token punctuation">.</span>StatusForbidden<br>    <span class="token keyword">default</span><span class="token punctuation">:</span><br>        status <span class="token operator">=</span> http<span class="token punctuation">.</span>StatusInternalServerError<br>    <span class="token punctuation">}</span><br>    c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>status<span class="token punctuation">,</span> httpErr<span class="token punctuation">{</span>Message<span class="token punctuation">:</span> appErr<span class="token punctuation">.</span><span class="token function">Message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><br><span class="token punctuation">}</span></code></pre><p>要注意這裡有個微妙的前後關係，是先意識到分層的必要性，透過分離責任來分離訊息，而不是反過來，先實作結構，再透過分離訊息來分離責任。</p><h2 id="%E7%B5%90%E8%AA%9E"><a href="#%E7%B5%90%E8%AA%9E" class="direct-link">#</a> 結語</h2><p>簡單總結內容：error 中最重要的兩項資訊是 Error Message 跟 Call Stack，儘管 Golang 在 1.13 後的標準庫已經有加入上下文的處理，但為了更符合應用場景與節省自己的時間，還是會建議用 pkg/errors 來處理 error。</p><p>也因為 Call Stack 是重要資訊，當收到 error 的第一時間，應該用 Wrapf 重新包裝成 AppError，讓開發者後續要追蹤時，可以一路查找到底。至於 ApiError 的處理，則是放在 Middleware，讓責任可以分離得更清楚。</p><p>當然，如果你是開發 lib，就像 Golang 標準庫常見的那樣，用 Sentinel Error 就可以了。lib 應該盡可能保持簡單；而應用則是盡可能讓責任保持簡單。希望大家看完這篇文後，都能優雅地處理錯誤。</p><h2 id="reference"><a href="#reference" class="direct-link">#</a> Reference</h2><ul><li><a href="https://go.dev/blog/error-handling-and-go" rel="noopener noreferrer" target="_blank">Error handling and Go - The Go Programming Language</a></li><li><a href="https://go.dev/blog/errors-are-values" rel="noopener noreferrer" target="_blank">Errors are values - The Go Programming Language</a></li><li><a href="https://go.dev/blog/go1.13-errors" rel="noopener noreferrer" target="_blank">Working with Errors in Go 1.13</a></li><li><a href="https://hackmd.io/@fieliapm/SJYqZtpuv?print-pdf#/" rel="noopener noreferrer" target="_blank">Survive under the Crap Go Error System - HackMD</a></li></ul><div class="article-footer"></div><div><p style="font-weight: bold;">標籤</p><div class="post-tags"><a href="/tags/go/" class="post-tag">Go</a> <a href="/tags/devops/" class="post-tag">DevOps</a></div><p style="font-weight: bold;">其他文章</p><ul><li><a href="/posts/2020/database-migration-by-go/">資料庫版本遷移：以 Go 為例</a></li><li><a href="/posts/2020/use-protobuf-in-golang/">一種更緊湊的數據格式：Protobuf 入門</a></li><li><a href="/posts/2020/use-conan-to-manage-c-package/">Conan：C/C++ 的套件管理工具</a></li><li><a href="/posts/2019/use-prometheus-to-monitor-end-devices/">監控節點的度量指標：Prometheus 入門</a></li><li><a href="/posts/2019/coding-by-your-smartphone/">全世界都是你的工作室：GCP 的雲端開發環境</a></li></ul></div><p style="font-weight: bold;">評論</p><script async="" src="https://utteranc.es/client.js" crossorigin="anonymous" id="utterance-script" issue-term="title" label="utterance" repo="ken00535/blog" theme="github-light"></script><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"如何優雅包裝錯誤：聊聊 Go 的 error","image":["https://blog.kenwsc.com/img/posts/2022/go-error-handling/error-1-1920w.png","https://blog.kenwsc.com/img/posts/2022/go-error-handling/error-2-1920w.png"],"author":{"@type":"Person","name":""},"publisher":{"@type":"Organization","name":"Ken Chen&#39;s Blog","url":"https://blog.kenwsc.com","logo":{"@type":"ImageObject","url":"https://blog.kenwsc.com/img/favicon/favicon.png","width":512,"height":512}},"url":"https://blog.kenwsc.com/posts/2022/go-error-handling/","mainEntityOfPage":"https://blog.kenwsc.com/posts/2022/go-error-handling/","datePublished":"2022-10-16","dateModified":"2022-12-15","description":"錯誤處理是 Golang 最常被討論的一個點。這有幾個因素，首先，這跟它「錯誤是值」的設計理念有關，開發者需要在業務流程中穿插錯誤處理，違反關注點分離的原則，當然會引發爭議。另外，在 1.13 前，Golang 標準 errors..."}</script></article></main><footer><div class="footer-logos"><a href="https://medium.com/@ken00535" rel="noopener noreferrer" target="_blank"><img alt="medium" height="50" src="/img/icons/icon_social media_medium.svg" width="50"></a><a href="https://www.linkedin.com/in/ken00535" rel="noopener noreferrer" target="_blank"><img alt="linkedin" height="30" src="/img/icons/icon_social media_linkedln.svg" width="30"></a><a href="https://blog.kenwsc.com/feed/feed.xml" rel="noreferrer noopener" target="_blank"><img alt="rss feed" height="30" src="/img/icons/rss-feed.svg" width="30"></a></div><div class="copyright">© 2022 Ken Chen's Blog, Powered by <a href="https://github.com/google/eleventy-high-performance-blog" rel="noopener noreferrer" target="_blank">eleventy-high-performance-blog</a></div></footer><script>// light/dark theme switch
      // disable dark mode for now
      const menuBtn = document.querySelector('.menu__btn')
      menuBtn.addEventListener('click', function() {
        document.querySelector('body').classList.toggle('lock')
        menuBtn.classList.toggle('menu__btn--close');
        document.querySelector('.nav__links').classList.toggle('nav__links--open')
      })</script></body></html>