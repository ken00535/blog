{
  "version": "https://jsonfeed.org/version/1",
  "title": "Ken Chen&#39;s Blog",
  "home_page_url": "https://blog.kenwsc.com",
  "feed_url": "https://blog.kenwsc.com/feed/feed.json",
  "description": "Ken Chen&#39;s Blog",
  "author": {
    "name": "Ken Chen",
    "url": ""
  },
  "items": [{
      "id": "https://blog.kenwsc.com/posts/2022/concurrency-of-go-error-handling/",
      "url": "https://blog.kenwsc.com/posts/2022/concurrency-of-go-error-handling/",
      "title": "Goroutine 的併發治理：由錯誤處理談起",
      "content_html": "<p>當需要同時執行多個任務時，Go 開發者會多開 Goroutine 來分擔任務，這稱為併發。併發聽起來似乎很理想，能其他任務等待時，照樣執行需要運算的任務，有效利用 CPU 資源，但如果要用在生產環境，它也需要完善的管理機制。想想看，Goroutine 在哪個情況下會被啟動？哪個情況下會結束？如果任務需要回傳結果，它應該要怎麼回傳？而如果執行中發生錯誤，又應該怎麼處理？</p>\n<p>我們可以稱呼這類主題為「併發治理」，需要開發者理解執行期的運作，而如何處理好 Goroutine 的開始與結束，讓錯誤能被意識到，可說是併發治理的第一關。</p>\n<h2 id=\"%E5%9F%BA%E6%9C%AC%E4%BD%B5%E7%99%BC\"><a class=\"direct-link\" href=\"#%E5%9F%BA%E6%9C%AC%E4%BD%B5%E7%99%BC\">#</a> 基本併發</h2>\n<p>來看個基本的併發操作。我們起 100 個 Goroutine，讓它們處理任務。如果執行時發生 error，就呼叫 HandleError 處理錯誤。</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token keyword\">var</span> wg sync<span class=\"token punctuation\">.</span>WaitGroup<br>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\twg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><br>\t\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>i <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t\t\terr <span class=\"token operator\">:=</span> <span class=\"token function\">DoTask</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><br>\t\t\t<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span><br>\t\t\t\t<span class=\"token function\">HandleError</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br>\t\t\t<span class=\"token punctuation\">}</span><br>\t\t\twg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><br>\t<span class=\"token punctuation\">}</span><br>\twg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">DoTask</span><span class=\"token punctuation\">(</span>i <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span> <span class=\"token punctuation\">{</span><br>\terr <span class=\"token operator\">:=</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Errorf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d: some err\"</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><br>\t<span class=\"token keyword\">return</span> err<br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">HandleError</span><span class=\"token punctuation\">(</span>err <span class=\"token builtin\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>這裡用 Go 標準包的 wait group 來管理 Goroutine，啟動 Goroutine 前，先用 wg.Add 將計數器加 1，Goroutine 執行完後，再用 wg.Done 將計數器減 1。等所有計數器歸零，代表 Goroutine 全部執行完成。wait group 的功用是同步化，確保主程式結束前，所有的 Goroutine 都執行完畢。</p>\n<p>在這個模型中，Goroutine 的錯誤是在 Goroutine 中被處理，這讓 Goroutine 承擔額外的任務，例如它可能會需要依賴 Logger 才能處理錯誤，這也降低 Goroutine 的可測試性。如果我們希望分離彼此的責任，集中管理錯誤的話，就得想個方式，把錯誤傳出來。</p>\n<h2 id=\"%E5%85%B1%E4%BA%AB%E8%A8%98%E6%86%B6%E9%AB%94%E4%BE%86%E9%80%9A%E8%A8%8A\"><a class=\"direct-link\" href=\"#%E5%85%B1%E4%BA%AB%E8%A8%98%E6%86%B6%E9%AB%94%E4%BE%86%E9%80%9A%E8%A8%8A\">#</a> 共享記憶體來通訊</h2>\n<p>第一種傳遞錯誤的方式稱為 Shared memory，可以想像成把 Goroutine 中發生的錯誤記錄在某個儲存空間，等待 Goroutine 執行完後再來處理，程式碼類似</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> lock sync<span class=\"token punctuation\">.</span>Mutex<br><span class=\"token keyword\">var</span> errs <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">error</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token keyword\">var</span> wg sync<span class=\"token punctuation\">.</span>WaitGroup<br>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\twg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><br>\t\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>i <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t\t\terr <span class=\"token operator\">:=</span> <span class=\"token function\">DoTask</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><br>\t\t\t<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span><br>\t\t\t\tlock<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t\t\t\terrs <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>errs<span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span><br>\t\t\t\tlock<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t\t\t<span class=\"token punctuation\">}</span><br>\t\t\twg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><br>\t<span class=\"token punctuation\">}</span><br>\twg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token keyword\">for</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> errs <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token function\">HandleError</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br>\t<span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>這段程式用 slice 來存放錯誤，因為 slice 沒保證併發安全，使用時要記得用 sync.Mutex 鎖起來再操作。</p>\n<p>這個模型有什麼問題呢？因為引入互斥鎖，Goroutine 執行期間有了同步化機制，讓不同的 Goroutine 可能會互相等待；再來，當應用變得複雜的時候，可能會存在好幾個鎖，一不小心就會造成 Dead Lock；另外，使用 Shared Memory 意味著所有 Goroutine 都能 Access 共享區塊，如果有哪個 Goroutine 沒有遵守規範，修改了共享區塊內的值，就會影響到其他的 Goroutine。開發者原本從錯誤處理釋放出來的專注力，變成要轉投入到併發處理，從結果來講，對生產力幫助有限。</p>\n<h2 id=\"errgroup\"><a class=\"direct-link\" href=\"#errgroup\">#</a> errGroup</h2>\n<p>既然目標是處理錯誤，我們可以建立一些前提，針對這個情境特化，讓併發治理跟業務邏輯分離開來。具體來講，希望對 wait group 與 Goroutine 的使用進行封裝。這就來到 <a href=\"https://pkg.go.dev/golang.org/x/sync/errgroup\">golang.org/x/sync/errgroup</a> 這個 package 了，先來上 code</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span><br>\t<span class=\"token string\">\"fmt\"</span><br>\t<span class=\"token string\">\"time\"</span><br><br>\t<span class=\"token string\">\"golang.org/x/sync/errgroup\"</span><br><span class=\"token punctuation\">)</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token keyword\">var</span> eg errgroup<span class=\"token punctuation\">.</span>Group<br>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\teg<span class=\"token punctuation\">.</span><span class=\"token function\">Go</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span> <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token keyword\">return</span> <span class=\"token function\">DoTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token keyword\">if</span> err <span class=\"token operator\">:=</span> eg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token function\">HandleError</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br>\t<span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>eg.Go 會啟動一個 Goroutine，而 eg.Wait 會等待所有的 Goroutine 都執行完畢，如果在執行過程中有發生錯誤，eg.Wait 會將錯誤回傳給處理函式。</p>\n<p>從名稱看，eg 封裝了 wait group 的邏輯，可以讓操作變得更簡單，它的內部實現跟原本 wait group 的操作類似</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>g <span class=\"token operator\">*</span>Group<span class=\"token punctuation\">)</span> <span class=\"token function\">Go</span><span class=\"token punctuation\">(</span>f <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token keyword\">if</span> g<span class=\"token punctuation\">.</span>sem <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span><br>\t\tg<span class=\"token punctuation\">.</span>sem <span class=\"token operator\">&lt;-</span> token<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><br>\t<span class=\"token punctuation\">}</span><br><br>\tg<span class=\"token punctuation\">.</span>wg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token keyword\">defer</span> g<span class=\"token punctuation\">.</span><span class=\"token function\">done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><br>\t\t<span class=\"token keyword\">if</span> err <span class=\"token operator\">:=</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span><br>\t\t\tg<span class=\"token punctuation\">.</span>errOnce<span class=\"token punctuation\">.</span><span class=\"token function\">Do</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t\t\t\tg<span class=\"token punctuation\">.</span>err <span class=\"token operator\">=</span> err<br>\t\t\t\t<span class=\"token keyword\">if</span> g<span class=\"token punctuation\">.</span>cancel <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span><br>\t\t\t\t\tg<span class=\"token punctuation\">.</span><span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t\t\t\t<span class=\"token punctuation\">}</span><br>\t\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>只是用到 sync.Once 來鎖定 critical section。</p>\n<p>errgroup 幫助開發者分離併發治理與業務邏輯，也降低無意中引發 Dead Lock 的可能性。</p>\n<h2 id=\"%E7%94%A8%E9%80%9A%E8%A8%8A%E4%BE%86%E5%85%B1%E4%BA%AB%E8%B3%87%E8%A8%8A\"><a class=\"direct-link\" href=\"#%E7%94%A8%E9%80%9A%E8%A8%8A%E4%BE%86%E5%85%B1%E4%BA%AB%E8%B3%87%E8%A8%8A\">#</a> 用通訊來共享資訊</h2>\n<p>還有沒有其他的可能呢？不妨換另一個角度來看待錯誤的傳遞。在 Go 中，錯誤是一種值，如果把 Goroutine 看成是處理值的處理程序，那只要能定義出程序的 input/output，就能將值傳遞出去。可能有人會想，這跟 function 不是差不多的意思嗎？是的，但關鍵在於，Goroutine 間不是順序式的關係，而是程序式的併發關係，在訊息經過 Goroutine 內部循序處理後，它會透過交談的方式，傳遞給另一個 Goroutine，這套模型又因此被稱為交談循序程式(CSP)。依照 CSP 的語法結構，可以修改程式為</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t<span class=\"token keyword\">var</span> wg sync<span class=\"token punctuation\">.</span>WaitGroup<br>\terrCh <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">error</span><span class=\"token punctuation\">)</span><br>\troutineEndCh <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><br>\tlogEndCh <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token keyword\">struct</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\twg<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><br>\t\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>i <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t\t\terr <span class=\"token operator\">:=</span> <span class=\"token function\">DoTask</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><br>\t\t\t<span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span><br>\t\t\t\terrCh <span class=\"token operator\">&lt;-</span> err<br>\t\t\t<span class=\"token punctuation\">}</span><br>\t\t\twg<span class=\"token punctuation\">.</span><span class=\"token function\">Done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><br>\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token keyword\">select</span> <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token keyword\">case</span> err <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>errCh<span class=\"token punctuation\">:</span><br>\t\t\t\t<span class=\"token function\">HandleError</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br>\t\t\t<span class=\"token keyword\">case</span> <span class=\"token operator\">&lt;-</span>routineEndCh<span class=\"token punctuation\">:</span><br>\t\t\t\t<span class=\"token function\">close</span><span class=\"token punctuation\">(</span>logEndCh<span class=\"token punctuation\">)</span><br>\t\t\t\t<span class=\"token keyword\">return</span><br>\t\t\t<span class=\"token punctuation\">}</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\t\twg<span class=\"token punctuation\">.</span><span class=\"token function\">Wait</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t\t<span class=\"token function\">close</span><span class=\"token punctuation\">(</span>routineEndCh<span class=\"token punctuation\">)</span><br>\t<span class=\"token punctuation\">}</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token operator\">&lt;-</span>logEndCh<br><span class=\"token punctuation\">}</span></code></pre>\n<p>在這段程式中，Goroutine 產生的錯誤被送進 channel，而錯誤處理的函式則放在另一個 Goroutine，假設稱為 G2，G2 在 channel 的一端接收錯誤，收到後立刻進行錯誤處理。此外，我們需要明訂 G2 的結束時間，因此開了再一個 Goroutine G3 來協調，當 wait group 的任務都結束後，G3 會關閉 routineEndCh，讓 G2 的 case 2 可以執行並關閉，G2 關閉前同樣關閉 logEndCh，讓主程式順利結束。</p>\n<p>儘管用到一些看起來很潮的字，在採用模型前，我們還是得先自問，這個做法真的有比較好嗎？程式碼長度由 20L 變成 30L，還有許多 channel 的同步處理問題，它對生產力真的有幫助嗎？</p>\n<p>唔，這是個好問題，CSP 的設計類似數學，從設計層面上切開彼此的相依性（在數學中，沒有狀態這回事）。在程式碼中，我們可以察覺到，原本的 Goroutine 跟 G2 間變成像是生產者跟消費者的關係，當訊息一生產出來，G2 會立刻消費它，讓程式變成像是生產線一樣，訊息處理完後，會被送到下一站繼續處理。而在共享記憶體的例子中，訊息是先搜集起來放在記憶體中，等待 Goroutine 完成後再批次處理。使用 channel 串接的方式，儘管不見得有更好的總處理時間(total time)，但理論上，避免了批次性的等待，它應該會具備更好的平均處理時間(average time)。</p>\n<p>技術本質上，channel 也是使用加鎖後複製值來實現，但它具備更高級的應用語義，我們可以把 channel 看成是對底層技術的封裝，因為這層封裝，開發者可以區別出生產者與消費者，也保證了消息的唯一性，從而在設計上防止 race condition 的發生。</p>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>在討論 Go 的併發時，質數篩是個很經典的例子，用共享記憶體的方式，質數篩會是</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\tn <span class=\"token operator\">:=</span> <span class=\"token number\">20</span><br>\tprimes <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><br>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">*</span>i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>primes<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span><br>\t\t\t<span class=\"token keyword\">for</span> j <span class=\"token operator\">:=</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">*</span>i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\t\t\tprimes<span class=\"token punctuation\">[</span>i<span class=\"token operator\">*</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><br>\t\t\t<span class=\"token punctuation\">}</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\t<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>primes<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span><br>\t\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><br>\t\t<span class=\"token punctuation\">}</span><br>\t<span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>但如果用 CSP 方式，則會變成</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>\tc <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><br>\t<span class=\"token keyword\">go</span> <span class=\"token function\">counter</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><br><br>\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">20</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span><br>\t\tp <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span> c<br>\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><br>\t\tprimes <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><br>\t\t<span class=\"token keyword\">go</span> <span class=\"token function\">filter</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">,</span> primes<span class=\"token punctuation\">)</span><br>\t\tc <span class=\"token operator\">=</span> primes<br>\t<span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>很明顯，兩個模型一對照，CSP 的可讀性更低，因為人類對訊息的理解是歷時性，而不是共時性的。我們可以輕易回想起某場棒球賽的再見全壘打，卻不容易記得某個賽季的平均打擊率。既然如此，為什麼我們會需要用反人類的方式來設計？因為當程式像數學一樣運作，它會變得無狀態、鬆耦合、更適合機器執行。至於可讀性方面，errgroup 給了一個靈感，我們可以將 channel 的操作封裝起來，透過框架來解決併發問題。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"https://pkg.go.dev/golang.org/x/sync@v0.1.0/errgroup\">errgroup package - golang.org/x/sync/errgroup - Go Packages</a></li>\n<li><a href=\"https://blog.kennycoder.io/2021/10/03/Golang-errGroup-%E7%94%A8%E6%B3%95%E5%8F%8A%E9%81%A9%E7%94%A8%E6%83%85%E5%A2%83/\">Golang - errGroup 用法及適用情境</a></li>\n</ul>\n",
      "date_published": "2022-12-07T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2022/three-semantics-of-rabbitmq/",
      "url": "https://blog.kenwsc.com/posts/2022/three-semantics-of-rabbitmq/",
      "title": "關於消息的三層語義：以 RabbitMQ 為例",
      "content_html": "<p>對分散式系統來說，消息的可靠性非常重要，想想一個金融應用的場景，如果在支付時，消息遺失了，或是重複遞送了，都會造成使用者的困擾。當我們在系統中引入消息隊列時，我們同時引入了複雜度，這意思是，系統的「處理消息」跟你想的不一定是同一件事。從可靠性的角度來看，「處理消息」的語義可以分為三個層次，第一層是「最多一次」，當你請系統處理消息時，它會幫你進行，但最多一次，並且不保證是否完成；第二層是「最少一次」，系統會幫你處理消息，而且附帶必要的錯誤處理，確保消息至少被完成一次；第三層是「準確一次」，意指消息不多不少，恰恰好被準確處理並完成了一次。</p>\n<p>當試著從語言學的角度來看待系統時，我們才能規劃出系統的整體面貌。儘管「準確處理一次」有最佳的可靠性，但因為其處理成本，降低了系統整體的吞吐量。在〈Starbucks Does Not Use Two-Phase Commit〉一文中，Gregor Hohpe 精確描繪了星巴克的異步系統。收銀員收費後，將咖啡杯放到隊列中，等待咖啡師處理，再交給取貨區的顧客。這個過程中，收銀員跟咖啡師不會特別確認咖啡杯的狀態，假設咖啡杯被放錯位置，直到顧客反應前都沒有人會知道，這是「最多一次」的語義；但如果咖啡杯掉落到地上，他們可能會重新做一杯新的咖啡，這裡就是「最少一次」的語義。因此我們可以說，星巴克是在「最多一次」的基礎上，有部分操作實現「最少一次」的語義。</p>\n<h2 id=\"amqp-%26-rabbitmq\"><a class=\"direct-link\" href=\"#amqp-%26-rabbitmq\">#</a> AMQP &amp; RabbitMQ</h2>\n<p>軟體的隊列設計也需要面臨類似問題，讓我們來看看 AMQP 的例子。AMQP 是由 JP Morgan Chase 提出的通訊協定，目的是為了讓消息隊列有個開放式的標準可以依循，如此一來，不同的語言跟架構能夠建置共通的應用程式。在 2007 年，Rabbit 公司開發一套開源軟體來實作 AMQP，稱為 RabbitMQ，現在由 Pivotal 維護。也因為它開源加上支持多語言客戶端，許多消息隊列會採用 RabbitMQ 來執行。</p>\n<p>AMQP 的訊框格式是</p>\n<pre><code>+ — — — + — — — — -+ — — — — -+ + — — — — — — -+ + — — — — — -+\n| type  | channel  | size     | | payload      | | frame-end  |\n+ — — — + — — — — -+ — — — — -+ + — — — — — — -+ + — — — — — -+\n</code></pre>\n<p>訊框的類型(type)分為 4 種。應用上常碰到的有 3 種</p>\n<ul>\n<li>METHOD(1)：該訊框用於傳送 AMQP 的指令</li>\n<li>HEADER(2)：該訊框用於傳送 AMQP 的標頭</li>\n<li>BODY(3)：該訊框用於傳送 AMQP 的內容</li>\n</ul>\n<p>其中 METHOD 會依照命令的不同，而有不同的參數(Argument)，實現越進階的語義就需要仰賴越複雜的設定。</p>\n<h2 id=\"at-most-once\"><a class=\"direct-link\" href=\"#at-most-once\">#</a> At most once</h2>\n<p>先從最基本的「最多一次」來看。最多一次可以指生產端，也可以指消費端。對生產端來說，只要發佈一次消息就算完成語義，後續也不會再重發。這裡我們使用開源庫  <a href=\"https://github.com/wagslane/go-rabbitmq\">go-rabbitmq</a>，來當 Golang 的 RabbitMQ 的客戶端，程式碼會是</p>\n<pre class=\"language-go\"><code class=\"language-go\">producer<span class=\"token punctuation\">.</span><span class=\"token function\">Publish</span><span class=\"token punctuation\">(</span><br>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token function\">byte</span><span class=\"token punctuation\">(</span>“hello”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><br>    routingKeys<span class=\"token punctuation\">,</span><br>    rabbitmq<span class=\"token punctuation\">.</span><span class=\"token function\">WithPublishOptionsExchange</span><span class=\"token punctuation\">(</span>exchangeName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">)</span></code></pre>\n<p>指定好內文、路由規則、還有交換器，進行發送。</p>\n<p>因為已經保證了傳遞「最多一次」，消費端只要在這基礎上進行消費，就能達成語義</p>\n<pre class=\"language-go\"><code class=\"language-go\">consumer<span class=\"token punctuation\">.</span><span class=\"token function\">StartConsuming</span><span class=\"token punctuation\">(</span><br>    consumeMessage<span class=\"token punctuation\">,</span><br>    queueName<span class=\"token punctuation\">,</span><br>    routingKeys<span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">)</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">consumeMessage</span><span class=\"token punctuation\">(</span>d rabbitmq<span class=\"token punctuation\">.</span>Delivery<span class=\"token punctuation\">)</span> rabbitmq<span class=\"token punctuation\">.</span>Action <span class=\"token punctuation\">{</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">.</span>Body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><br>    <span class=\"token keyword\">return</span> rabbitmq<span class=\"token punctuation\">.</span>Ack<br><span class=\"token punctuation\">}</span></code></pre>\n<p>指定消費函數、隊列名稱、路由規則來消費。</p>\n<p>用 WireShark 抓封包的話，會看到 Basic.Publish 發佈了一次的消息</p>\n<p><img src=\"/img/posts/2022/three-semantics-of-rabbitmq/wireshark-rabbitmq-1.webp\" alt=\"\"></p>\n<p>消費端也用 Basic.Consume 進行了消費</p>\n<p><img src=\"/img/posts/2022/three-semantics-of-rabbitmq/wireshark-rabbitmq-2.webp\" alt=\"\"></p>\n<h2 id=\"at-least-once\"><a class=\"direct-link\" href=\"#at-least-once\">#</a> At least once</h2>\n<p>「最多一次」對於分散式系統的應用來說是遠遠不夠的，假設客戶購買商品，產生一則消息，這個消息卻在傳遞的過程中因為一些網路問題而讓消息丟失，像是某人突然拔掉網路線，或是供電的電廠跳電，如果使用「最多一次」的語義，直到客戶反應前，我們都不會知道這個問題，同時，因為消息傳遞到一半丟失，有可能會造成系統狀態不一致，有部分系統已經執行過消息，有部分系統則是沒有。</p>\n<p>如果問題是由消息丟失引起的，最直覺的想法就是重試。想想，客戶向星巴克的店員抱怨，他點的咖啡還沒好，店員查詢後發現漏單，因此重做一份，這稱為重試(Retry)。</p>\n<p>同樣先從生產端來看。要重試，就需要先知道原本的消息是有否正確傳遞。這裡可以用 AMQP 的 Confirm 機制 來實現，時序圖上是</p>\n<p><img src=\"/img/posts/2022/three-semantics-of-rabbitmq/pub-and-sub.webp\" alt=\"\"></p>\n<p>在建立 channel 時，聲明這個 channel 需要 confirm。Broker 收到後會回 Confirm.Select-Ok，表示同意生產者將 channel 設為 confirm。之後，每次生產者發佈消息後，都會收到 Ack，如果因為 RabbitMQ 自身的問題導致消息丟失，則會回傳 Nack 給生產者。</p>\n<p>程式碼會是</p>\n<pre class=\"language-go\"><code class=\"language-go\">comfirmCh <span class=\"token operator\">:=</span> producer<span class=\"token punctuation\">.</span><span class=\"token function\">NotifyPublish</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>producer<span class=\"token punctuation\">.</span><span class=\"token function\">Publish</span><span class=\"token punctuation\">(</span><br>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token function\">byte</span><span class=\"token punctuation\">(</span>“hello”<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><br>    routingKeys<span class=\"token punctuation\">,</span><br>    rabbitmq<span class=\"token punctuation\">.</span><span class=\"token function\">WithPublishOptionsExchange</span><span class=\"token punctuation\">(</span>exchangeName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><br>    rabbitmq<span class=\"token punctuation\">.</span>WithPublishOptionsMandatory<span class=\"token punctuation\">,</span><br>    rabbitmq<span class=\"token punctuation\">.</span>WithPublishOptionsPersistentDelivery<span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">)</span><br>comfirmation <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>comfirmCh<br>fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span>“receive<span class=\"token punctuation\">:</span> <span class=\"token operator\">%</span><span class=\"token operator\">+</span>v\\n”<span class=\"token punctuation\">,</span> comfirmation<span class=\"token punctuation\">)</span></code></pre>\n<p>遺憾的是，僅僅這樣還不算達到「至少一次」的語義。讓我們更進一步思考情境。假設 Broker 能收到消息，可是卻因為設定的因素，導致消息無法被放入隊列，例如使用了一組不存在的路由規則。那 AMQP 應該如何通知這類「運行正常但邏輯有誤」的情況呢？這時需要用到 mandatory 這個 Publish 的參數。</p>\n<p>當 Publish 附帶 mandatory 時，生產端會告訴 Broker，這則消息需要被放進 Queue 中，如果沒辦法放入的話，需要將此消息退回給我。在程式碼上，需要改成</p>\n<pre class=\"language-go\"><code class=\"language-go\">comfirmCh <span class=\"token operator\">:=</span> producer<span class=\"token punctuation\">.</span><span class=\"token function\">NotifyPublish</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>returnCh <span class=\"token operator\">:=</span> producer<span class=\"token punctuation\">.</span><span class=\"token function\">NotifyReturn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>err <span class=\"token operator\">=</span> producer<span class=\"token punctuation\">.</span><span class=\"token function\">Publish</span><span class=\"token punctuation\">(</span><br>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token function\">byte</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><br>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"non-existence\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><br>    rabbitmq<span class=\"token punctuation\">.</span><span class=\"token function\">WithPublishOptionsExchange</span><span class=\"token punctuation\">(</span>exchangeName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><br>    rabbitmq<span class=\"token punctuation\">.</span>WithPublishOptionsMandatory<span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">)</span><br>comfirmation <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;-</span>comfirmCh<br>fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"receive: %+v\\n\"</span><span class=\"token punctuation\">,</span> comfirmation<span class=\"token punctuation\">)</span><br>returnVal <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>returnCh<br>fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"receive: %+v\\n\"</span><span class=\"token punctuation\">,</span> returnVal<span class=\"token punctuation\">)</span><br><span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>到此，我們可以確保消息會被放進隊列，但我們仍然沒辦法確保這則消息被放進隊列後，Broker 會突然關閉，導致消息丟失。要防範這情況，就需要持久化隊列中的消息。RabbitMQ 的持久化分爲三個部分：交換器的持久化、隊列的持久化和消息的持久化。這裡會需要操作的是後兩者。如果只設置隊列持久化，重啓 RabbitMQ 後，消息會丟失；只設置消息的持久化，重啓之後隊列消失，繼而消息也丟失。因此隊列跟消息的持久化都需要設定。</p>\n<p>要設定隊列的持久化，用</p>\n<pre class=\"language-go\"><code class=\"language-go\">conn<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> amqp<span class=\"token punctuation\">.</span><span class=\"token function\">Dial</span><span class=\"token punctuation\">(</span>cfg<span class=\"token punctuation\">.</span>Url<span class=\"token punctuation\">)</span><br>ch<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> conn<span class=\"token punctuation\">.</span><span class=\"token function\">Channel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token comment\">// the second arg is durable</span><br><span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> err <span class=\"token operator\">=</span> ch<span class=\"token punctuation\">.</span><span class=\"token function\">QueueDeclare</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span></code></pre>\n<p>同時，在發布的消息中設定消息持久化</p>\n<pre class=\"language-go\"><code class=\"language-go\">err <span class=\"token operator\">=</span> producer<span class=\"token punctuation\">.</span><span class=\"token function\">Publish</span><span class=\"token punctuation\">(</span><br>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token function\">byte</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><br>    routingKeys<span class=\"token punctuation\">,</span><br>    rabbitmq<span class=\"token punctuation\">.</span><span class=\"token function\">WithPublishOptionsExchange</span><span class=\"token punctuation\">(</span>exchangeName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><br>    rabbitmq<span class=\"token punctuation\">.</span>WithPublishOptionsMandatory<span class=\"token punctuation\">,</span><br>    rabbitmq<span class=\"token punctuation\">.</span>WithPublishOptionsPersistentDelivery<span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">)</span></code></pre>\n<p>來看 WireShark 抓到的封包</p>\n<p><img src=\"/img/posts/2022/three-semantics-of-rabbitmq/wireshark-rabbitmq-3.webp\" alt=\"\"></p>\n<p>可以看到 Header 的 Delivery-Mode 被設為 2，指的就是有持久化消息。</p>\n<p>在傳遞「最少一次」的基礎上，消費端要保證消息也至少被消費一次。這個相對單純，只需要消費完成後，用 Ack 回應 Broker 消費已完成。如果 Broker 沒收到 Ack 且連結斷開，那再下次建立連結時，Broker 會重新發送消息。</p>\n<h2 id=\"exactly-once\"><a class=\"direct-link\" href=\"#exactly-once\">#</a> Exactly once</h2>\n<p>「最少一次」的問題很明顯，要是消息不斷被重複發送，有可能導致同樣的消息被重複處理，以電商的情境為例，有可能出現重複扣款的狀況。對於重複不敏感的場景，例如物聯網資訊蒐集，「最少一次」已經足以應付，但對金融場景來講，重複扣款是個嚴重的問題。</p>\n<p>為了達到「準確一次」的語義，會需要在「最少一次」的基礎上，加上去重複的機制。最直覺的想法是替所有消息都加上 ID，當收到消息時，會將該 ID 緩存起來，日後如果收到新的消息，先確認緩存中沒有重複的 ID 再進行處理。這個技巧又稱為「冪等鍵」，意思是將操作冪等化，不論重複送多少次，都會得到相同的結果。</p>\n<p>RabbitMQ 沒有實作緩存確認的機制，因此無法保證「準確一次」。這可以分兩個方向來看，假設生產端正在等待 Broker 回覆 Confirm，此時網路斷開，生產端偵測到異常，為了滿足「至少一次」，生產端重複發送消息，RabbitMQ 的 Broker 中就會存在兩條相同的消息。或者，消費端在消費完消息後，因為網路斷開，Broker 沒收到 Ack，則在連線恢復後，Broker 會將同樣的消息再度發送給消費端，造成重複消費。</p>\n<p>如上面講到的，因為 RabbitMQ 沒有辦法保證每個步驟能「準確一次」，我們得退而求其次，希望能做到端到端的「準確一次」。這代表說，我們不在意 RabbitMQ 中間是否存在重複遞送，只要訊息最後能被準確消費一次即可。</p>\n<p>要達成這件事，生產端需要替每則訊息加上 unique ID</p>\n<pre class=\"language-go\"><code class=\"language-go\">err <span class=\"token operator\">=</span> producer<span class=\"token punctuation\">.</span><span class=\"token function\">Publish</span><span class=\"token punctuation\">(</span><br>    <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token function\">byte</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><br>    routingKeys<span class=\"token punctuation\">,</span><br>    rabbitmq<span class=\"token punctuation\">.</span><span class=\"token function\">WithPublishOptionsMessageID</span><span class=\"token punctuation\">(</span>uniqueID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><br>    rabbitmq<span class=\"token punctuation\">.</span><span class=\"token function\">WithPublishOptionsExchange</span><span class=\"token punctuation\">(</span>exchangeName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><br>    rabbitmq<span class=\"token punctuation\">.</span>WithPublishOptionsMandatory<span class=\"token punctuation\">,</span><br>    rabbitmq<span class=\"token punctuation\">.</span>WithPublishOptionsPersistentDelivery<span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">)</span></code></pre>\n<p>消費端收到訊息後，確認緩存內沒有 uniqueID，再進行處理</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">consumeMessage</span><span class=\"token punctuation\">(</span>d rabbitmq<span class=\"token punctuation\">.</span>Delivery<span class=\"token punctuation\">)</span> rabbitmq<span class=\"token punctuation\">.</span>Action <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">if</span> cache<span class=\"token punctuation\">.</span><span class=\"token function\">IsExist</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">.</span>MessageId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"duplicated message\"</span><span class=\"token punctuation\">)</span><br>        <span class=\"token keyword\">return</span> rabbitmq<span class=\"token punctuation\">.</span>Ack<br>    <span class=\"token punctuation\">}</span><br>    cache<span class=\"token punctuation\">.</span><span class=\"token function\">Store</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">.</span>MessageId<span class=\"token punctuation\">)</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">string</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">.</span>Body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><br>    <span class=\"token keyword\">return</span> rabbitmq<span class=\"token punctuation\">.</span>Ack<br><span class=\"token punctuation\">}</span></code></pre>\n<p>用 WireShark 也能看到 MessageID</p>\n<p><img src=\"/img/posts/2022/three-semantics-of-rabbitmq/wireshark-rabbitmq-4.webp\" alt=\"\"></p>\n<p>因為我們是在業務層面保證「準確一次」，實作方式就會跟系統相關，像是引入集中式緩存（Redis）會增加系統複雜度；而緩存的空間與失效期間也需要設計，這就不是單單調整參數就好，而是需要視具體運作的狀況來確定了。</p>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>軟體工程的其中一項挑戰來自於「語義鴻溝」，可以看到光是消息處理就存在著三層不同的語義，而且越高階語義就需要越複雜的設定。如果消息處理跟使用者的期待有落差，很容易產生無形的錯誤。可能對於大多數的使用者來說，都是以「準確一次」為預設，開發者也不會跟使用者講，消息丟失算是正常情況（即使在有條件的情況下，它的確是正常）。</p>\n<p>也許可以這麼想：身為開發者，如何盡早辨識出語義鴻溝，並提出對應的技術方案，就是功力所在了。雖然用層次的概念來描述語義，好像會給人只要實作高層次就好的印象，但高層次的保證需要更多操作，像是更多的 Confirm、跟緩存間更多的溝通，都會影響到其他效能指標。以「準確一次」來說，還得確保緩存不會在執行中出問題，如果有問題的話，錯誤處理也要額外設計。</p>\n<p>商業模型跟技術模型間如何對應一直是很有意思的題目，希望大家看完這篇後能體會到消息處理有趣的地方。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"https://www.rabbitmq.com/amqp-0-9-1-reference.html\">AMQP 0-9-1 Complete Reference Guide</a></li>\n</ul>\n",
      "date_published": "2022-10-22T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2022/error-as-resource-grpc-error-handling/",
      "url": "https://blog.kenwsc.com/posts/2022/error-as-resource-grpc-error-handling/",
      "title": "讓錯誤成為資源：gRPC 的錯誤處理模型",
      "content_html": "<p>錯誤處理是所有 RPC 服務都要具備的設計，但是怎樣的錯誤處理模型，算是好的模型呢？從字面上來看，錯誤處理可以分解成「錯誤」跟「處理」，如果用 RESTful 的觀點，將錯誤當成是 Resource，一個好的模型應該要能匹配不同場景的 Resource，並根據場景需求來處理這些 Resource。</p>\n<h2 id=\"%E9%8C%AF%E8%AA%A4%E6%A8%A1%E5%9E%8B\"><a class=\"direct-link\" href=\"#%E9%8C%AF%E8%AA%A4%E6%A8%A1%E5%9E%8B\">#</a> 錯誤模型</h2>\n<p>在 RESTful 中，通常會用 HTTP Status Code 當錯誤訊息的分類(Category)，錯誤內容則放在 Payload。這樣的好處是，只要看到分類，就能先進行大方向的處理，如果需要特定資訊，再從 Payload 拿取。通常錯誤內容的格式會自行定義，以支付服務 Stripe 的 API 為例，定義的格式就有</p>\n<ul>\n<li>type (string)</li>\n<li>code (string)</li>\n<li>decline_code (string)</li>\n<li>message (string)</li>\n</ul>\n<p>message 應該是最常見的欄位，當開發分為前後端時，前端能根據 message 快速定位錯誤原因。code 則是用來補足 HTTP Status Code 的不足，在原本的分類下進行子分類。其他欄位則視應用場景來添加。如果應用場景不複雜的話，可以考慮只用基本的 Payload 格式，像是</p>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span><br>    <span class=\"token property\">\"code\"</span><span class=\"token operator\">:</span> <span class=\"token number\">40001</span><span class=\"token punctuation\">,</span><br>    <span class=\"token property\">\"message\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"an invalid parameter: user_name\"</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>RESTful API 透過分類知道要如何處理錯誤，透過 Payload 知道錯誤的內容，狹義來說，RESTful API 是指用 HTTP + JSON/XML 的方式來設計 API，但這只是一種特定的實作方式，不直接等於 RESTful。Roy Fielding 談 RESTful 時，用的名稱是「表述性狀態轉移」，這是個原則性的概念，只要稍加改動，應該要能套用同樣原則到不同的實現中，例如 gRPC。在進一步細談如何套用前，我們先來看看 gRPC 的錯誤處理模型。</p>\n<p>假設我們建立一個 gRPC server，定義一個 service func SayHello，裡面什麼事情都不做，直接回傳錯誤</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    srv <span class=\"token operator\">:=</span> grpc<span class=\"token punctuation\">.</span><span class=\"token function\">NewServer</span><span class=\"token punctuation\">(</span>cfg<span class=\"token punctuation\">)</span><br>    proto<span class=\"token punctuation\">.</span><span class=\"token function\">RegisterHelloServiceServer</span><span class=\"token punctuation\">(</span>srv<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>server<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><br>    srv<span class=\"token punctuation\">.</span><span class=\"token function\">Serve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br><span class=\"token keyword\">var</span> demoErr <span class=\"token operator\">=</span> errors<span class=\"token punctuation\">.</span><span class=\"token function\">New</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"some error\"</span><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">type</span> server <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span><br>    proto<span class=\"token punctuation\">.</span>UnimplementedHelloServiceServer<br><span class=\"token punctuation\">}</span><br><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">*</span>server<span class=\"token punctuation\">)</span> <span class=\"token function\">SayHello</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span>Context<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>emptypb<span class=\"token punctuation\">.</span>Empty<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>emptypb<span class=\"token punctuation\">.</span>Empty<span class=\"token punctuation\">,</span> <span class=\"token builtin\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>emptypb<span class=\"token punctuation\">.</span>Empty<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> demoErr<br><span class=\"token punctuation\">}</span></code></pre>\n<p>同時建立一個 client 去呼叫 server</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>  conn<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> grpc<span class=\"token punctuation\">.</span><span class=\"token function\">NewClient</span><span class=\"token punctuation\">(</span>cfg<span class=\"token punctuation\">)</span><br>  client <span class=\"token operator\">:=</span> proto<span class=\"token punctuation\">.</span><span class=\"token function\">NewHelloServiceClient</span><span class=\"token punctuation\">(</span>conn<span class=\"token punctuation\">)</span><br>  client<span class=\"token punctuation\">.</span><span class=\"token function\">SayHello</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span><span class=\"token function\">Background</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>emptypb<span class=\"token punctuation\">.</span>Empty<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>然後拿出你的 WireShark 抓包，直接看看傳了哪些東西，抓到的 Request 會是</p>\n<p><img src=\"/img/posts/2022/error-as-resource-grpc-error-handling/wireshark_grpc_request_1.webp\" alt=\"\"></p>\n<p>翻譯成白話：gRPC 用 POST method 呼叫 /proto.HelloService/SayHello 的 URL。</p>\n<p>也能抓到 Response</p>\n<p><img src=\"/img/posts/2022/error-as-resource-grpc-error-handling/wireshark_grpc_response_1.webp\" alt=\"\"></p>\n<p>在 Header 中可以看到兩個跟 gRPC相關的 header，grpc-status 跟 grpc-message。語意上，這大致可以對應到 HTTP 的 Status Code 跟 Payload。可能有人會覺得奇怪，為什麼 HTTP 已經有一套可以套用的錯誤模型了，gRPC 還需要自己定義 Header？從定義來看，有機會是 HTTP Status Code 的應用情境不符合 gRPC 的情境，像是在 gRPC 中，有些 Status 是 client 獨有，有些是 server 獨有，而 HTTP Status Code 沒分這麼細緻。</p>\n<p>另外，HTTP 的錯誤模型有個缺點，它將正常的資源跟錯誤的資源都用 Payload 來表述狀態。這裡有語意重載，會帶來複雜的處理問題。舉個例子，假設有人請你幫他跑腿，你回答 “No way”，意思是「我才不要」；但如果有人跟你說他中了樂透，你回答 “No way”，意思就變成是「天啊，怎麼可能」，同樣是 “No way”，前後的情境不同，意思就變得不一樣。對照到 Payload，當語意重載的情況出現時，會讓 client 需要依照 Context 來判斷要用什麼模型來處理，如果可以將正常的資源跟錯誤的資源分開，出錯的機率就會變小，可讀性也會提高。gRPC 這個設計相對合理。</p>\n<h2 id=\"%E7%8B%80%E6%85%8B%E7%A2%BC\"><a class=\"direct-link\" href=\"#%E7%8B%80%E6%85%8B%E7%A2%BC\">#</a> 狀態碼</h2>\n<p>剛剛講到 grpc-status 是 gRPC 的狀態碼，在上面的 Response 中，我們看到 grpc-status = 2，2 是什麼意思？依照 gRPC official status code 的定義，2 是 Unknown Error。</p>\n<blockquote>\n<p>Unknown error. For example, this error may be returned when a Status value received from another address space belongs to an error space that is not known in this address space. Also errors raised by APIs that do not return enough error information may be converted to this error.</p>\n</blockquote>\n<p>為什麼會是 Unknown 呢？因為我們直接把 error 回傳，沒有替這個 error 分類，在 Golang 的實作中，沒分類的 error 會自動被歸類為 Unknown，可想而知這不是個好的實作，收到錯誤訊息的人看到 Unknown，無法進一步處理，只能被動印出 Log。</p>\n<p>為了讓訊息更明確，我們需要替 gRPC error 指定 grpc-status</p>\n<p>修改 server</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">*</span>server<span class=\"token punctuation\">)</span> <span class=\"token function\">SayHello</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span>Context<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>emptypb<span class=\"token punctuation\">.</span>Empty<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>emptypb<span class=\"token punctuation\">.</span>Empty<span class=\"token punctuation\">,</span> <span class=\"token builtin\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>emptypb<span class=\"token punctuation\">.</span>Empty<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> status<span class=\"token punctuation\">.</span><span class=\"token function\">Error</span><span class=\"token punctuation\">(</span>codes<span class=\"token punctuation\">.</span>InvalidArgument<span class=\"token punctuation\">,</span> <span class=\"token string\">\"some error\"</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>status package 是官方提供的 Package，顧名思義，就是讓你可以控制 status 的值；而 codes package 則定義了 gRPC 相關的 status code。我們在這裡定義該 status code 是 invalid argument，告知呼叫者參數錯誤；並在後面帶上 error message 讓呼叫者可以知道詳細資訊。</p>\n<p>修改後，WireShark 的 Response 變成</p>\n<p><img src=\"/img/posts/2022/error-as-resource-grpc-error-handling/wireshark_grpc_response_2.webp\" alt=\"\"></p>\n<p>原本 grpc-status 變成 3了，對應到 Status 就是 INVALID_ARGUMENT。呼叫者可以知道原來是自己的參數錯誤才導致呼叫異常。</p>\n<p>順便來看一下，目前 gRPC 定義的 status code 有這些</p>\n<ul>\n<li>OK(0)：成功狀態</li>\n<li>CANCELLED(1)：操作已被（調用者）取消</li>\n<li>UNKNOWN(2)：未知錯誤</li>\n<li>INVALID_ARGUMENT(3)：客戶端指定非法參數</li>\n<li>DEADLINE_EXCEEDED(4)：在操作完成前，已經過了截止時間</li>\n<li>NOT_FOUND(5)：請求的資源找不到</li>\n<li>ALREADY_DENIED(6)：客戶端試圖創建的實體已經存在</li>\n<li>PERMISSION_DENIED(7)：調用者沒有權限執行操作</li>\n<li>RESOURCE_EXHASTED(8)：某些資源已經被耗盡</li>\n<li>FAILED_PRECONDITION(9)：系統沒有處於操作需要的狀態</li>\n<li>ABORTED(10)：操作被中止</li>\n<li>OUT_OF_RANGE(11)：嘗試進行的操作超出合理範圍</li>\n<li>UNIMPLEMENTED(12)：該操作尚未實現</li>\n<li>INTERNAL(13)：內部錯誤</li>\n<li>UNAVAILABLE(14)：該服務目前不可用</li>\n<li>DATA_LOSS(15)：不可恢復的數據損壞</li>\n<li>UNAUTHENTICATED(16)：客戶端沒有操作需要的認證</li>\n</ul>\n<p>到這裡我們發現一件事，如果想要描述的錯誤內容單純用狀態碼無法表達怎麼辦？例如，我們不僅想知道錯誤類型是參數錯誤，還想知道錯誤的參數是哪個，應該要如何修正，該怎麼將這個資訊給結構化呢？</p>\n<h2 id=\"%E8%A9%B3%E7%B4%B0%E9%8C%AF%E8%AA%A4%E8%B3%87%E8%A8%8A\"><a class=\"direct-link\" href=\"#%E8%A9%B3%E7%B4%B0%E9%8C%AF%E8%AA%A4%E8%B3%87%E8%A8%8A\">#</a> 詳細錯誤資訊</h2>\n<p>gRPC 除了有 grpc-message 顯示人眼可讀的 error message 外，還有一個 header grpc-status-details-bin，用來補足 status 表現能力不夠的問題。為了統一模型，這個資訊格式也是採用 protobuf，我們可以把它想像成 error 專用欄位，內容經過 protobuf message 編碼後，會放在這個標頭中。</p>\n<p>既然知道概念，那就好處理了，把 server 端改成</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">*</span>server<span class=\"token punctuation\">)</span> <span class=\"token function\">SayHello</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span>Context<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>emptypb<span class=\"token punctuation\">.</span>Empty<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>emptypb<span class=\"token punctuation\">.</span>Empty<span class=\"token punctuation\">,</span> <span class=\"token builtin\">error</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    st <span class=\"token operator\">:=</span> status<span class=\"token punctuation\">.</span><span class=\"token function\">New</span><span class=\"token punctuation\">(</span>codes<span class=\"token punctuation\">.</span>InvalidArgument<span class=\"token punctuation\">,</span> <span class=\"token string\">\"some error\"</span><span class=\"token punctuation\">)</span><br>    st<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">=</span> st<span class=\"token punctuation\">.</span><span class=\"token function\">WithDetails</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>errdetails<span class=\"token punctuation\">.</span>BadRequest_FieldViolation<span class=\"token punctuation\">{</span><br>        Field<span class=\"token punctuation\">:</span>       <span class=\"token string\">\"lost\"</span><span class=\"token punctuation\">,</span><br>        Description<span class=\"token punctuation\">:</span> <span class=\"token string\">\"lost field that should have\"</span><span class=\"token punctuation\">,</span><br>    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><br>    <span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>emptypb<span class=\"token punctuation\">.</span>Empty<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> st<span class=\"token punctuation\">.</span><span class=\"token function\">Err</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>一樣是用 status 來處理，但在 status 中加入 details，gRPC 可以接受多個 detail，因此你可以根據需求將詳細的資訊傳進去。在這個例子中，我們進一步補充說 lost 這個 field 的值錯誤，它應該要有值，但接收時沒發現。這的資訊就豐富到能讓呼叫端進行應用層級的處理了。</p>\n<p>雖然只要是 protobuf 就能放進 detail 中，但為了更好的相容性與定義，建議使用 Google 提供的 errdetails package 來處理，避免自己定義模型。</p>\n<p>修改後，用 WireShark 再抓一次</p>\n<p><img src=\"/img/posts/2022/error-as-resource-grpc-error-handling/wireshark_grpc_response_3.webp\" alt=\"\"></p>\n<p>看到 grpc-status-details-bin 冒出來了，後面是 base64 編碼過的內容，如果丟進 decode 的話，可以得到</p>\n<pre><code>invalid argument e\n8type.googleapis.com/google.rpc.BadRequest.FieldViolation)\nlost lost field that should have\n</code></pre>\n<p>可以看到詳細的錯誤資訊都在裡面。</p>\n<p>用 Postman 呼叫 gRPC，也能看到同樣的錯誤訊息。</p>\n<p><img src=\"/img/posts/2022/error-as-resource-grpc-error-handling/postman.webp\" alt=\"\"></p>\n<h2 id=\"%E5%AE%A2%E6%88%B6%E7%AB%AF\"><a class=\"direct-link\" href=\"#%E5%AE%A2%E6%88%B6%E7%AB%AF\">#</a> 客戶端</h2>\n<p>剛剛的例子講的都是 server 端應該怎麼定義並回傳錯誤，client 收到 server 回傳的錯誤後，也要針對錯誤進行處理。</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> err <span class=\"token operator\">=</span> client<span class=\"token punctuation\">.</span><span class=\"token function\">SayHello</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">.</span><span class=\"token function\">Background</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>emptypb<span class=\"token punctuation\">.</span>Empty<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><br>st<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> status<span class=\"token punctuation\">.</span><span class=\"token function\">FromError</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br><span class=\"token keyword\">if</span> st<span class=\"token punctuation\">.</span><span class=\"token function\">Code</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> codes<span class=\"token punctuation\">.</span>InvalidArgument <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">for</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> d <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> st<span class=\"token punctuation\">.</span><span class=\"token function\">Details</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        <span class=\"token keyword\">switch</span> info <span class=\"token operator\">:=</span> d<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        <span class=\"token keyword\">case</span> <span class=\"token operator\">*</span>errdetails<span class=\"token punctuation\">.</span>BadRequest_FieldViolation<span class=\"token punctuation\">:</span><br>            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>info<span class=\"token punctuation\">)</span><br>        <span class=\"token punctuation\">}</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>我們先用 status package 將 error 轉換成 status 的結構，接著從 status 的結構中讀取 status code，如果是 Invalid Argument，再進一步迭代所有的 detail 項並且印出。</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">~/git/ken-playground/grpc<span class=\"token operator\">></span> go run ./example/client-demo                                                                                      <br>field:<span class=\"token string\">\"lost\"</span>  description:<span class=\"token string\">\"lost field that should have\"</span></code></pre>\n<p>這裡有幾點要注意，第一，錯誤處理的結構仍然稍嫌複雜，if 中還嵌套著迭代跟 switch，如果 status code 有多個可能，最外圍的 if 需要再改成 switch 來接收，整體來說有一定的成本在。設計得太複雜，花太多時間來管理錯誤，結果大多錯誤都用不到的話，只會增加無謂的成本。gRPC 是針對所有可能的場景來設計，實際上還是要根據應用來裁量。</p>\n<p>再來，對於企業層級的錯誤處理，也可以試著用 gRPC interceptor 來轉換錯誤，像是提供企業級的錯誤定義模組，在每個 client 建構時都自動引入定義好的 interceptor，儘管會犧牲一些些彈性，但能換取較好的可擴充性，加速開發時間。</p>\n<p>最後，我們直接使用了 *errdetails.BadRequest_FieldViolation 來做型別斷言，省掉額外宣告錯誤模型的麻煩。這時 server 使用 errdetails 的效果顯現出來了，透過重用泛用性高，經過產品階段驗證的介面，自己就不用從頭摸索、設計、維護模型，可以轉而將這些時間投入到產品開發上。</p>\n<h2 id=\"%E7%B5%90%E8%AA%9E\"><a class=\"direct-link\" href=\"#%E7%B5%90%E8%AA%9E\">#</a> 結語</h2>\n<p>這篇從錯誤模型的角度，嘗試設計一套 gRPC 的錯誤處理機制，不過，與其說是設計，最後還是用了跟主流方案接近的最佳實踐。畢竟最佳實踐能是最佳實踐的原因，就是經過實務中的打磨，使用性特別好。</p>\n<p>這邊想再講的一個思考角度是開發者體驗，通常我們開發時，只會關注 happy path，錯誤處理都是用精簡至上的角度來設計，直到某天錯誤發生，想看的除錯資訊都沒有，才會回來檢視原本的設計。這背後意味著在思考開發場景時，有些假設是值得商榷的。在開發者花費的時間中，除錯或許比開發佔更高比例，既然如此，我們應該將每個錯誤都當成是一個使用者故事來看待，讓系統的支援完善，才能做好開發者體驗。</p>\n<p>以上大概是梳理錯誤處理的一些過程，中間也學習到很多模型匹配的原則，算是挺有收穫的，希望看完這篇文章的讀者，能多知道一些錯誤處理的背景。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"https://grpc.github.io/grpc/core/md_doc_statuscodes.html\">GRPC Core: Status codes and their use in gRPC</a></li>\n<li><a href=\"https://stripe.com/docs/api/errors#errors-api_error\">Stripe API reference – Go</a></li>\n</ul>\n",
      "date_published": "2022-10-07T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2020/use-protobuf-in-golang/",
      "url": "https://blog.kenwsc.com/posts/2020/use-protobuf-in-golang/",
      "title": "一種更緊湊的數據格式：Protobuf 入門",
      "content_html": "<p>Protocol buffers，簡稱 Protobuf，是由 Google 設計的結構化序列化資料技術。對網路應用來講，常常需要在不同的伺服端、客戶端之間交換資料，這些資料格式有 XML、JSON 等等之類。XML 特點是完整，便於記載更多的 meta data，但格式複雜，需要更強的效能來解析，傳輸時也需要更多頻寬；而 JSON 是 JavaScript 用於表示物件的語法，相對 XML 來得簡潔，隨著 JavaScript 普及，也變成現在常用的輕量級資料交換格式。</p>\n<p>儘管 XML 跟 JSON 在當前網路應用中已經相當常見，但用不同語言開發的伺服端程式，都需要分別實現自己語言的 XML 或 JSON 解析，同時，這些格式定義也是團隊協作的痛點。假設 A 團隊開發某支應用，因為開發時沒有定義文件，只用 Email 跟 B 團隊說明，如果說明得不夠清楚，就會導致 B 團隊在交換資料時格式錯誤，需要好幾個來回，才能釐清彼此應該實現的格式。</p>\n<p>Protobuf 對這些問題有它的看法，本文會使用 Protobuf 來序列化資料，搭配 Golang 寫個簡單的讀檔寫檔程式，體會一下 Protobuf 的設計特點。</p>\n<h2 id=\"prepare-environment\"><a class=\"direct-link\" href=\"#prepare-environment\">#</a> Prepare Environment</h2>\n<p>Prorobuf 使用前，需要依據格式定義文件 proto file 來編譯訊息，編譯用工具是 protoc，可以到官網下載，或使用</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">choco <span class=\"token function\">install</span> protoc</code></pre>\n<p>來安裝，安裝後輸入</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">PS C:<span class=\"token punctuation\">\\</span>Users<span class=\"token punctuation\">\\</span>ken<span class=\"token operator\">></span> protoc --version<br>libprotoc <span class=\"token number\">3.12</span>.3</code></pre>\n<p>來確認版本。版本號很重要，跟 Google 其他的工具一樣，不同版本間可能有相容問題，使用時盡量依照語意化版本的方式選用對應版本。</p>\n<p>Protobuf 用於結構化訊息的方法，是先將格式定義好，再用定義好的格式來產生序列化訊息，可以參考官方說明</p>\n<blockquote>\n<p>You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages.</p>\n</blockquote>\n<p>因為包含 Code Generator，Protobuf 可以相容多種語言，常見的 C++、C#、Java 等等都在支援中。</p>\n<p>參照 Golang 的專案目錄，建個 pb 來放置 proto file</p>\n<pre><code>project\n├── cmd\n├── pkg\n├── scripts\n|   └── build_win.bat\n├── pb\n|   └── person.proto\n|── go.mod\n└── README.md\n</code></pre>\n<p>檔案內容是</p>\n<pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">syntax</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"proto3\"</span><span class=\"token punctuation\">;</span><br><br><span class=\"token keyword\">package</span> person<span class=\"token punctuation\">;</span><br><br><span class=\"token keyword\">message</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token builtin\">string</span> name <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><br>    <span class=\"token builtin\">string</span> address <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span><br>    <span class=\"token builtin\">string</span> gender <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span><br>    <span class=\"token builtin\">int32</span> age <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>syntax 是版本，用於跟 proto2 區別；package 是這份 proto file 所屬的套件名稱；message 用於定義訊息結構。假設訊息結構是 Person，其中包含姓名、地址、性別、年齡等欄位，用於表示 Person 的資料。各欄位等號後數字是用於區別欄位，如果開發中需要新增欄位，可以直接在 field 中使用新數字，即可無痛向後相容。</p>\n<h2 id=\"use-protobuf-command-line-tool\"><a class=\"direct-link\" href=\"#use-protobuf-command-line-tool\">#</a> Use Protobuf Command Line Tool</h2>\n<p>材料準備好後，來試著用 protoc 序列化訊息。前面已經定義好的格式了，這邊將需要傳輸的內容寫在 sample.txt</p>\n<pre><code>name: &quot;Ken Chen&quot;\naddress: &quot;New Taipei City&quot;\ngender: &quot;Male&quot;\nage: 18\n</code></pre>\n<p>引號後面是 proto 欄位的值，格式類似 JSON，可以參考官方說明。</p>\n<p>然後用 protoc 來序列化訊息</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">protoc --encode person.Person ./pb/person.proto <span class=\"token operator\">></span> encode.txt <span class=\"token operator\">&lt;</span> sample.txt<br><span class=\"token builtin class-name\">type</span> encode.txt<br><br>Ken ChenNew Taipei CityMale</code></pre>\n<p>最底下那串是序列化後的訊息，可以看到 string 還留著，但 field 跟 number 都被序列化成 byte 訊息了。</p>\n<p>這些序列化完成的訊息，可以再用 protoc 反序列化回來，變成人眼可讀</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">protoc --decode person.Person ./pb/person.proto <span class=\"token operator\">&lt;</span> encode.txt<br>name: <span class=\"token string\">\"Ken Chen\"</span><br>address: <span class=\"token string\">\"New Taipei City\"</span><br>gender: <span class=\"token string\">\"Male\"</span><br>age: <span class=\"token number\">18</span></code></pre>\n<p>我們將傳輸內容序列化、寫進檔案、讀出、反序列化，這就是個簡單的傳輸過程。</p>\n<h2 id=\"prepare-golang-environment\"><a class=\"direct-link\" href=\"#prepare-golang-environment\">#</a> Prepare Golang Environment</h2>\n<p>驗證 Protobuf 的使用流程後，接著要將 Protobuf 的機制放到自行開發的應用程式中。</p>\n<p>先下載 Golang 的 Protobuf 套件</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">go get google.golang.org/protobuf/cmd/protoc-gen-go</code></pre>\n<p>修改 proto file，讓它帶有 Golang Package 的資訊</p>\n<pre class=\"language-protobuf\"><code class=\"language-protobuf\"><span class=\"token keyword\">syntax</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"proto3\"</span><span class=\"token punctuation\">;</span><br><br><span class=\"token keyword\">option</span> go_package <span class=\"token operator\">=</span> <span class=\"token string\">\"example/pkg/pb/person\"</span><span class=\"token punctuation\">;</span><br><br><span class=\"token keyword\">package</span> person<span class=\"token punctuation\">;</span><br><br><span class=\"token keyword\">message</span> <span class=\"token class-name\">Person</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token builtin\">string</span> name <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><br>    <span class=\"token builtin\">string</span> address <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span><br>    <span class=\"token builtin\">string</span> gender <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span><br>    <span class=\"token builtin\">int32</span> age <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>使用 protoc 中的 Code Generator 來產生 go 的程式碼</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">protoc --go_out<span class=\"token operator\">=</span>./ --go_opt<span class=\"token operator\">=</span>paths<span class=\"token operator\">=</span>source_relative ./pb/*.proto</code></pre>\n<p>go_out 是產出文件的路徑；我們將 pb 的所有 proto file 都產生一份對應的 go 程式碼</p>\n<p>可以看看產出文件 person.pb.go 的開頭</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// Code generated by protoc-gen-go. DO NOT EDIT.</span><br><span class=\"token comment\">// versions:</span><br><span class=\"token comment\">//  protoc-gen-go v1.25.0</span><br><span class=\"token comment\">//  protoc        v3.12.3</span><br><span class=\"token comment\">// source: pb/person.proto</span><br><br><span class=\"token keyword\">package</span> person<br><br><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span><br>    proto <span class=\"token string\">\"github.com/golang/protobuf/proto\"</span><br>    protoreflect <span class=\"token string\">\"google.golang.org/protobuf/reflect/protoreflect\"</span><br>    protoimpl <span class=\"token string\">\"google.golang.org/protobuf/runtime/protoimpl\"</span><br>    reflect <span class=\"token string\">\"reflect\"</span><br>    sync <span class=\"token string\">\"sync\"</span><br><span class=\"token punctuation\">)</span></code></pre>\n<p>如第一行寫的，這是產出文件，看看就好，不要修改它。如果有一些客製化應用，希望在既有的 Protobuf struct 加上自己的 method，建議可以用 go package 的機制，在同目錄底下放 patch.go 文件來新增。</p>\n<p>把產出的文件放到專案路徑 pkg，變成</p>\n<pre><code>project\n├── cmd\n├── pkg\n|   └── person\n|      └── person.pb.go\n├── scripts\n|   └── build_win.bat\n├── pb\n|   └── person.proto\n|── go.mod\n└── README.md\n</code></pre>\n<h2 id=\"read%2Fwrite-data-in-golang\"><a class=\"direct-link\" href=\"#read%2Fwrite-data-in-golang\">#</a> Read/Write Data in Golang</h2>\n<p>可以來寫點應用了，在 cmd 下新增 go 程式碼</p>\n<pre><code>project\n├── cmd\n|   └── proto\n|      └── main.go\n├── pkg\n|   └── person\n|      └── person.pb.go\n├── scripts\n|   └── build_win.bat\n├── pb\n|   └── person.proto\n|── go.mod\n└── README.md\n</code></pre>\n<p>內容是</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main<br><br><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span><br>    <span class=\"token string\">\"example/pkg/person\"</span><br>    <span class=\"token string\">\"fmt\"</span><br>    <span class=\"token string\">\"io/ioutil\"</span><br><br>    <span class=\"token string\">\"github.com/golang/protobuf/proto\"</span><br><span class=\"token punctuation\">)</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    data<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> ioutil<span class=\"token punctuation\">.</span><span class=\"token function\">ReadFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"encode.txt\"</span><span class=\"token punctuation\">)</span><br>    msg <span class=\"token operator\">:=</span> person<span class=\"token punctuation\">.</span>Person<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><br>    err <span class=\"token operator\">:=</span> proto<span class=\"token punctuation\">.</span><span class=\"token function\">Unmarshal</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>msg<span class=\"token punctuation\">)</span><br>    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span><br>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br>    <span class=\"token punctuation\">}</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">,</span> msg<span class=\"token punctuation\">.</span>Gender<span class=\"token punctuation\">,</span> msg<span class=\"token punctuation\">.</span>Address<span class=\"token punctuation\">,</span> msg<span class=\"token punctuation\">.</span>Age<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>由於前面已經用 protoc 產生序列化後的檔案 encode.txt，這裡可以讀取該檔來驗證程式。example/pkg/person 是引入剛剛產出的 go 套件。使用 ioutil 讀檔，再用 proto.Umarshal 反序列化成 struct，最後印出。</p>\n<p>編譯並執行，看看結果</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">.<span class=\"token punctuation\">\\</span>bin<span class=\"token punctuation\">\\</span>proto.exe<br>Ken Chen Male New Taipei City <span class=\"token number\">18</span></code></pre>\n<p>可以看到欄位值跟 sample.txt 相同。</p>\n<p>接著來寫檔，修改 main.go</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token comment\">// write file</span><br>    msgWrite <span class=\"token operator\">:=</span> person<span class=\"token punctuation\">.</span>Person<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><br>    msgWrite<span class=\"token punctuation\">.</span>Age <span class=\"token operator\">=</span> <span class=\"token number\">22</span><br>    msgWrite<span class=\"token punctuation\">.</span>Gender <span class=\"token operator\">=</span> <span class=\"token string\">\"Female\"</span><br>    msgWrite<span class=\"token punctuation\">.</span>Name <span class=\"token operator\">=</span> <span class=\"token string\">\"Cythia\"</span><br>    msgWrite<span class=\"token punctuation\">.</span>Address <span class=\"token operator\">=</span> <span class=\"token string\">\"Boston ,US\"</span><br>    dataWrite<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> proto<span class=\"token punctuation\">.</span><span class=\"token function\">Marshal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>msgWrite<span class=\"token punctuation\">)</span><br>    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span><br>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br>    <span class=\"token punctuation\">}</span><br>    err <span class=\"token operator\">=</span> ioutil<span class=\"token punctuation\">.</span><span class=\"token function\">WriteFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"encode.txt\"</span><span class=\"token punctuation\">,</span> dataWrite<span class=\"token punctuation\">,</span> os<span class=\"token punctuation\">.</span>ModePerm<span class=\"token punctuation\">)</span><br>    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span><br>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br>    <span class=\"token punctuation\">}</span><br><br>    <span class=\"token comment\">// read file</span><br>    data<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> ioutil<span class=\"token punctuation\">.</span><span class=\"token function\">ReadFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"encode.txt\"</span><span class=\"token punctuation\">)</span><br>    msg <span class=\"token operator\">:=</span> person<span class=\"token punctuation\">.</span>Person<span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><br>    err <span class=\"token operator\">=</span> proto<span class=\"token punctuation\">.</span><span class=\"token function\">Unmarshal</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>msg<span class=\"token punctuation\">)</span><br>    <span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span><br>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br>    <span class=\"token punctuation\">}</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">)</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>Gender<span class=\"token punctuation\">)</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>Address<span class=\"token punctuation\">)</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>Age<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>寫檔的順序跟讀檔相反，先建立 Protobuf struct，填入各欄位，用 proto.Marshal 序列化，再用 ioutil.WriteFile 將序列化後的資訊寫進檔案中。寫入檔案同樣是 encode.txt，底下再用讀檔將內容讀出。</p>\n<p>編譯並執行，觀察結果</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">.<span class=\"token punctuation\">\\</span>bin<span class=\"token punctuation\">\\</span>proto.exe<br>Cythia<br>Female<br>Boston ,US<br><span class=\"token number\">22</span></code></pre>\n<p>檔案內容由 Ken 改為 Cythia，寫入成功。</p>\n<h2 id=\"compare-with-json\"><a class=\"direct-link\" href=\"#compare-with-json\">#</a> Compare with JSON</h2>\n<p>既然都有現成的資料了，可以再跟 JSON 比較，看看兩者序列化後的大小差多少。</p>\n<p>由於 Protobuf 相容 JSON 的格式，這件事變得很容易，可以看 person.pb.go 的內容</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span><br>    state         protoimpl<span class=\"token punctuation\">.</span>MessageState<br>    sizeCache     protoimpl<span class=\"token punctuation\">.</span>SizeCache<br>    unknownFields protoimpl<span class=\"token punctuation\">.</span>UnknownFields<br><br>    Name    <span class=\"token builtin\">string</span> <span class=\"token string\">`protobuf:\"bytes,1,opt,name=name,proto3\" json:\"name,omitempty\"`</span><br>    Address <span class=\"token builtin\">string</span> <span class=\"token string\">`protobuf:\"bytes,2,opt,name=address,proto3\" json:\"address,omitempty\"`</span><br>    Gender  <span class=\"token builtin\">string</span> <span class=\"token string\">`protobuf:\"bytes,3,opt,name=gender,proto3\" json:\"gender,omitempty\"`</span><br>    Age     <span class=\"token builtin\">int32</span>  <span class=\"token string\">`protobuf:\"varint,4,opt,name=age,proto3\" json:\"age,omitempty\"`</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>在 Person 這個 struct 中，Name、Address、Gender、Age 等欄位有同時打上 protobuf 跟 json 兩種 tag，因此要轉換 struct 為 json，只需要直接使用 Golang 標準庫中的 json 庫即可。</p>\n<p>修改 main.go</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// write json</span><br>dataJSON<span class=\"token punctuation\">,</span> err <span class=\"token operator\">:=</span> json<span class=\"token punctuation\">.</span><span class=\"token function\">Marshal</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>msgWrite<span class=\"token punctuation\">)</span><br><span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br>err <span class=\"token operator\">=</span> ioutil<span class=\"token punctuation\">.</span><span class=\"token function\">WriteFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"encode_json.txt\"</span><span class=\"token punctuation\">,</span> dataJSON<span class=\"token punctuation\">,</span> os<span class=\"token punctuation\">.</span>ModePerm<span class=\"token punctuation\">)</span><br><span class=\"token keyword\">if</span> err <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">{</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>執行後可以看到多出 encode_json.txt 這個檔案，內容是</p>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span><span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"Cythia\"</span><span class=\"token punctuation\">,</span><span class=\"token property\">\"address\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"Boston ,US\"</span><span class=\"token punctuation\">,</span><span class=\"token property\">\"gender\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"Female\"</span><span class=\"token punctuation\">,</span><span class=\"token property\">\"age\"</span><span class=\"token operator\">:</span><span class=\"token number\">22</span><span class=\"token punctuation\">}</span></code></pre>\n<p>來比較 Protobuf 跟 JSON 序列化後的差異，用</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">dir</span> *.txt /s</code></pre>\n<p>得到</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token number\">2020</span>/06/26  下午 02:42                <span class=\"token number\">30</span> encode.txt<br><span class=\"token number\">2020</span>/06/26  下午 02:42                <span class=\"token number\">67</span> encode_json.txt</code></pre>\n<p>Protobuf 只要 30 bytes，而 JSON 需要 67 bytes，相差一倍多，難怪 Google 宣稱它又小又快。</p>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>Protobuf 對網路應用來講，最主要的優點就是體積更小，傳輸更快，在高密度的資料交換場景，例如微服務組成的大型應用中，Protobuf 能有效提高傳輸速度。讓人訝異的是，根據這篇<a href=\"https://medium.com/@akresling/go-benchmark-json-v-protobuf-4ec3c62ec8d4\">文章</a>，Protobuf 在解析使用的資源居然還低於 JSON，真要說不方便的地方，大約是人眼不可讀這點。</p>\n<p>除了傳輸與效能上的特點，Protobuf 將資料格式文件化，無意中也防止兩個不同的應用程序無法交換，對多人協作來講有其優勢。麻煩的地方可能是 proto file 需要額外版控，而 Git 目前的子版本版控技術用起來不是很方便，無論 submodule 或 subtree 都有限制，以 subtree 來講，會需要開發者先到 proto file 的 Repo 中修改檔案，加入並提交後，再到專案開發資料夾用 subtree 拉下來。可以預期在開發初期，proto file 會頻繁變更，衍生出許多隱形的開發成本。</p>\n<p>Google 怎麼處理這問題呢？他們不用處理，因為 Google 的版控 Policy 是 Monorepo，所有的程式碼都放在一起，不需要做子版本版控。這好像是某種<a href=\"https://zh.wikipedia.org/zh-tw/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B\">康威定律</a>的佐證。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"https://developers.google.com/protocol-buffers\">Protocol Buffers</a></li>\n<li><a href=\"https://yami.io/protobuf/\">比起 JSON 更方便、更快速、更簡短的 Protobuf 格式</a></li>\n<li><a href=\"https://medium.com/@akresling/go-benchmark-json-v-protobuf-4ec3c62ec8d4\">Go Benchmark : JSON v. ProtoBuf</a></li>\n</ul>\n",
      "date_published": "2020-06-26T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2020/develop-your-middleware-by-golang/",
      "url": "https://blog.kenwsc.com/posts/2020/develop-your-middleware-by-golang/",
      "title": "訊息的處理架構：路由與中間層模式",
      "content_html": "<p>進行後端程式開發時，常會使用到 Golang 的 http 標準庫。例如要對某個 URL 進行處理時，會用到</p>\n<pre class=\"language-go\"><code class=\"language-go\">http<span class=\"token punctuation\">.</span><span class=\"token function\">Handle</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/foo\"</span><span class=\"token punctuation\">,</span> fooHandler<span class=\"token punctuation\">)</span></code></pre>\n<p>可以想像，如果沒有 http 庫，就需要使用大量的 if else 來對 URL 判斷，大幅降低程式碼可讀性。http 庫對 URL 進行 function 註冊的設計模式，不僅可以使用在後端開發，也能應用於更普遍的情境。對於要對同類型資訊進行不同處理的例子，都可以使用這個設計模式。</p>\n<p>本文會用 Golang 來開發一個類似 http middleware 的程式，處理自訂的訊息格式，藉由這過程，也順便走一次 http 庫的路由設計原理。</p>\n<h2 id=\"build-a-go-module\"><a class=\"direct-link\" href=\"#build-a-go-module\">#</a> Build a Go Module</h2>\n<p>依照<a href=\"/posts/2020/develop-a-command-line-tool-by-golang\">前篇</a>提過的專案目錄結構，我們的使用情境是：(1)有個主程式負責主要邏輯；(2)有關路由跟 middleware 的內部邏輯，使用 package 來處理。因此專案目錄會是</p>\n<pre><code>project\n├── cmd  # main applications for this project.\n|   └── main\n|      └── main.go\n├── pkg  # code that's ok to use by external applications\n|   └── route\n|      └── route.go\n├── scripts\n|   └── build_win.bat\n|── go.mod\n└── README.md\n</code></pre>\n<p>go.mod 是由 go moudle 產生出來的文件，這是 Golang 在 1.11 後推出的套件管理工具，讓開發者可以不用依照 GOPATH 的結構來安排專案（原本使用 GOPATH 大約是因為 Google 用 Monorepo 來管理專案，而 Golang 沿襲著 Google 的風格）。</p>\n<p>要將當前的專案目錄建立為 Module，只需要用 CLI 寫入</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">go mod init router</code></pre>\n<p>go module 會自動生成 go.mod，記錄模組與相依情況，這裡的 router 是模組名稱，如果這個模組會放到 github，可以用你的 github 網址作為模組名稱，更符合 Golang 的設計</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">module router<br><br>go <span class=\"token number\">1.14</span></code></pre>\n<p>然後，因為專案目錄變得比較複雜了，也建立一個 batch file 來幫忙 build code</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>@echo<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>http://twitter.com/echo<span class=\"token punctuation\">)</span> off<br><br><span class=\"token keyword\">if</span> not exist bin <span class=\"token punctuation\">(</span><br>    <span class=\"token function\">mkdir</span> bin<br><span class=\"token punctuation\">)</span><br><br><span class=\"token keyword\">for</span> /f <span class=\"token string\">\"usebackq\"</span> %%i <span class=\"token keyword\">in</span> <span class=\"token punctuation\">(</span><span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">dir</span> /b /on /a:d .<span class=\"token punctuation\">\\</span>cmd<span class=\"token variable\">`</span></span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span> <span class=\"token punctuation\">(</span><br>    <span class=\"token builtin class-name\">echo</span> %%i<br>    go build -o ./bin/%%i.exe ./cmd/%%i<br><span class=\"token punctuation\">)</span></code></pre>\n<p>執行這個 batch file 後，會建立 bin 資料夾，並依照 cmd 下所有的資料夾名稱，個別建立執行檔。由於現在有 main.go，會生成對應的 ./bin/main.exe。</p>\n<h2 id=\"design-router\"><a class=\"direct-link\" href=\"#design-router\">#</a> Design Router</h2>\n<p>在 pkg 下設計一個簡單的路由模組，負責將不同的訊息路由到對應的處理函式，路由器的設計可以長這樣</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> route<br><br><span class=\"token comment\">// Message is message</span><br><span class=\"token keyword\">type</span> Message <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span><br>    Identification <span class=\"token builtin\">string</span><br>    Time           <span class=\"token builtin\">string</span><br>    Content        <span class=\"token builtin\">string</span><br>    Size           <span class=\"token builtin\">int</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token comment\">// Handler is handler</span><br><span class=\"token keyword\">type</span> Handler <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> req <span class=\"token operator\">*</span>Message<span class=\"token punctuation\">)</span><br><br><span class=\"token comment\">// Router is router</span><br><span class=\"token keyword\">type</span> Router <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span><br>    mux <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span>Handler<br><span class=\"token punctuation\">}</span><br><br><span class=\"token comment\">// NewRouter new a router</span><br><span class=\"token keyword\">func</span> <span class=\"token function\">NewRouter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>Router <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>Router<span class=\"token punctuation\">{</span><br>    mux<span class=\"token punctuation\">:</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span>Handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token comment\">// Add a route</span><br><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>Router<span class=\"token punctuation\">)</span> <span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>route <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> h Handler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">var</span> mergedHandler <span class=\"token operator\">=</span> h<br>    r<span class=\"token punctuation\">.</span>mux<span class=\"token punctuation\">[</span>route<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> mergedHandler<br><span class=\"token punctuation\">}</span><br><br><span class=\"token comment\">// Run router</span><br><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>Router<span class=\"token punctuation\">)</span> <span class=\"token function\">Run</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> req <span class=\"token operator\">*</span>Message<span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span> <span class=\"token punctuation\">{</span><br>    route <span class=\"token operator\">:=</span> req<span class=\"token punctuation\">.</span>Identification<br>    handler<span class=\"token punctuation\">,</span> exists <span class=\"token operator\">:=</span> r<span class=\"token punctuation\">.</span>mux<span class=\"token punctuation\">[</span>route<span class=\"token punctuation\">]</span><br>    <span class=\"token keyword\">if</span> exists <span class=\"token punctuation\">{</span><br>    <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> req<span class=\"token punctuation\">)</span><br>    <span class=\"token punctuation\">}</span><br>    <span class=\"token keyword\">return</span> <span class=\"token boolean\">nil</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>一段一段來看</p>\n<p>首先設計一個訊息格式，視具體的應用需求，用來乘載要處理的資訊。這邊假設訊息格式中帶有辨識用的 Identification，如果是 http，可能是請求資源用的 URL。其他欄位可以是不同的 attribute，例如時間、內容、訊息大小等等。</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// Message is message</span><br><span class=\"token keyword\">type</span> Message <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span><br>    Identification <span class=\"token builtin\">string</span><br>    Time           <span class=\"token builtin\">string</span><br>    Content        <span class=\"token builtin\">string</span><br>    Size           <span class=\"token builtin\">int</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>使用 type 的方式，定義訊息的處理函式。</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// Handler is handler</span><br><span class=\"token keyword\">type</span> Handler <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> req <span class=\"token operator\">*</span>Message<span class=\"token punctuation\">)</span></code></pre>\n<p>定義路由器</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// Router is router</span><br><span class=\"token keyword\">type</span> Router <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span><br>    mux <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span>Handler<br><span class=\"token punctuation\">}</span></code></pre>\n<p>路由器的具體實作是個 hashtable，用 Identification 當 key，處理函式當 value，當請求進來時，直接用 Identification 查出對應的處理函式進行處理。</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// NewRouter new a router</span><br><span class=\"token keyword\">func</span> <span class=\"token function\">NewRouter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>Router <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>Router<span class=\"token punctuation\">{</span><br>        mux<span class=\"token punctuation\">:</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span>Handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>路由器的建構式，因為 Golang 不是完全的物件導向語言，因此沒有預設的建構式，使用上習慣用 NewType 的函式做為建構式。</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// Add a route</span><br><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>Router<span class=\"token punctuation\">)</span> <span class=\"token function\">Add</span><span class=\"token punctuation\">(</span>route <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> h Handler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">var</span> mergedHandler <span class=\"token operator\">=</span> h<br>    r<span class=\"token punctuation\">.</span>mux<span class=\"token punctuation\">[</span>route<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> mergedHandler<br><span class=\"token punctuation\">}</span><br><br><span class=\"token comment\">// Run router</span><br><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>Router<span class=\"token punctuation\">)</span> <span class=\"token function\">Run</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> req <span class=\"token operator\">*</span>Message<span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span> <span class=\"token punctuation\">{</span><br>    route <span class=\"token operator\">:=</span> req<span class=\"token punctuation\">.</span>Identification<br>    handler<span class=\"token punctuation\">,</span> exists <span class=\"token operator\">:=</span> r<span class=\"token punctuation\">.</span>mux<span class=\"token punctuation\">[</span>route<span class=\"token punctuation\">]</span><br>    <span class=\"token keyword\">if</span> exists <span class=\"token punctuation\">{</span><br>        <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> req<span class=\"token punctuation\">)</span><br>    <span class=\"token punctuation\">}</span><br>    <span class=\"token keyword\">return</span> <span class=\"token boolean\">nil</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>最後是路由器的關鍵 method。路由器有兩個 method，Add 用來將路由規則跟函式註冊到路由器中；Run 用來執行路由器。當路由器被執行時，它會去查自己的註冊表中有沒有對應的規則，如果有就執行。由於 Run 前會用 Add 將規則都寫進路由器中，message 進來就會進行對應的調用。</p>\n<h2 id=\"use-router\"><a class=\"direct-link\" href=\"#use-router\">#</a> Use Router</h2>\n<p>來看看在 cmd 下應該如何使用設計好的路由器模組</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main<br><br><span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span><br>    <span class=\"token string\">\"fmt\"</span><br>    <span class=\"token string\">\"router/pkg/route\"</span><br><span class=\"token punctuation\">)</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    router <span class=\"token operator\">:=</span> route<span class=\"token punctuation\">.</span><span class=\"token function\">NewRouter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    router<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> helloHandler<span class=\"token punctuation\">)</span><br>    <span class=\"token keyword\">var</span> res route<span class=\"token punctuation\">.</span>Message<br>    req <span class=\"token operator\">:=</span> route<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">{</span><br>        Identification<span class=\"token punctuation\">:</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span><br>        Content<span class=\"token punctuation\">:</span>        <span class=\"token string\">\"Gopher\"</span><span class=\"token punctuation\">,</span><br>    <span class=\"token punctuation\">}</span><br>    router<span class=\"token punctuation\">.</span><span class=\"token function\">Run</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>res<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>req<span class=\"token punctuation\">)</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>Content<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">helloHandler</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> req <span class=\"token operator\">*</span>route<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    res<span class=\"token punctuation\">.</span>Content <span class=\"token operator\">=</span> req<span class=\"token punctuation\">.</span>Content<br><span class=\"token punctuation\">}</span></code></pre>\n<p>先由 pkg/route 引入使用的模組，建構新的路由器，對它進行註冊。假設可以由訊息的 Identification 來 Locate 訊息，則可以用</p>\n<pre class=\"language-go\"><code class=\"language-go\">router<span class=\"token punctuation\">.</span><span class=\"token function\">Add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> helloHandler<span class=\"token punctuation\">)</span></code></pre>\n<p>來標明 Identification 是 hello 的訊息，希望用 helloHandler 來處理，而 helloHandler 的內容是</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">helloHandler</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> req <span class=\"token operator\">*</span>route<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    res<span class=\"token punctuation\">.</span>Content <span class=\"token operator\">=</span> req<span class=\"token punctuation\">.</span>Content<br><span class=\"token punctuation\">}</span></code></pre>\n<p>它依照前面 route 模組 Handler 的定義，有兩個引數，分別表示 response 跟 request，helloHandler 會將 request 的 content 複製給 response。因此經過 helloHandler 後，出去的響應會有跟請求相同的內容。</p>\n<p>建立一則訊息，Identification 是 hello，Content 是 Gopher，執行路由。</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> res route<span class=\"token punctuation\">.</span>Message<br>req <span class=\"token operator\">:=</span> route<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">{</span><br>    Identification<span class=\"token punctuation\">:</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span><br>    Content<span class=\"token punctuation\">:</span>        <span class=\"token string\">\"Gopher\"</span><span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">}</span><br>router<span class=\"token punctuation\">.</span><span class=\"token function\">Run</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>res<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>req<span class=\"token punctuation\">)</span><br>fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>Content<span class=\"token punctuation\">)</span></code></pre>\n<p>寫好程式先編譯，看看結果</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">.<span class=\"token punctuation\">\\</span>scripts<span class=\"token punctuation\">\\</span>build_win.bat<br>.<span class=\"token punctuation\">\\</span>bin<span class=\"token punctuation\">\\</span>main.exe<br><br>Gopher</code></pre>\n<p>Content 成功複製給 response 了。</p>\n<h2 id=\"add-various-method\"><a class=\"direct-link\" href=\"#add-various-method\">#</a> Add Various Method</h2>\n<p>假設今天訊息類似 http method 一樣，有好幾種不同的處理方式，希望在進行註冊時，能明確各處理方式，免得出現 Get 寫成 Got 這類無意間拼錯的悲劇，可以怎麼做？</p>\n<p>首先，來修改 route 模組，先修改訊息格式，加入 method</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Message <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span><br>    Identification <span class=\"token builtin\">string</span><br>    Method         <span class=\"token builtin\">string</span><br>    Time           <span class=\"token builtin\">string</span><br>    Content        <span class=\"token builtin\">string</span><br>    Size           <span class=\"token builtin\">int</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>將 Add 由 public 改為 private，免得誤用，並增加各 method 的 function</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// add a route</span><br><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>Router<span class=\"token punctuation\">)</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>route <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> h Handler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">var</span> mergedHandler <span class=\"token operator\">=</span> h<br>    r<span class=\"token punctuation\">.</span>mux<span class=\"token punctuation\">[</span>route<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> mergedHandler<br><span class=\"token punctuation\">}</span><br><br><span class=\"token comment\">// Get add a get method pattern</span><br><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>Router<span class=\"token punctuation\">)</span> <span class=\"token function\">Get</span><span class=\"token punctuation\">(</span>route <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> h Handler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    r<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"get:\"</span><span class=\"token operator\">+</span>route<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token comment\">// Put add a put method pattern</span><br><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>Router<span class=\"token punctuation\">)</span> <span class=\"token function\">Put</span><span class=\"token punctuation\">(</span>route <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> h Handler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    r<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"put:\"</span><span class=\"token operator\">+</span>route<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token comment\">// Post add a post method pattern</span><br><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>Router<span class=\"token punctuation\">)</span> <span class=\"token function\">Post</span><span class=\"token punctuation\">(</span>route <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> h Handler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    r<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"post:\"</span><span class=\"token operator\">+</span>route<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token comment\">// Delete add a delete method pattern</span><br><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>Router<span class=\"token punctuation\">)</span> <span class=\"token function\">Delete</span><span class=\"token punctuation\">(</span>route <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> h Handler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    r<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"delete:\"</span><span class=\"token operator\">+</span>route<span class=\"token punctuation\">,</span> h<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>Run 函式改為</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>Router<span class=\"token punctuation\">)</span> <span class=\"token function\">Run</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> req <span class=\"token operator\">*</span>Message<span class=\"token punctuation\">)</span> <span class=\"token builtin\">error</span> <span class=\"token punctuation\">{</span><br>    route <span class=\"token operator\">:=</span> req<span class=\"token punctuation\">.</span>Method <span class=\"token operator\">+</span> <span class=\"token string\">\":\"</span> <span class=\"token operator\">+</span> req<span class=\"token punctuation\">.</span>Identification<br>    handler<span class=\"token punctuation\">,</span> exists <span class=\"token operator\">:=</span> r<span class=\"token punctuation\">.</span>mux<span class=\"token punctuation\">[</span>route<span class=\"token punctuation\">]</span><br>    <span class=\"token keyword\">if</span> exists <span class=\"token punctuation\">{</span><br>        <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> req<span class=\"token punctuation\">)</span><br>    <span class=\"token punctuation\">}</span><br>    <span class=\"token keyword\">return</span> <span class=\"token boolean\">nil</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>概念上很單純，就是在 key 上新加個字段，用來分別 method。</p>\n<p>使用上則變成</p>\n<pre class=\"language-go\"><code class=\"language-go\">router<span class=\"token punctuation\">.</span><span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> helloHandler<span class=\"token punctuation\">)</span><br><span class=\"token keyword\">var</span> res route<span class=\"token punctuation\">.</span>Message<br>req <span class=\"token operator\">:=</span> route<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">{</span><br>    Identification<span class=\"token punctuation\">:</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span><br>    Method<span class=\"token punctuation\">:</span>         <span class=\"token string\">\"get\"</span><span class=\"token punctuation\">,</span><br>    Content<span class=\"token punctuation\">:</span>        <span class=\"token string\">\"Gopher\"</span><span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">}</span><br>router<span class=\"token punctuation\">.</span><span class=\"token function\">Run</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>res<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>req<span class=\"token punctuation\">)</span></code></pre>\n<p>註冊時直接用 Get 來註冊即可。</p>\n<h2 id=\"add-middleware\"><a class=\"direct-link\" href=\"#add-middleware\">#</a> Add Middleware</h2>\n<p>如果現在有個情境，Identification foo 跟 bar 在進行核心的處理前，都需要某種共通的訊息處理，例如記錄運算時間，但 hello 不需要；或者是我們希望將前處理的邏輯跟核心處理邏輯分開，不要讓兩種不同邏輯混雜在一起，又要怎麼進行呢？這時就是 Middleware 派上用場的時刻了。</p>\n<p>Middleware 顧名思義，是軟體的中間層，可以想像成是 Request 到核心邏輯，再到 Response 這段的中間夾層。這些中間層可以類似漢堡的結構，你想要加入什麼樣的食材，例如高麗菜、牛肉、酸黃瓜、起司等等，你就多加一層中間層，藉此達到分離與彈性的效果。</p>\n<p><img src=\"/img/posts/2020/develop-your-middleware-by-golang/middleware.png\" alt=\"middleware 示意圖\"><em>middleware 示意圖</em></p>\n<p>為了讓 route 模組具有中間層的功能，新增</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// Middleware is public middleware</span><br><span class=\"token keyword\">type</span> middleware <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>Handler<span class=\"token punctuation\">)</span> Handler<br><br><span class=\"token comment\">// Router is router</span><br><span class=\"token keyword\">type</span> Router <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span><br>    middlewareChain <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>middleware<br>    mux <span class=\"token keyword\">map</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">]</span>Handler<br><span class=\"token punctuation\">}</span></code></pre>\n<p>middleware 是中間層的 type，它是個函式，會吃進 Handler 進行包裝後，再吐出包裝後，具有同樣簽名的 Handler。因為 middleware 的存在，可以再執行被包裝的 Handler 前，先執行一些想要的前處理。</p>\n<p>Router 的部分也加入 middlewareChain，讓這些 middleware 可以被註冊到路由器中，並進行嵌套式的包裝。</p>\n<p>另外，也需要改寫 add，並新增一個 middleware 的註冊函式</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token comment\">// Use add middleware</span><br><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>Router<span class=\"token punctuation\">)</span> <span class=\"token function\">Use</span><span class=\"token punctuation\">(</span>m middleware<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    r<span class=\"token punctuation\">.</span>middlewareChain <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">.</span>middlewareChain<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token comment\">// add a route</span><br><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">*</span>Router<span class=\"token punctuation\">)</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>route <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> h Handler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">var</span> mergedHandler <span class=\"token operator\">=</span> h<br>    <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">.</span>middlewareChain<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span> <span class=\"token punctuation\">{</span><br>    mergedHandler <span class=\"token operator\">=</span> r<span class=\"token punctuation\">.</span>middlewareChain<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>mergedHandler<span class=\"token punctuation\">)</span><br>    <span class=\"token punctuation\">}</span><br>    r<span class=\"token punctuation\">.</span>mux<span class=\"token punctuation\">[</span>route<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> mergedHandler<br><span class=\"token punctuation\">}</span></code></pre>\n<p>Use 負責將 middleware 加入路由器中；add 中新增一個 for 迴圈，對 Handler 進行包裝。可以看到 for 迴圈會由最後一個加入的 middleware 開始，一層一層將 middleware 包覆到 Handler 上，等全部都包裝完後，放進 route 中。</p>\n<p>最後修改 main 的使用方式，加入兩層 middleware</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    router <span class=\"token operator\">:=</span> route<span class=\"token punctuation\">.</span><span class=\"token function\">NewRouter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    router<span class=\"token punctuation\">.</span><span class=\"token function\">Use</span><span class=\"token punctuation\">(</span>cheeseMiddleware<span class=\"token punctuation\">)</span><br>    router<span class=\"token punctuation\">.</span><span class=\"token function\">Use</span><span class=\"token punctuation\">(</span>beefMiddleware<span class=\"token punctuation\">)</span><br>    router<span class=\"token punctuation\">.</span><span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> helloHandler<span class=\"token punctuation\">)</span><br>    <span class=\"token keyword\">var</span> res route<span class=\"token punctuation\">.</span>Message<br>    req <span class=\"token operator\">:=</span> route<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">{</span><br>        Identification<span class=\"token punctuation\">:</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span><br>        Method<span class=\"token punctuation\">:</span>         <span class=\"token string\">\"get\"</span><span class=\"token punctuation\">,</span><br>        Content<span class=\"token punctuation\">:</span>        <span class=\"token string\">\"Gopher\"</span><span class=\"token punctuation\">,</span><br>    <span class=\"token punctuation\">}</span><br>    router<span class=\"token punctuation\">.</span><span class=\"token function\">Run</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>res<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>req<span class=\"token punctuation\">)</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">.</span>Content<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">helloHandler</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> req <span class=\"token operator\">*</span>route<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This is core\"</span><span class=\"token punctuation\">)</span><br>    res<span class=\"token punctuation\">.</span>Content <span class=\"token operator\">+=</span> req<span class=\"token punctuation\">.</span>Content<br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">cheeseMiddleware</span><span class=\"token punctuation\">(</span>next route<span class=\"token punctuation\">.</span>Handler<span class=\"token punctuation\">)</span> route<span class=\"token punctuation\">.</span>Handler <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> req <span class=\"token operator\">*</span>route<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        res<span class=\"token punctuation\">.</span>Content <span class=\"token operator\">+=</span> <span class=\"token string\">\"cheese \"</span><br>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This is cheese\"</span><span class=\"token punctuation\">)</span><br>        <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> req<span class=\"token punctuation\">)</span><br>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This is cheese\"</span><span class=\"token punctuation\">)</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">beefMiddleware</span><span class=\"token punctuation\">(</span>next route<span class=\"token punctuation\">.</span>Handler<span class=\"token punctuation\">)</span> route<span class=\"token punctuation\">.</span>Handler <span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">return</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> req <span class=\"token operator\">*</span>route<span class=\"token punctuation\">.</span>Message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>        res<span class=\"token punctuation\">.</span>Content <span class=\"token operator\">+=</span> <span class=\"token string\">\"beef \"</span><br>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This is beef\"</span><span class=\"token punctuation\">)</span><br>        <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> req<span class=\"token punctuation\">)</span><br>        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"This is beef\"</span><span class=\"token punctuation\">)</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>在進到核心處理邏輯前，先加入一層 cheese，再加入一層 beef，這兩層 middleware 都會印出訊息，並修改 response 的內容。</p>\n<p>來看看輸出結果</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">.<span class=\"token punctuation\">\\</span>bin<span class=\"token punctuation\">\\</span>main.exe<br><br>This is cheese<br>This is beef<br>This is core<br>This is beef<br>This is cheese<br>cheese beef Gopher</code></pre>\n<p>夾心 Gopher 完成。</p>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>http 庫跟 middleware 是現代 Web 開發中常使用的設計模式，跟基本的 if else 相比，route 的邏輯非常乾淨，只需要</p>\n<pre class=\"language-go\"><code class=\"language-go\">router<span class=\"token punctuation\">.</span><span class=\"token function\">Use</span><span class=\"token punctuation\">(</span>cheeseMiddleware<span class=\"token punctuation\">)</span><br>router<span class=\"token punctuation\">.</span><span class=\"token function\">Use</span><span class=\"token punctuation\">(</span>beefMiddleware<span class=\"token punctuation\">)</span><br>router<span class=\"token punctuation\">.</span><span class=\"token function\">Get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span> helloHandler<span class=\"token punctuation\">)</span></code></pre>\n<p>就能看出程式碼的意圖，無須關注條件判斷。同時，因為 middleware 跟 route 在設計時已經對介面進行定義，其他人在開發時能根據相同的 interface 來設計，擴充性也比 if else 來得要好。</p>\n<p>這種以函式為主體，進行嵌套跟處理的模式，就是標準的函數式編程(Functional Programming)，這也是 Golang 相對於傳統語言的一大特色。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"https://drstearns.github.io/tutorials/gomiddleware/\">Middleware Patterns in Go</a></li>\n<li><a href=\"https://golang.org/pkg/net/http/\">Package http</a></li>\n</ul>\n",
      "date_published": "2020-06-14T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2020/develop-a-command-line-tool-by-golang/",
      "url": "https://blog.kenwsc.com/posts/2020/develop-a-command-line-tool-by-golang/",
      "title": "Go 命令行工具初體驗：使用標準包開發",
      "content_html": "<p>最初是在社群活動時接觸到 Golang，前陣子換工作後，新的產品團隊也是使用 Golang 來開發產品，在接觸新語言時覺得有些地方很有意思，好像能看到某種程式語言的變遷，或者說開發方向之類？跟常見的物件導向語言不同，Golang 不強調物件，而且帶有一些函式編程的特色，如果說 C++ 是替 C 補上物件導向的環節，那 Golang 更像是 C 語言的現代版。</p>\n<p>本篇會簡單介紹如何使用 Golang 來開發一個簡單的命令行工具。我們可以假設一個微服務開發的情境，開發者需要頻繁在開發環境中啟動或關閉微服務，這時它會需要一個工具，能依照需求啟動各個微服務，通常在 Linux，我們會使用 shell script 來做這件事；如果是 Windows，則會使用 power shell 或 batch file；更正式的生產環境，可能會採用容器調度工具。Golang 由於具有跨平台的特性，也可以用在這個情境中。</p>\n<h2 id=\"install-golang\"><a class=\"direct-link\" href=\"#install-golang\">#</a> Install Golang</h2>\n<p>開發前，當然要先安裝囉，對於 Windows 的使用者，會建議使用 chocolatey 來安裝</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">choco <span class=\"token function\">install</span> golang -y</code></pre>\n<p>安裝好後確認版本</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">go version</code></pre>\n<p>得到</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">go version go1.14 windows/amd64</code></pre>\n<p>由於 Golang 是發展快速的語言，對版本要特別注意，可能前個版本的功能或環境，到下個版本就不同了。</p>\n<p>然後，建議開發者的專案目錄可以長這樣</p>\n<pre><code>project\n├── cmd  # main applications for this project.\n|   └── main.go\n├── pkg  # code that's ok to use by external applications\n|   ├── module 1\n|   |   └── module.go\n|   └── module 2\n└── README.md\n</code></pre>\n<p>cmd 用來放主要的應用程式，pkg 用來放相關的 lib，更細部的 layout 可以參考相關<a href=\"https://github.com/golang-standards/project-layout\">連結</a>。因為我們的程式不會很大，這邊先用到 cmd 就可以了。</p>\n<h2 id=\"hello-world\"><a class=\"direct-link\" href=\"#hello-world\">#</a> Hello World</h2>\n<p>所有語言的入門款就是 Hello, World，在 cmd/main.go 下加入程式碼，印出第一行文字</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main<br><br><span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, world\"</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>package main 是這個 go file 所屬的 module，對於所有的 go file 而言，都會有專屬的模組，方便進行引用；import 則是引用其他的模組，fmt 是 format 的縮寫，是 Go 的標準庫，用來做一些格式化的輸入輸出，可以在相關的<a href=\"https://pkg.go.dev/fmt?tab=doc\">網站</a>看到說明</p>\n<blockquote>\n<p>Package fmt implements formatted I/O with functions analogous to C’s printf and scanf. The format ‘verbs’ are derived from C’s but are simpler.</p>\n</blockquote>\n<p>main 是 Go 的保留關鍵字，只要是 func main，就會是程式的入口，概念跟 C 語言的 int main() 相同。</p>\n<p>當敲好程式後，可以直接用 go run 來編譯並執行</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">go run cmd/main.go</code></pre>\n<p>將 command-line tool 整合到 language 中，這點就很有現代語言特色，讓開發者更專注心力於開發上。當然，如果只是想要 build 應用程式，也可以使用</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">go build -o micro-cli.exe ./cmd</code></pre>\n<p>執行完後可以看到專案目錄多了一個 micro-cli.exe，執行可以得到</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">D:<span class=\"token punctuation\">\\</span>git<span class=\"token punctuation\">\\</span>golang-introduction<span class=\"token operator\">></span>micro-cli.exe<br>Hello, world</code></pre>\n<h2 id=\"exec-system-command\"><a class=\"direct-link\" href=\"#exec-system-command\">#</a> Exec System Command</h2>\n<p>接著，我們需要使用 Golang 來執行外部的程式，引入 os/exec 這個模組</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, world\"</span><span class=\"token punctuation\">)</span><br>    noteCmd <span class=\"token operator\">:=</span> exec<span class=\"token punctuation\">.</span><span class=\"token function\">Command</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"notepad\"</span><span class=\"token punctuation\">)</span><br>    noteCmd<span class=\"token punctuation\">.</span><span class=\"token function\">Start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>這樣就能用 Golang 來打開記事本了。</p>\n<p>如果除了啟動程式，還需要重新導向該程式的標準輸出到現在的視窗，可以怎麼做？這邊先準備一個文字檔，裡面放要輸出的內容</p>\n<pre class=\"language-md\"><code class=\"language-md\"><span class=\"token title important\"><span class=\"token punctuation\">#</span> README</span><br><br>this is readme file</code></pre>\n<p>在 Windows 下，可以使用</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">type</span> README.md</code></pre>\n<p>來輸出檔案內容。我們將 go file 改成</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, world\"</span><span class=\"token punctuation\">)</span><br>    noteCmd <span class=\"token operator\">:=</span> exec<span class=\"token punctuation\">.</span><span class=\"token function\">Command</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cmd\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"/c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"type README.md\"</span><span class=\"token punctuation\">)</span><br>    buf <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><br>    stdout<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> noteCmd<span class=\"token punctuation\">.</span><span class=\"token function\">StdoutPipe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    noteCmd<span class=\"token punctuation\">.</span><span class=\"token function\">Start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    stdout<span class=\"token punctuation\">.</span><span class=\"token function\">Read</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><br>    os<span class=\"token punctuation\">.</span>Stdout<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>先建立一個 byte 的動態儲存陣列（Go 的專門用語叫 slice），大小是 1024，再將 noteCmd 的標準輸出建立 pipeline，連接到建好的陣列中。如此 noteCmd 的輸出就會像水管，源源不絕進到 buf，我們再由 buf 中取值，輸出到 micro-cli.exe 的標準輸出，完成串接。</p>\n<h2 id=\"parse-arguments\"><a class=\"direct-link\" href=\"#parse-arguments\">#</a> Parse Arguments</h2>\n<p>因為命令行工具需要對應到不同的情境，比如說，有些時候希望輸出 A 檔案的內容，有些時候希望輸出 B 檔案的內容，因此最好有個 option 可以讓人做切換。Golang 的標準庫自帶 argument parser，名稱是 flag，說明可以看<a href=\"https://pkg.go.dev/flag?tab=doc\">這</a>，用法是</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> <span class=\"token punctuation\">(</span><br>    help     <span class=\"token builtin\">bool</span><br>    filename <span class=\"token builtin\">string</span><br><span class=\"token punctuation\">)</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    flag<span class=\"token punctuation\">.</span><span class=\"token function\">BoolVar</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>help<span class=\"token punctuation\">,</span> <span class=\"token string\">\"h\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"this is help\"</span><span class=\"token punctuation\">)</span><br>    flag<span class=\"token punctuation\">.</span><span class=\"token function\">StringVar</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>filename<span class=\"token punctuation\">,</span> <span class=\"token string\">\"r\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"select your file\"</span><span class=\"token punctuation\">)</span><br>    flag<span class=\"token punctuation\">.</span>Usage <span class=\"token operator\">=</span> usage<br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    flag<span class=\"token punctuation\">.</span><span class=\"token function\">Parse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    <span class=\"token keyword\">if</span> help <span class=\"token punctuation\">{</span><br>    flag<span class=\"token punctuation\">.</span><span class=\"token function\">Usage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    <span class=\"token keyword\">return</span><br>    <span class=\"token punctuation\">}</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, world\"</span><span class=\"token punctuation\">)</span><br>    noteCmd <span class=\"token operator\">:=</span> exec<span class=\"token punctuation\">.</span><span class=\"token function\">Command</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cmd\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"/c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"type README.md\"</span><span class=\"token punctuation\">)</span><br>    buf <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><br>    stdout<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> noteCmd<span class=\"token punctuation\">.</span><span class=\"token function\">StdoutPipe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    noteCmd<span class=\"token punctuation\">.</span><span class=\"token function\">Start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    stdout<span class=\"token punctuation\">.</span><span class=\"token function\">Read</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><br>    os<span class=\"token punctuation\">.</span>Stdout<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">usage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Usage: micro-cli [-h] [-r filename]\"</span><span class=\"token punctuation\">)</span><br>    flag<span class=\"token punctuation\">.</span><span class=\"token function\">PrintDefaults</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>先看第一部分</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> <span class=\"token punctuation\">(</span><br>    help     <span class=\"token builtin\">bool</span><br>    filename <span class=\"token builtin\">string</span><br><span class=\"token punctuation\">)</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    flag<span class=\"token punctuation\">.</span><span class=\"token function\">BoolVar</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>help<span class=\"token punctuation\">,</span> <span class=\"token string\">\"h\"</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"this is help\"</span><span class=\"token punctuation\">)</span><br>    flag<span class=\"token punctuation\">.</span><span class=\"token function\">StringVar</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>filename<span class=\"token punctuation\">,</span> <span class=\"token string\">\"r\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"select your file\"</span><span class=\"token punctuation\">)</span><br>    flag<span class=\"token punctuation\">.</span>Usage <span class=\"token operator\">=</span> usage<br><span class=\"token punctuation\">}</span></code></pre>\n<p>用 var 建立兩個全域變數 help 跟 filename，用來儲存 flag 的值，接著在 init 設定 flag。func init 跟 func main 同樣是保留字，當程式進入時，會先執行 init 的內容，之後才進行 main，這用在一些初始化設定很方便。</p>\n<p>這邊做了三個初始化設定：(1) 看 h 這個選項是否存在，如果存在，賦值給 help，預設是 false，最後的文字是說明；(2) 看 r 這個選項是否存在，如果存在，賦值給 filename；(3) 將 Usage 這個函數指給 flag.Usage。</p>\n<p>再來看第二部分</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    flag<span class=\"token punctuation\">.</span><span class=\"token function\">Parse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    <span class=\"token keyword\">if</span> help <span class=\"token punctuation\">{</span><br>    flag<span class=\"token punctuation\">.</span><span class=\"token function\">Usage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    <span class=\"token keyword\">return</span><br>    <span class=\"token punctuation\">}</span><br>    <span class=\"token operator\">...</span><br><span class=\"token punctuation\">}</span><br><br><span class=\"token keyword\">func</span> <span class=\"token function\">usage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Usage: micro-cli [-h] [-r filename]\"</span><span class=\"token punctuation\">)</span><br>    flag<span class=\"token punctuation\">.</span><span class=\"token function\">PrintDefaults</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>使用 flag.Parse 來解析選項，並實際賦值給前面設定好的變數；使用後，就能運用 help 跟 filename 了，這邊定義，當使用者用了 h 參數，就印出使用說明。使用說明看函式 usage，會先印出使用方法，再用 PrintDefaults 顯示細部設定。</p>\n<p>來看看實際執行結果，先看 help</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">go run cmd/main.go -h<br><br>Usage: micro-cli <span class=\"token punctuation\">[</span>-h<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>-r filename<span class=\"token punctuation\">]</span><br>    -h this is <span class=\"token builtin class-name\">help</span><br>    -r string<br>       <span class=\"token keyword\">select</span> your <span class=\"token function\">file</span></code></pre>\n<p>簡單將使用說明與程式結合起來。</p>\n<p>接著，修改程式，來讀讀看不同的檔案</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    flag<span class=\"token punctuation\">.</span><span class=\"token function\">Parse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    <span class=\"token keyword\">if</span> help <span class=\"token punctuation\">{</span><br>    flag<span class=\"token punctuation\">.</span><span class=\"token function\">Usage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    <span class=\"token keyword\">return</span><br>    <span class=\"token punctuation\">}</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, world\"</span><span class=\"token punctuation\">)</span><br>    noteCmd <span class=\"token operator\">:=</span> exec<span class=\"token punctuation\">.</span><span class=\"token function\">Command</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cmd\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"/c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"type \"</span><span class=\"token operator\">+</span>filename<span class=\"token punctuation\">)</span><br>    buf <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><br>    stdout<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> noteCmd<span class=\"token punctuation\">.</span><span class=\"token function\">StdoutPipe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    noteCmd<span class=\"token punctuation\">.</span><span class=\"token function\">Start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    n<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> stdout<span class=\"token punctuation\">.</span><span class=\"token function\">Read</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><br>    os<span class=\"token punctuation\">.</span>Stdout<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>執行</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">go run cmd/main.go -r file1<br>Hello, world<br>This is <span class=\"token function\">file</span> <span class=\"token number\">1</span><br><br>go run cmd/main.go -r file2<br>Hello, world<br>This is <span class=\"token function\">file</span> <span class=\"token number\">2</span></code></pre>\n<p>只要後面帶不同的 filename，就能讀到不同的檔案了</p>\n<h2 id=\"read-config\"><a class=\"direct-link\" href=\"#read-config\">#</a> Read Config</h2>\n<p>因為每次要讀檔案，都要重新再輸入一次 option，對某些情境實在有點麻煩，想想，如果只有一兩個 option 就算了，假設現在 option 有 10 個，每次啟動程式都要輸入，很容易出現 typo，最好的辦法是將不常更改的 option 放在 config file，使用 config 來設定。</p>\n<p>先在專案結構中建立一個 configs 資料夾，用來放設定檔，設定檔格式可以使用 json，但不限制，這邊用 json 格式相對單純而且我比較熟</p>\n<pre><code>project\n├── cmd  # main applications for this project.\n|   └── main.go\n├── configs\n|   └── config.json\n├── pkg  # code that's ok to use by external applications\n|   ├── module 1\n|   |   └── module.go\n|   └── module 2\n└── README.md\n</code></pre>\n<p>內容是</p>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span><br>    <span class=\"token property\">\"filename\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"file1\"</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>為讀取 config，要先建立一個對應 config 結構的 struct，好讓程式知道該如何將 config 翻譯成物件</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> config <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span><br>    Filename <span class=\"token builtin\">string</span> <span class=\"token string\">`json:\"filename\"`</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>包在反引號 ` 中的文字是 Go 的 tag，它的功用是讓編譯器知道這個 struct 可以對應到 json，在這個例子中，struct config 的 field Filename 對應到 config file 的 filename 欄位。</p>\n<p>修改主程式來讀取設定檔</p>\n<pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><br>    data<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> ioutil<span class=\"token punctuation\">.</span><span class=\"token function\">ReadFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"configs/config.json\"</span><span class=\"token punctuation\">)</span><br>    <span class=\"token keyword\">var</span> fileConfig config<br>    json<span class=\"token punctuation\">.</span><span class=\"token function\">Unmarshal</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>fileConfig<span class=\"token punctuation\">)</span><br>    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, world\"</span><span class=\"token punctuation\">)</span><br>    noteCmd <span class=\"token operator\">:=</span> exec<span class=\"token punctuation\">.</span><span class=\"token function\">Command</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"cmd\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"/c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"type \"</span><span class=\"token operator\">+</span>fileConfig<span class=\"token punctuation\">.</span>Filename<span class=\"token punctuation\">)</span><br>    buf <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">byte</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><br>    stdout<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> noteCmd<span class=\"token punctuation\">.</span><span class=\"token function\">StdoutPipe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    noteCmd<span class=\"token punctuation\">.</span><span class=\"token function\">Start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    n<span class=\"token punctuation\">,</span> <span class=\"token boolean\">_</span> <span class=\"token operator\">:=</span> stdout<span class=\"token punctuation\">.</span><span class=\"token function\">Read</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">)</span><br>    os<span class=\"token punctuation\">.</span>Stdout<span class=\"token punctuation\">.</span><span class=\"token function\">Write</span><span class=\"token punctuation\">(</span>buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>使用 ioutil 來讀取檔案，將讀取到的 byte 資訊用 json.Unmarshal 反序列化，轉成人眼能看懂的結構，或者講更明白，賦值給 fileConfig 這個變數。接著，就能使用 fileConfig 內的 Filename 來讀取檔案了。</p>\n<p>觀察執行結果</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">go run cmd/main.go<br>Hello, world<br>This is <span class=\"token function\">file</span> <span class=\"token number\">1</span></code></pre>\n<p>好的，不用每次都帶 option 了。</p>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>用簡單的命令行工具，來當 Golang 的入門熱身，可以看到 Golang 跟 C 語言些相同的地方，例如它們都是靜態語言，可讀性跟可維護性較腳本語言更好，適合開發大型程式。但是 Golang 相對於 C，有幾項優點</p>\n<ul>\n<li>支援多重回傳值，有效解決 C 語言函式輸入輸出語意模糊的問題</li>\n<li>標準庫更強大，例如 flags 或是 ioutil，讓開發者能更專注於開發</li>\n<li>支援垃圾回收，同樣也讓開發者更專注於應用</li>\n<li>跨平台，這對當前的應用環境很重要，你絕對不希望換個作業系統要重寫一次程式碼</li>\n<li>工具齊全，有時候有點太齊全了，例如強制性的語法靜態檢查</li>\n<li>編譯速度快如閃電</li>\n</ul>\n<p>作為 Google 力推的程式語言，Golang 可以挖掘的地方還有很多，像是它最重要的賣點 Goroutine，很適合開發高併發程式；它的精簡語法也適合開發微服務。我們可以想像它是因應雲端世代而產生的新工具。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"https://github.com/golang-standards/project-layout\">Standard Go Project Layout</a></li>\n<li><a href=\"https://tour.golang.org/list\">A Tour of Go</a></li>\n</ul>\n",
      "date_published": "2020-06-06T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2020/use-conan-to-manage-c-package/",
      "url": "https://blog.kenwsc.com/posts/2020/use-conan-to-manage-c-package/",
      "title": "Conan：C/C++ 的套件管理工具",
      "content_html": "<p>開發 C++ 程式時，套件管理會是個困擾開發者的問題，C++ 不像 Python 有 pip；node.js 有 npm；lua 有 rock；C# 有 Nuget。它就只是沒有。沒有套件管理，當不同開發環境的使用者要開發程式時，不僅需要手動將相關的檔案塞進 repository 中，還會遇到相容性的問題，例如小明使用 paho-c 1.3.0 開發，開發到一半時，另一位開發者小華引用了小明放在 repo 中 include 資料夾下的 header file，卻使用了自己的 1.3.1 shared library，這使得兩個人的版本不相容，要花很多時間除錯。</p>\n<p>此外，當需要更新 repo 中的第三方套件版本時，需要手動將檔案放到 include 跟 libs 的資料夾，你引用多少套套件，你就要塞多少檔案進去；而跨平台的問題也是，Win32 可能要一份，Win64 要一份，Release 跟 Debug 的 Libs 各要一份，Linux 跟 Mac 再各要一份，最後 x86、arm、mips 再各要一份，自行排列組合一下就知道這個更新的痛苦了。為什麼我知道呢？因為我就是那個被困擾的人。</p>\n<p>好在許多開發者都有同樣的問題，於是 Conan 出來了，這是一個 C++ 套件管理工具，用 Python 寫成，目的在於協助開發者解決上述的困擾。本文會簡單介紹 Conan 的用法，希望大家看完後都能如獲新生。</p>\n<h2 id=\"install-conan\"><a class=\"direct-link\" href=\"#install-conan\">#</a> Install conan</h2>\n<p>首先來安裝 conan 這套工具，由於 conan 是用 python 寫的，也有在 pip 的 remote repo 中，因此只要用 pip 即可安裝</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken@DESKTOP-2R08VK6:~/git/conan/build$ pip3 <span class=\"token function\">install</span> conan<br>Collecting conan<br>    Downloading <span class=\"token punctuation\">[</span>https://files.pythonhosted.org/packages/2e/b7/560406ecd9d20e308498ce378dc8c1e0bc932f44d5377bc0ca62ec8dd75b/conan-1.21.1.tar.gz<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>https://files.pythonhosted.org/packages/2e/b7/560406ecd9d20e308498ce378dc8c1e0bc932f44d5377bc0ca62ec8dd75b/conan-1.21.1.tar.gz<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>552kB<span class=\"token punctuation\">)</span><br>    <span class=\"token number\">100</span>% <span class=\"token operator\">|</span>████████████████████████████████<span class=\"token operator\">|</span> 552kB 761kB/s <br>Collecting Jinja<span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>&lt;</span><span class=\"token number\">3</span>,<span class=\"token operator\">>=</span><span class=\"token number\">2.3</span> <span class=\"token punctuation\">(</span>from conan<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">..</span>.</code></pre>\n<p>安裝完記得重新讀取 .profile，引入 conan 指令</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">source</span> ~/.profile</code></pre>\n<h2 id=\"prepare-environment\"><a class=\"direct-link\" href=\"#prepare-environment\">#</a> Prepare Environment</h2>\n<p>來看一下專案環境，假設我們<a href=\"https://medium.com/@ken00535/use-cmake-to-build-cross-platform-application-8888db861cb3\">參照前篇</a>，用 cmake 來進行編譯，工作目錄會長</p>\n<pre><code>project/\n├── build/\n├── src/\n|   ├── CMakeLists.txt\n|   └── hello.cpp\n├── CMakeLists.txt\n├── conanfile.txt\n└── README\n</code></pre>\n<p>其中 src 放原始碼，hello.cpp 內容為經典的 hello, world</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"Poco/Thread.h\"</span></span><br><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">\"Poco/Runnable.h\"</span></span><br><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span><br><br><span class=\"token keyword\">class</span> <span class=\"token class-name\">HelloRunnable</span><span class=\"token operator\">:</span> <span class=\"token base-clause\"><span class=\"token keyword\">public</span> Poco<span class=\"token double-colon punctuation\">::</span><span class=\"token class-name\">Runnable</span></span><br><span class=\"token punctuation\">{</span><br>    <span class=\"token keyword\">virtual</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>    <span class=\"token punctuation\">{</span><br>        std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Hello, world!\"</span> <span class=\"token operator\">&lt;&lt;</span> std<span class=\"token double-colon punctuation\">::</span>endl<span class=\"token punctuation\">;</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span><br><br><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">{</span><br>    HelloRunnable runnable<span class=\"token punctuation\">;</span><br>    Poco<span class=\"token double-colon punctuation\">::</span>Thread thread<span class=\"token punctuation\">;</span><br>    thread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span>runnable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    thread<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>這邊使用 Poco 的 Lib 來創建 thread，並呼叫一個印出 Hello, world 的 Runnable。之所以用 Poco 是因為 conan 官方也用 Poco 當範例，而且方便進行跨平台。Lib 本身不是重點，重點是有使用了一個第三方套件。</p>\n<p>關於 CMakeLists.txt 的使用請參照前篇，不再多述，兩個 CMakeLists.txt 分別是</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># .CmakeLists.txt</span><br><br>CMAKE_MINIMUM_REQUIRED<span class=\"token punctuation\">(</span>VERSION <span class=\"token number\">2.6</span><span class=\"token punctuation\">)</span><br>PROJECT<span class=\"token punctuation\">(</span>HELLOLIB<span class=\"token punctuation\">)</span><br>ADD_SUBDIRECTORY<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">)</span></code></pre>\n<p>以及</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># .src/CmakeLists.txt</span><br><br>ADD_EXECUTABLE<span class=\"token punctuation\">(</span>hello hello.cpp<span class=\"token punctuation\">)</span></code></pre>\n<h2 id=\"edit-conanfile\"><a class=\"direct-link\" href=\"#edit-conanfile\">#</a> Edit conanfile</h2>\n<p>conan 使用 conanfile.txt 來管理套件，conanfile 的格式有點像 TOML，但我找不到官方說法，對使用者來說也許不用想太多，只要知道是某種配置文件就行，它的內容是</p>\n<pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token header\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">requires</span><span class=\"token punctuation\">]</span></span><br>Poco/1.9.4@pocoproject/stable<br><br><span class=\"token header\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">generators</span><span class=\"token punctuation\">]</span></span><br>cmake</code></pre>\n<p>這段內容表示依賴套件是 Poco，版本 1.9.4，來源 pocoproject/stable，產生cmake 模組。</p>\n<p>接著進到 build 目錄，使用 conan</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken@DESKTOP-2R08VK6:~/git/conan/build$ conan <span class=\"token function\">install</span> <span class=\"token punctuation\">..</span><br>Configuration:<br><span class=\"token punctuation\">[</span>settings<span class=\"token punctuation\">]</span><br><span class=\"token assign-left variable\">arch</span><span class=\"token operator\">=</span>x86_64<br><span class=\"token assign-left variable\">arch_build</span><span class=\"token operator\">=</span>x86_64<br><span class=\"token assign-left variable\">build_type</span><span class=\"token operator\">=</span>Release<br><span class=\"token assign-left variable\">compiler</span><span class=\"token operator\">=</span>gcc<br>compiler.libcxx<span class=\"token operator\">=</span>libstdc++<br>compiler.version<span class=\"token operator\">=</span><span class=\"token number\">7</span><br><span class=\"token assign-left variable\">os</span><span class=\"token operator\">=</span>Linux<br><span class=\"token assign-left variable\">os_build</span><span class=\"token operator\">=</span>Linux<br><span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span><br><span class=\"token punctuation\">[</span>build_requires<span class=\"token punctuation\">]</span><br><span class=\"token punctuation\">[</span>env<span class=\"token punctuation\">]</span><br><br>conanfile.txt: Installing package<br>Requirements<br>    OpenSSL/1.0.2o@conan/stable from <span class=\"token string\">'conan-center'</span> - Cache<br>    Poco/1.9.4@pocoproject/stable from <span class=\"token string\">'conan-center'</span> - Cache<br>    zlib/1.2.11@conan/stable from <span class=\"token string\">'conan-center'</span> - Cache<br>Packages<br>    OpenSSL/1.0.2o@conan/stable:b781af3f476d0aa5070a0a35b544db7a3c193cc8 - Cache<br>    Poco/1.9.4@pocoproject/stable:57e3039664a87aab5ccabd995efae6da01c1ff17 - Cache<br>    zlib/1.2.11@conan/stable:d50a0d523d98c15bb147b18fa7d203887c38be8b - Cache<br><br>zlib/1.2.11@conan/stable: Already installed<span class=\"token operator\">!</span><br>OpenSSL/1.0.2o@conan/stable: Already installed<span class=\"token operator\">!</span><br>Poco/1.9.4@pocoproject/stable: Already installed<span class=\"token operator\">!</span><br>conanfile.txt: Generator cmake created conanbuildinfo.cmake<br>conanfile.txt: Generator txt created conanbuildinfo.txt<br>conanfile.txt: Generated conaninfo.txt<br>conanfile.txt: Generated graphinfo</code></pre>\n<p>然後工作目錄就變成</p>\n<pre><code>project/\n├── build/\n|   ├── ...\n|   ├── conanbuildinfo.cmake\n|   └── ...\n├── src/\n|   ├── CMakeLists.txt\n|   └── hello.cpp\n├── CMakeLists.txt\n├── conanfile.txt\n└── README\n</code></pre>\n<p>跟之前對照，多出了 cmake 模組 conanbuildinfo.cmake</p>\n<h2 id=\"modify-cmakelists\"><a class=\"direct-link\" href=\"#modify-cmakelists\">#</a> Modify CMakeLists</h2>\n<p>之所以要有 cmake 模組，就是為了讓 cmake 引用，因此要回頭改 CMakeLists.txt，將 conan 相關的指令加進去</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># .CMakeLists.txt</span><br><br>CMAKE_MINIMUM_REQUIRED<span class=\"token punctuation\">(</span>VERSION <span class=\"token number\">2.6</span><span class=\"token punctuation\">)</span><br>PROJECT<span class=\"token punctuation\">(</span>HELLOLIB<span class=\"token punctuation\">)</span><br><br>INCLUDE<span class=\"token punctuation\">(</span><span class=\"token variable\">${CMAKE_BINARY_DIR}</span>/conanbuildinfo.cmake<span class=\"token punctuation\">)</span><br>CONAN_BASIC_SETUP<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><br>INCLUDE_DIRECTORIES<span class=\"token punctuation\">(</span><span class=\"token variable\">${CONAN_INCLUDE_DIRS}</span><span class=\"token punctuation\">)</span><br>MESSAGE<span class=\"token punctuation\">(</span>STATUS <span class=\"token variable\">${CONAN_INCLUDE_DIRS}</span><span class=\"token punctuation\">)</span><br>ADD_SUBDIRECTORY<span class=\"token punctuation\">(</span>src<span class=\"token punctuation\">)</span></code></pre>\n<p>其中 INCLUDE 是引用 conan 產生的 cmake 模組；CONAN_BASIC_SETUP 會設定 conan 需要的變數；INCLUDE_DIRECTORIES 是引用 conan 相關的 header file，免去手動搬運 header file 的麻煩。MESSAGE 可加可不加，這邊是用來印出 conan header file 的所在目錄，讓開發者心底踏實一點。</p>\n<p>而另一個 CMakeLists.txt 則改成</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># .src/CMakeLists.txt</span><br><br>ADD_EXECUTABLE<span class=\"token punctuation\">(</span>hello hello.cpp<span class=\"token punctuation\">)</span><br>TARGET_LINK_LIBRARIES<span class=\"token punctuation\">(</span>hello <span class=\"token variable\">${CONAN_LIBS}</span><span class=\"token punctuation\">)</span></code></pre>\n<p>非常單純，就是鏈結 conan 相關的 lib。</p>\n<h2 id=\"build\"><a class=\"direct-link\" href=\"#build\">#</a> Build</h2>\n<p>關鍵的時候到了，用 cmake 配置並編譯</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken@DESKTOP-2R08VK6:~/git/conan/build$ cmake <span class=\"token punctuation\">..</span><br>-- The C compiler identification is GNU <span class=\"token number\">7.4</span>.0<br><span class=\"token punctuation\">..</span>.<br>-- /home/ken/.conan/data/Poco/1.9.4/pocoproject/stable/package/57e3039664a87aab5ccabd995efae6da01c1ff17/include/home/ken/.conan/data/OpenSSL/1.0.2o/conan/stable/package/b781af3f476d0aa5070a0a35b544db7a3c193cc8/include/home/ken/.conan/data/zlib/1.2.11/conan/stable/package/d50a0d523d98c15bb147b18fa7d203887c38be8b/include<br><span class=\"token punctuation\">..</span>.</code></pre>\n<p>可以看到 conan 抓下來的檔案會放在 user 家目錄的 .conan。</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken@DESKTOP-2R08VK6:~/git/conan/build$ cmake --build <span class=\"token builtin class-name\">.</span><br>Scanning dependencies of target hello<br><span class=\"token punctuation\">[</span> <span class=\"token number\">50</span>%<span class=\"token punctuation\">]</span> Building CXX object src/CMakeFiles/hello.dir/hello.cpp.o<br><span class=\"token punctuation\">[</span><span class=\"token number\">100</span>%<span class=\"token punctuation\">]</span> Linking CXX executable <span class=\"token punctuation\">..</span>/bin/hello<br><span class=\"token punctuation\">[</span><span class=\"token number\">100</span>%<span class=\"token punctuation\">]</span> Built target hello</code></pre>\n<p>編譯完成，來執行看看</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken@DESKTOP-2R08VK6:~/git/conan/build$ ./bin/hello <br>Hello, world<span class=\"token operator\">!</span></code></pre>\n<p>結束！conan 自動抓完 header file 跟 library，開發者不要再煩惱套件跟庫管理了，專心來享受寫程式的快樂吧。</p>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>看到 conan 能自動管理套件，真的不是個「爽」字能形容，套句強者我同事的話：「我不常寫 C++，因為它的套件管理太可怕了」。有使用開源程式碼開發的人，應該非常能了解這種感受。</p>\n<p>在使用 conan 開發途中，難免踩到一些坑，直接上 GitHub 發問後，沒想到 conan 的 Contributor 在短短幾小時內就快速回覆，還 involve 相關專案的 Contributor 一起來確認，現在開源社群的活躍度已經這麼厲害了嗎？</p>\n<p>要說 conan 的問題，可能是普及度還不夠，有時需要的 library 不一定會有，但我覺得這沒有關係，只要會 python，就可以捲起袖子，把自己要用的 library 打包後回饋，讓其他人也能快速利用同樣的資源。畢竟人生苦短，不要重複造輪子，我們可以面朝大海。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"https://conan.io/\">Conan Official Website</a></li>\n<li><a href=\"https://docs.conan.io/en/latest/reference/generators/cmake.html\">常用的 conan cmake 變數</a></li>\n<li><a href=\"http://blog.guorongfei.com/2018/04/23/conan-tutorial/\">C++包管理器 — — conan</a></li>\n</ul>\n",
      "date_published": "2020-01-18T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2020/use-cmake-to-build-cross-platform-application/",
      "url": "https://blog.kenwsc.com/posts/2020/use-cmake-to-build-cross-platform-application/",
      "title": "跨平台軟體建置：CMake 入門",
      "content_html": "<p>當我們將軟體的價值視為服務時，跨平台就會越來越重要，因為它代表軟體能跨越限制，降低客戶使用成本，進而更快創造價值。工程師可能很難想像，當客戶拿到新軟體時，他需要面對一堆設定問題，還需要建置平台，這會是一件多讓人厭世的事。</p>\n<p>常見的跨平台是指，軟體可在三大主流平台上運作，也就是支援 Windows、Linux、Mac；也有些跨平台指硬體平台，像是 x86 或 arm。本文會用 cmake 這個跨平台建置工具，分別建置可於 Windows 與 Linux 上執行的應用程式。</p>\n<h2 id=\"prerequisite\"><a class=\"direct-link\" href=\"#prerequisite\">#</a> Prerequisite</h2>\n<p>對於 Windows 的開發者，建議用 MinGW 來建置，這個工具讓 Windows 上有跟 Linux 相同的操作經驗，可以避免二次學習。Windows 10 有很便利的 Package Management Chocolatey，類似 Ubuntu 的 apt 或 Fedora 的 yum，可以用來安裝 MinGW</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">choco <span class=\"token function\">install</span> mingw -y</code></pre>\n<h2 id=\"install-cmake\"><a class=\"direct-link\" href=\"#install-cmake\">#</a> Install CMake</h2>\n<p>主角可以登場了，使用 Chocolatey 來安裝 cmake</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">choco <span class=\"token function\">install</span> cmake -y</code></pre>\n<p>安裝完執行</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">cmake</code></pre>\n<p>來看是否安裝成功</p>\n<p><img src=\"/img/posts/2020/use-cmake-to-build-cross-platform-application/cmake-1.png\" alt=\"\"></p>\n<p>如果 Command Prompt 找不到 cmake，確認有沒有將 cmake 的執行檔路徑加入 PATH 環境變數。 Command Prompt 會從 PATH 中抓指令，如果沒加的話記得加入並重新啟動 Command Prompt。</p>\n<h2 id=\"prepare-source-code\"><a class=\"direct-link\" href=\"#prepare-source-code\">#</a> Prepare Source Code</h2>\n<p>先看一下 cmake 的資料夾結構，通常會是</p>\n<pre><code>project/\n├── build/\n├── src/\n|   ├── CMakeLists.txt\n|   └── hello.c\n├── CMakeLists.txt\n└── README\n</code></pre>\n<p>build 資料夾用於放置 cmake 的建構文件；src 用於放置原始碼；CMakeLists.txt 類似 GNU 中的 makefile，用於描述應該如何建構檔案。cmake 使用遞迴建構，每個子資料夾中都要放置該資料夾的 CMakeLists.txt。</p>\n<p>當建立好資料夾後，在 src 底下產生 hello.c，內容是</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span><br><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">{</span><br>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello World!\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>如此一來，環境就準備完成了。</p>\n<h2 id=\"edit-cmake-makefile\"><a class=\"direct-link\" href=\"#edit-cmake-makefile\">#</a> Edit CMake makefile</h2>\n<p>有了環境後，開始 cmake 的重頭戲：編寫 CmakeLists.txt。先處理最上層專案目錄的 CmakeLists.txt</p>\n<pre class=\"language-makefile\"><code class=\"language-makefile\">PROJECT <span class=\"token punctuation\">(</span>HELLO<span class=\"token punctuation\">)</span><br>ADD_SUBDIRECTORY<span class=\"token punctuation\">(</span>src bin<span class=\"token punctuation\">)</span></code></pre>\n<p>對，兩行，就這樣，有沒有很單純？cmake 的語法是</p>\n<pre class=\"language-makefile\"><code class=\"language-makefile\">CMD <span class=\"token punctuation\">(</span>ARG<span class=\"token punctuation\">)</span></code></pre>\n<p>所以這兩行的意思是：(1) 命名專案為 HELLO；(2) 加入子目錄 src，並將產生的目標檔放入 bin 目錄中。</p>\n<p>接著來看 src 中的 CmakeLists.txt</p>\n<pre class=\"language-makefile\"><code class=\"language-makefile\">ADD_EXECUTABLE<span class=\"token punctuation\">(</span>hello hello.c<span class=\"token punctuation\">)</span></code></pre>\n<p>意思是使用 hello.c 產生 hello 執行檔。</p>\n<p>由於專案目錄中的 CmakeLists.txt 會引用到 src 中的 CmakeLists.txt，當 cmake 執行時，它會讀取兩個 CmakeLists.txt，並按照命令來設定建置環境。</p>\n<h2 id=\"compile-for-windows\"><a class=\"direct-link\" href=\"#compile-for-windows\">#</a> Compile for Windows</h2>\n<p>我們來試著建置 Windows 的應用程式，因為 cmake 的設計原則是將 src 與建置環境分開，不要讓 cmake 產生出來的文件汙染專案，強烈建議進入 build 中建置</p>\n<pre class=\"language-makefile\"><code class=\"language-makefile\">cd build<br>cmake -G <span class=\"token string\">\"MinGW Makefiles\"</span> ..</code></pre>\n<p>使用 -G 是選擇 build system 的 Generator；cmake 支援 Visual Studio 專案、MinGW Makefiles、CodeLite 專案等等。由於我們希望操作方式盡量一致，使用與 GNU 風格相同的 MinGW。</p>\n<p>此時，會看到 cmake 在 build 下自動產生文件</p>\n<pre><code>project/\n├── build/\n|   ├── bin/\n|   ├── CMakeFiles/\n|   ├── cmake_install.cmake\n|   └── Makefile\n├── src/\n|   ├── CMakeLists.txt\n|   └── hello.c\n├── CMakeLists.txt\n└── README\n</code></pre>\n<p>看到 Makefile 後，直接反應就是 make 啦</p>\n<pre><code>mingw32-make\n</code></pre>\n<p>得到編譯訊息</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">D:<span class=\"token punctuation\">\\</span>git<span class=\"token punctuation\">\\</span>cmake-example<span class=\"token punctuation\">\\</span>t2<span class=\"token punctuation\">\\</span>build<span class=\"token operator\">></span>mingw32-make<br>Scanning dependencies of target hello<br><span class=\"token punctuation\">[</span> <span class=\"token number\">50</span>%<span class=\"token punctuation\">]</span> Building C object bin/CMakeFiles/hello.dir/hello.obj<br><span class=\"token punctuation\">[</span><span class=\"token number\">100</span>%<span class=\"token punctuation\">]</span> Linking C executable hello.exe<br><span class=\"token punctuation\">[</span><span class=\"token number\">100</span>%<span class=\"token punctuation\">]</span> Built target hello</code></pre>\n<p>執行檔案</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">D:<span class=\"token punctuation\">\\</span>git<span class=\"token punctuation\">\\</span>cmake-example<span class=\"token punctuation\">\\</span>t2<span class=\"token punctuation\">\\</span>build<span class=\"token operator\">></span>.<span class=\"token punctuation\">\\</span>bin<span class=\"token punctuation\">\\</span>hello.exe<br>Hello World<span class=\"token operator\">!</span></code></pre>\n<p>Windows 版本建置完成。</p>\n<h2 id=\"compile-for-linux\"><a class=\"direct-link\" href=\"#compile-for-linux\">#</a> Compile for Linux</h2>\n<p>將相同的專案複製到 Linux 底下，再次編譯。如果你是使用 Windows 為開發平台，可以使用 WSL 來建構 Linux 環境。執行步驟相同，只是使用 cmake 時不用加 MinGW，下 cmake 前記得清空 build 資料夾</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> build<br><span class=\"token function\">rm</span> -rf ./*<br>cmake <span class=\"token punctuation\">..</span></code></pre>\n<p>得到配置訊息</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken@DESKTOP-2R08VK6:/mnt/d/git/cmake-example/t2/build$ cmake <span class=\"token punctuation\">..</span><br>-- The C compiler identification is GNU <span class=\"token number\">7.4</span>.0<br>-- The CXX compiler identification is GNU <span class=\"token number\">7.4</span>.0<br>-- Check <span class=\"token keyword\">for</span> working C compiler: /usr/bin/cc<br>-- Check <span class=\"token keyword\">for</span> working C compiler: /usr/bin/cc -- works<br>-- Detecting C compiler ABI info<br>-- Detecting C compiler ABI info - <span class=\"token keyword\">done</span><br>-- Detecting C compile features<br>-- Detecting C compile features - <span class=\"token keyword\">done</span><br>-- Check <span class=\"token keyword\">for</span> working CXX compiler: /usr/bin/c++<br>-- Check <span class=\"token keyword\">for</span> working CXX compiler: /usr/bin/c++ -- works<br>-- Detecting CXX compiler ABI info<br>-- Detecting CXX compiler ABI info - <span class=\"token keyword\">done</span><br>-- Detecting CXX compile features<br>-- Detecting CXX compile features - <span class=\"token keyword\">done</span><br>CMake Warning <span class=\"token punctuation\">(</span>dev<span class=\"token punctuation\">)</span> <span class=\"token keyword\">in</span> CMakeLists.txt:<br>    No cmake_minimum_required <span class=\"token builtin class-name\">command</span> is present.  A line of code such as<br><br>cmake_minimum_required<span class=\"token punctuation\">(</span>VERSION <span class=\"token number\">3.10</span><span class=\"token punctuation\">)</span><br><br>should be added at the <span class=\"token function\">top</span> of the file.  The version specified may be lower<br>    <span class=\"token keyword\">if</span> you wish to support older CMake versions <span class=\"token keyword\">for</span> this project.  For <span class=\"token function\">more</span><br>    information run <span class=\"token string\">\"cmake --help-policy CMP0000\"</span><span class=\"token builtin class-name\">.</span><br>This warning is <span class=\"token keyword\">for</span> project developers.  Use -Wno-dev to suppress it.<br><br>-- Configuring <span class=\"token keyword\">done</span><br>-- Generating <span class=\"token keyword\">done</span><br>-- Build files have been written to: /mnt/d/git/cmake-example/t2/build</code></pre>\n<p>進行編譯</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">make</span></code></pre>\n<p>得到</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken@DESKTOP-2R08VK6:/mnt/d/git/cmake-example/t2/build$ <span class=\"token function\">make</span><br>Scanning dependencies of target hello<br><span class=\"token punctuation\">[</span> <span class=\"token number\">50</span>%<span class=\"token punctuation\">]</span> Building C object bin/CMakeFiles/hello.dir/main.o<br><span class=\"token punctuation\">[</span><span class=\"token number\">100</span>%<span class=\"token punctuation\">]</span> Linking C executable hello<br><span class=\"token punctuation\">[</span><span class=\"token number\">100</span>%<span class=\"token punctuation\">]</span> Built target hello</code></pre>\n<p>執行程式</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken@DESKTOP-2R08VK6:/mnt/d/git/cmake-example/t2/build$ ./bin/hello <br>Hello World<span class=\"token operator\">!</span></code></pre>\n<p>如果對檔案格式有興趣，也可以用 file 指令查看</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken@DESKTOP-2R08VK6:/mnt/d/git/cmake-example/t2/build$ <span class=\"token function\">file</span> ./bin/hello <br>./bin/hello: ELF <span class=\"token number\">64</span>-bit LSB shared object, x86-64, version <span class=\"token number\">1</span> <span class=\"token punctuation\">(</span>SYSV<span class=\"token punctuation\">)</span>, dynamically linked, interpreter /lib64/l, <span class=\"token keyword\">for</span> GNU/Linux <span class=\"token number\">3.2</span>.0, BuildID<span class=\"token punctuation\">[</span>sha1<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>e7fcca840caa7d5e99bdd0e26bf329b79b7e83fd, not stripped</code></pre>\n<p>可看到 ELF 是 Linux 可執行檔格式。</p>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>cmake 雖然功能不錯，但學習曲線真的有點陡，別看簡單寫個 hello, world，中間的坑一堆；不是很理解 cmake 反人類的語法是怎麼設計的，跟其他語言差距非常大，剛開始發現沒有 case sensitive 時還很開心，結果程式碼一寫長就覺得風格混亂，維護困難；每個子資料夾都要 CmakeLists.txt 也讓人無言，容易迷路在專案結構中，看不到全貌；最麻煩的是除錯困難，範例又少，要使用 cmake 幾乎無法避免一系列花式踩坑。</p>\n<p>但是！對於 C/C++ 的跨平台建構來說，cmake 仍是目前最方便最主流的工具，支援的 Generator 夠多，成熟度也高。如果開發者有使用 autotools 來建構專案的經驗，應該能上手 cmake。我不是要黑使用 Visual Studio 的開發者，但如果習慣 GUI 的人，應該會覺得痛苦指數很高。cmake 有自己的圖形介面，似乎也能跟 Visual Studio 整合，但這就留到日後再來慢慢研究了。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"https://cmake.org/\">Cmake Official Website</a></li>\n<li><a href=\"https://www.zhihu.com/question/276415476\">如何評價 CMake？</a></li>\n</ul>\n",
      "date_published": "2020-01-12T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2019/use-codelite-to-program-c/",
      "url": "https://blog.kenwsc.com/posts/2019/use-codelite-to-program-c/",
      "title": "C++ 開發環境架設：使用 CodeLite",
      "content_html": "<p>很久沒寫 C++ 了，上次是一年多前的事，當時為了在專案中使用 TDD 開發，套用 CppUTest 當 Unit Test Framework，而這套 Framework 就是用 C++ 寫的。最近工作上又需要用到 C++ 當底層資源，環境重架之餘，順手紀錄一下歷程。</p>\n<p>原本的開發環境是 Windows 7 + uVision，使用 C 來開發 MCU。為了導入 TDD，需要在 Local 端有編譯執行的能力，考量到資源開放性，選擇用 cygwin 來執行 GNU，同時選擇當時資源豐富的 VSCode 做為編輯器。如果現在重選的話，可能會直接使用 Ubuntu 的 GNU，搭配 STM32CubeMX 自動生成 Makefile 來編譯，不論是自由度還是效能都較好，而且沒有後面 cygwin 一系列踩坑問題，But，人生就是這個 But，當時我不知道 cygwin 有這麼多坑。</p>\n<p>由於現在工作的開發環境會用 Windows 10，仍然需要找個在 Windows 下的編譯執行工具，同時也希望是 cross-platform，無論 IDE 有多好，如果不能 cross-platform，不利於現在變動頻繁的開發環境與挑戰（想想看，原本用 .NET 全家餐用得好好的，結果開發環境變 Linux，又要重新用一套 IDE，而且你可能已經在原本的 IDE 上自行整合一些套件了）。現行的幾款 C++ IDE 有 CodeLite、Eclipse、CLion、Dev-C++、Visual Studio。由於我不想為 C++ 重新編寫 Makefile，不考慮 VSCode、Notepad++ 等 Editor；Dev-C++ 跟 Visual Studio 因為無法跨平台也劃掉；CLion 是 JetBrains 開發的 IDE，據說相當優秀，是很多人的首選，但我只需要開發小程式，用付款軟體太麻煩，劃掉；Eclipse 通常開發 Java 比較多，而且吃的資源有點兇，因此最後選用 CodeLite 來開發。</p>\n<p>如果你是習慣使用 Visual Studio 的 Windows 開發者，不用懷疑，直接用 Visual Studio；如果你想在工作上選擇一款 cross-platform，CLion 是你的好夥伴；如果你只是想簡單寫點程式來驗證概念，也許可以跟我一樣用 CodeLite。</p>\n<h2 id=\"install-mingw\"><a class=\"direct-link\" href=\"#install-mingw\">#</a> Install MinGW</h2>\n<p>CodeLite 底層推薦用 MinGW 中的 GNU toolchain 來編譯，如果對象平台是 Windows，也可以使用 Visual C++，因為 WIN 10 有 WSL 可以執行 Linux Binary File，使用 MinGW 就能滿足需求了。</p>\n<p>MinGW 是一套 Windows 下的開發環境，讓 Windows 的開發者也能使用 GNU 等 Linux 工具。要安裝 MinGW，到 <a href=\"http://mingw.org/\">MinGW 官網</a>下載安裝程式</p>\n<p><img src=\"/img/posts/2019/use-codelite-to-program-c/codelite-1.png\" alt=\"\"></p>\n<p>安裝時，在 Basic Setup 中選擇 mingw32-base-bin、mingw32-gcc-g++-bin、msys-base-bin</p>\n<p><img src=\"/img/posts/2019/use-codelite-to-program-c/codelite-2.png\" alt=\"\"></p>\n<p>安裝完後，要將執行檔路徑加入環境變數，讓 CodeLite 能抓到底層。打開控制台\\系統及安全性\\系統，選擇[進階系統設定]，點選[環境變數]</p>\n<p><img src=\"/img/posts/2019/use-codelite-to-program-c/codelite-3.png\" alt=\"\"></p>\n<p>在系統變數中，編輯 Path</p>\n<p><img src=\"/img/posts/2019/use-codelite-to-program-c/codelite-4.png\" alt=\"\"></p>\n<p>將 C:\\MinGW\\bin 加入 Path 中。</p>\n<h2 id=\"install-codelite\"><a class=\"direct-link\" href=\"#install-codelite\">#</a> Install CodeLite</h2>\n<p>接著來安裝 CodeLite，到官網下載安裝檔，官網上可以看到 CodeLite 主要支援三款語言：C++、php、node.js，主要 TA 是放在後端上</p>\n<p><img src=\"/img/posts/2019/use-codelite-to-program-c/codelite-5.png\" alt=\"\"></p>\n<p>下載，解壓縮，執行，一路安裝精靈到結束，沒難度。</p>\n<h2 id=\"configure-codelite\"><a class=\"direct-link\" href=\"#configure-codelite\">#</a> Configure CodeLite</h2>\n<p>首次執行 CodeLite 時，先用 Setup Wizard 設定環境，開發的環境先用 C/C++</p>\n<p><img src=\"/img/posts/2019/use-codelite-to-program-c/codelite-6.png\" alt=\"\"></p>\n<p>如果前面有成功安裝 MinGW 跟 g++，這邊選擇 Compiler 時就會看到</p>\n<p><img src=\"/img/posts/2019/use-codelite-to-program-c/codelite-7.png\" alt=\"\"></p>\n<h2 id=\"test-example\"><a class=\"direct-link\" href=\"#test-example\">#</a> Test Example</h2>\n<p>設定完後，用 CodeLite 來寫一支簡單的 C++，確認功能正常。先建立工作空間，在工作空間點右鍵，加入新專案</p>\n<p><img src=\"/img/posts/2019/use-codelite-to-program-c/codelite-8.png\" alt=\"\"></p>\n<p>選擇用 g++ 的 Console Template</p>\n<p><img src=\"/img/posts/2019/use-codelite-to-program-c/codelite-9.png\" alt=\"\"></p>\n<p>CodeLite 會套用範本長出基本檔案</p>\n<pre><code>CPPWorkspace\n├-- Test1\n    ├-- src\n        ├-- main.cpp\n</code></pre>\n<p>打開 main.cpp，查看內容</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span><br><br><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> argc<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span><span class=\"token operator\">*</span>argv<span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">{</span><br>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello world\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><br>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>由於這是 C，將它改成 C++</p>\n<pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span><br><br><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token punctuation\">{</span><br>    std<span class=\"token double-colon punctuation\">::</span>cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"Hello testing...\"</span><span class=\"token punctuation\">;</span><br>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span><br><span class=\"token punctuation\">}</span></code></pre>\n<p>來建置並執行程式，先在導覽列選擇 Build &gt; Clean Project ，把舊的檔案（如果有的話）清空，選擇 Run 來建置執行</p>\n<p><img src=\"/img/posts/2019/use-codelite-to-program-c/codelite-10.png\" alt=\"\"></p>\n<p>程式執行完成，開發環境建好啦！</p>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>整個執行下來，最麻煩的不是軟體操作，而是一開始要選用哪個 IDE。原本想依照平常的開發環境，選用 VSCode，但因為需要 Compiler，又不想用 cygwin，只好研究 VSCode 跟 WSL 的串法，真的串起來後又發現自己不想寫 Makefile，只好回去選別的 IDE。</p>\n<p>也想說是不是直接用 cl 來編譯，但查詢 VSCode 的<a href=\"https://code.visualstudio.com/docs/cpp/config-msvc\">文件</a>後，發現</p>\n<blockquote>\n<p>Start VS Code from the Developer Command Prompt</p>\n<p>To use MSVC in VS Code, you must start VS Code from a Developer Command Prompt for Visual Studio. An ordinary Windows command prompt, or a Bash prompt, does not have the necessary environment variables set.</p>\n</blockquote>\n<p>如果有 Visual Studio，直接用 Visual Studio 就好啦，為了要寫個小程式還要特定安裝大型 IDE，好像有點誇張。而且 Visual Studio 不是跨平台，跟我的訴求不合。找了一陣子後，決定採用 CodeLite。</p>\n<p>反倒後面安裝執行沒問題。人生就是這樣，做決定最困難。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"http://mingw.org/\">MinGW</a></li>\n<li><a href=\"https://codelite.org/\">CodeLite</a></li>\n</ul>\n",
      "date_published": "2019-12-30T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2019/use-feedly-to-subscribe-facebooks-group/",
      "url": "https://blog.kenwsc.com/posts/2019/use-feedly-to-subscribe-facebooks-group/",
      "title": "訂閱 Facebook Group 的訊息：自建 RSS 伺服器",
      "content_html": "<p>feedly 是一款 Web RSS 訂閱服務，自從 Google Reader 2013 年停止服務後，我就一直使用它，但隨著社群媒體像 Facebook 或 Twitter 流行，訊息的樣貌也改變很多，最痛苦的就是在 Facebook 跟人互動，結果這些訊息都要透過 Facebook 動態來 Follow，等同於變相洗版，何況 Facebook 有自己的演算法，會篩掉它認為你沒興趣的訊息。</p>\n<p>這幾天被 Facebook 洗版洗到受不了，外加漏掉一則重要訊息，終於忍無可忍決定找一個新的訂閱方式，但偏偏 Facebook 本身不提供 RSS 訂閱服務，只好土法煉鋼，自己想辦法。</p>\n<p>本文會用 tweeper + GCP + feedly 來完成對 Facebook 公開頁面的訂閱。讓這些消息能更好地被管理。</p>\n<h2 id=\"fetch-rss\"><a class=\"direct-link\" href=\"#fetch-rss\">#</a> Fetch RSS</h2>\n<p>要訂閱消息，就要有消息來源，我們用 tweeper 來抓取 Facebook 並轉換成 RSS，這是一款 Linux 工具，首先安裝</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> tweeper</code></pre>\n<p>使用方式非常簡單，在後面跟著 Facebook 的公開頁面</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">tweeper https://www.facebook.com/groups/cloudnative.tw/</code></pre>\n<p>然後在 stdout 中，就能看到抓取的資料</p>\n<pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token prolog\">&lt;?xml version=\"1.0\"?></span><br><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>rss</span> <span class=\"token attr-name\">version</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>2.0<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\"><span class=\"token namespace\">xml:</span>base</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://facebook.com<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><br>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>channel</span><span class=\"token punctuation\">></span></span><br>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>generator</span><span class=\"token punctuation\">></span></span>Tweeper<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>generator</span><span class=\"token punctuation\">></span></span><br>    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>title</span><span class=\"token punctuation\">></span></span>Biz<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>title</span><span class=\"token punctuation\">></span></span><br>...</code></pre>\n<p>RSS 使用 XML 格式來發佈消息，這個消息文件稱為 RSS feed。RSS Reader 就是抓取這些 feeds 的 URL 來訂閱。</p>\n<h2 id=\"install-apache\"><a class=\"direct-link\" href=\"#install-apache\">#</a> Install Apache</h2>\n<p>抓取下來的 feed 要給外網存取，因此需要有個網頁伺服器，我們使用最常見的 apache</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> apache2</code></pre>\n<p>安裝好後，apache 會用 80 port 提供 HTTP 服務，相關的文檔放在</p>\n<pre><code>/var/www/\n</code></pre>\n<p>在瀏覽器中輸入對應 IP，可以看到 apache 的畫面</p>\n<p><img src=\"/img/posts/2019/use-feedly-to-subscribe-facebooks-group/feedly-1.png\" alt=\"\"></p>\n<p>當現在有一份文件需要對外提供時，可以放到 /var/www 中，外部就能得到這份文件。</p>\n<h2 id=\"register-a-domain-name\"><a class=\"direct-link\" href=\"#register-a-domain-name\">#</a> Register a Domain Name</h2>\n<p>因為資安考量，我們不希望將內網曝露到外網中，想在外部架設新的 Server 來提供服務，為了方便 RSS Reader 能找到 Server Address，還需要有個 Domain Name，也就是平常說的網址，這個網址能對應到自行架設的 Server Address。Domain Name 可以向供應商購買，像 Google Domains 就有提供這個服務，價格是 20$/Year</p>\n<p><img src=\"/img/posts/2019/use-feedly-to-subscribe-facebooks-group/feedly-2.png\" alt=\"\"></p>\n<p>但我們先用免費的 Domain 來測試，交大有無償提供這項服務</p>\n<p><img src=\"/img/posts/2019/use-feedly-to-subscribe-facebooks-group/feedly-3.png\" alt=\"\"></p>\n<p>註冊並登入後，在網域管理的標籤下，可以新增子網域，輸入自定義的網域名稱</p>\n<p><img src=\"/img/posts/2019/use-feedly-to-subscribe-facebooks-group/feedly-4.png\" alt=\"\"></p>\n<p>並在 DNS 管理中新增紀錄，輸入名稱與 IP，即可完成申請。如果已經有 GCP 的，可以在 IP 填入 GCP 的 External Address，如果還沒有，先進行下一步，取得 GCP 的 IP。</p>\n<h2 id=\"set-gcp\"><a class=\"direct-link\" href=\"#set-gcp\">#</a> Set GCP</h2>\n<p>申請好網域後，就是要架 Server 了。外部 Server 可以用 GCP 架設，具體流程是進入 GCP，開好 VM，安裝需要的軟體，如果不知道怎麼使用 GCP，可以參考<a href=\"https://blog.kenwsc.com/posts/2019/coding-by-your-smartphone/\">前面的文章</a>，GCP 也有提供 apache 的<a href=\"https://cloud.google.com/compute/docs/tutorials/basic-webserver-apache?hl=zh-tw\">安裝說明</a></p>\n<p><img src=\"/img/posts/2019/use-feedly-to-subscribe-facebooks-group/feedly-5.png\" alt=\"\"></p>\n<p>開通 VM 時，要記得將 Firewalls 的 Allow HTTP traffic、Allow HTTPS traffic 兩項打勾，GCP 才能提供 HTTP 跟 HTTPS 的服務。</p>\n<p>VM 設完來建立工作目錄。在家目錄底下建一個 rssfeed 資料夾，將輸出的 RSS feed 放到這個資料夾中。接著到 /var/www/html 下創建一個連結到 rssfeed，這樣一來，即使沒有管理者權限，也能在家目錄下管理檔案</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">mkdir</span> rssfeed <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">cd</span> rssfeed<br>tweeper https://www.facebook.com/groups/cloudnative.tw <span class=\"token operator\">></span> cloudnative.tw.xml<br><span class=\"token builtin class-name\">cd</span> /var/www/html<br><span class=\"token function\">sudo</span> <span class=\"token function\">ln</span> -s ~/rssfeed ./rssfeed</code></pre>\n<p>完成後還要修改網路設定，到網路服務點選 Cloud DNS</p>\n<p><img src=\"/img/posts/2019/use-feedly-to-subscribe-facebooks-group/feedly-6.png\" alt=\"\"></p>\n<p>建立區域，將 DNS 名稱，就是前面步驟申請的網域名填入</p>\n<p><img src=\"/img/posts/2019/use-feedly-to-subscribe-facebooks-group/feedly-7.png\" alt=\"\"></p>\n<p>外部就可以用 URL 來使用 GCP 的服務了。</p>\n<h2 id=\"subscribe-rss\"><a class=\"direct-link\" href=\"#subscribe-rss\">#</a> Subscribe RSS</h2>\n<p>現在用 feedly 訂閱剛剛製作完成的 RSS feed，打開 feedly，點選側欄的「+」號，進入探索頁面</p>\n<p><img src=\"/img/posts/2019/use-feedly-to-subscribe-facebooks-group/feedly-8.png\" alt=\"\"></p>\n<p>在搜尋欄中填入 RSS 的網路位置，例如</p>\n<pre><code>http://example.nctu.me/rssfeed/cloudnative.tw.xml\n</code></pre>\n<p>就能在 FEEDS 的訂閱項目中看到訊息啦</p>\n<p><img src=\"/img/posts/2019/use-feedly-to-subscribe-facebooks-group/feedly-9.png\" alt=\"\"></p>\n<p>是不是很有成就感！</p>\n<h2 id=\"update-rss-periodically\"><a class=\"direct-link\" href=\"#update-rss-periodically\">#</a> Update RSS Periodically</h2>\n<p>雖然能用 feedly 訂閱 RSS 了，但 RSS 需要定期更新，feedly 才有最新的資料能抓。我們這邊利用 Linux 的自動執行程序 cron 來做這件事。</p>\n<p>先將執行的指令寫成腳本，打開 GCP 的 VM，輸入</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">mkdir</span> cronscript <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">cd</span> cronscript<br><span class=\"token function\">vi</span> update_fb_group.sh</code></pre>\n<p>內容是</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">tweeper https://www.facebook.com/groups/cloudnative.tw <span class=\"token operator\">></span> ~/rssfeed/cloudnative.tw.xml</code></pre>\n<p>然後要讓 VM 能依照排程，自動執行這支腳本，因此需要使用 cron</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">crontab</span> -e</code></pre>\n<p>打開 crontab 後有範例，依照設定定期執行的時間後，就會定期執行預設的腳本</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># m h  dom mon dow   command</span><br><span class=\"token number\">0</span> */1 * * * /home/ken/cronscript/update_fb_group.sh</code></pre>\n<p>第一行的 0 表示 0 分時執行，第二行的 */1 表示每小時執行，最後的 command 表示需要執行的指令。</p>\n<p>如此一來，服務架設完成，我們有正式的 RSS feeds 了。</p>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>讓我們來看看 feedly 抓資料的速度</p>\n<p><img src=\"/img/posts/2019/use-feedly-to-subscribe-facebooks-group/feedly-10.png\" alt=\"\"></p>\n<p>該筆資料在 2019/12/07 14:58:24 發表，到 2019/12/08 11:17:51 時抓進 feedly，需要快一天，呃，好慢。因為我們的 cron 是每小時更新，速度慢純粹是 feedly 的問題了，依照 feedly 官方的說法，fetcher 是一小時左右抓取一次，可能它有自己的演算法，會再根據每個 feed 的活躍度修改抓取頻率？</p>\n<p>且不管速度，至少這樣一來，我們能方便管理訊息了。我統計過，自己一天在 FB 的訊息量大約是 20+，有 feedly 能協助管理訊息後，Facebook 終於可以回歸到乾淨的版面了。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"https://cloud.google.com/compute/docs/tutorials/basic-webserver-apache?hl=zh-tw\">Google Cloud 執行基本 Apache 網路伺服器</a></li>\n<li><a href=\"https://medium.com/@ken00535/coding-by-your-smartphone-4dee8438462f\">Coding by Your Smartphone</a></li>\n<li><a href=\"https://nctu.me/\">NCTU.me Domain Hosting</a></li>\n<li><a href=\"http://manpages.ubuntu.com/manpages/bionic/man1/tweeper.1.html\">Tweeper</a></li>\n<li><a href=\"https://feedly.com/\">feedly</a></li>\n</ul>\n",
      "date_published": "2019-12-08T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2019/send-gmail-with-python/",
      "url": "https://blog.kenwsc.com/posts/2019/send-gmail-with-python/",
      "title": "從零開始的 SMTP：以 Python 為例",
      "content_html": "<p>這陣子在重溫 SMTP，想說拿 Gmail 來測試，看看能不能從底層刻出一個簡單的 SMTP Client。沒有其他目的，本文會使用 Python 當範例，一步步實現 SMTP 協議。</p>\n<h2 id=\"set-gmail\"><a class=\"direct-link\" href=\"#set-gmail\">#</a> Set Gmail</h2>\n<p>既然是用 Gmail，就要先把 Gmail 設定好。因為安全性的因素，Gmail 會管控部分應用程式，不讓它們登入，很不幸的，我們自己寫的 Python Script 就是所謂的低安全性應用程式。因此在測試前請先到 Google <a href=\"https://myaccount.google.com/lesssecureapps\">設定頁面</a>中開啟「允許低安全性應用程式」，測試完後再改回去。</p>\n<p><img src=\"/img/posts/2019/send-gmail-with-python/gmail-1.png\" alt=\"\"></p>\n<h2 id=\"create-a-ssl-socket\"><a class=\"direct-link\" href=\"#create-a-ssl-socket\">#</a> Create a SSL Socket</h2>\n<p>在寫 Code 前，要先知道 Server 的位置跟 Port，參考 Gmail 頁面的說明</p>\n<p><img src=\"/img/posts/2019/send-gmail-with-python/gmail-2.png\" alt=\"\"></p>\n<p>知道 SMTP 的 Server 是 <a href=\"http://smtp.gmail.com\">smtp.gmail.com</a>，SSL port 是 465。</p>\n<p>創建一個 Socket，用來發送 SMTP</p>\n<pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">from</span> socket <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span><br><span class=\"token keyword\">import</span> ssl<br><span class=\"token keyword\">import</span> smtplib<br><span class=\"token keyword\">import</span> base64<br><br>mailserver <span class=\"token operator\">=</span> <span class=\"token string\">\"smtp.gmail.com\"</span><br>mailport <span class=\"token operator\">=</span> <span class=\"token number\">465</span><br><br>context <span class=\"token operator\">=</span> ssl<span class=\"token punctuation\">.</span>create_default_context<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><br>clientSocket <span class=\"token operator\">=</span> socket<span class=\"token punctuation\">(</span>AF_INET<span class=\"token punctuation\">,</span> SOCK_STREAM<span class=\"token punctuation\">)</span><br>clientSocket<span class=\"token punctuation\">.</span>connect<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>mailserver<span class=\"token punctuation\">,</span> mailport<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><br>clientSocket <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span>wrap_socket<span class=\"token punctuation\">(</span>clientSocket<span class=\"token punctuation\">,</span> server_hostname<span class=\"token operator\">=</span>mailserver<span class=\"token punctuation\">)</span></code></pre>\n<p>ssl 是用來加密，如果沒有加密，等於將自己的機密資訊暴露在網路上，現在比較正式的應用都會要求加密。如果沒有用 ssl 就要使用 tls，否則無法連線。</p>\n<p>執行 connect 後，host 會跟 server 握手，雙方的連線就完成了。</p>\n<h2 id=\"hello-and-login\"><a class=\"direct-link\" href=\"#hello-and-login\">#</a> Hello and Login</h2>\n<p>SMTP 的 Command 可以參照 <a href=\"https://tools.ietf.org/html/rfc821\">RFC 821</a>，連線相關的指令是 HELO 跟 AUTH LOGIN，前者用來通知身分，後者用來登入，記得要用 \\r\\n 結尾</p>\n<pre class=\"language-py\"><code class=\"language-py\">recv <span class=\"token operator\">=</span> clientSocket<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>recv<span class=\"token punctuation\">)</span><br><span class=\"token keyword\">if</span> recv<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token string\">'220'</span><span class=\"token punctuation\">:</span><br>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"220 reply not received from server.\"</span><span class=\"token punctuation\">)</span><br><br>heloCommand <span class=\"token operator\">=</span> <span class=\"token string\">'HELO Ken\\r\\n'</span><span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>clientSocket<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>heloCommand<span class=\"token punctuation\">)</span><br>recv1 <span class=\"token operator\">=</span> clientSocket<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>recv1<span class=\"token punctuation\">)</span><br><span class=\"token keyword\">if</span> recv1<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token string\">'250'</span><span class=\"token punctuation\">:</span><br>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'250 reply not received from server.'</span><span class=\"token punctuation\">)</span><br><br>heloCommand <span class=\"token operator\">=</span> <span class=\"token string\">'AUTH LOGIN\\r\\n'</span><span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>clientSocket<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>heloCommand<span class=\"token punctuation\">)</span><br>recv1 <span class=\"token operator\">=</span> clientSocket<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>recv1<span class=\"token punctuation\">)</span></code></pre>\n<p>如果前面的操作都順利，應該會收到 server 的回覆</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token number\">220</span> smtp.gmail.com ESMTP d6sm6677367pju.8 - gsmtp<br><span class=\"token number\">250</span> smtp.gmail.com at your <span class=\"token function\">service</span><br><span class=\"token number\">334</span> VXNlcm5hbWU6</code></pre>\n<p>後面 334 是等待客戶端輸入，VXNlcm5hbWU6 是經過 base64 編碼後的 username:，簡單講，Gmail 在等登入資訊。</p>\n<p>同樣將登入的帳號密碼編碼後傳送給 Gmail</p>\n<pre class=\"language-py\"><code class=\"language-py\">clientSocket<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>base64<span class=\"token punctuation\">.</span>b64encode<span class=\"token punctuation\">(</span><span class=\"token string\">\"account\"</span><span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><br>clientSocket<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span><span class=\"token string\">\"\\r\\n\"</span><span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><br>recv1 <span class=\"token operator\">=</span> clientSocket<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>recv1<span class=\"token punctuation\">)</span><br>clientSocket<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>base64<span class=\"token punctuation\">.</span>b64encode<span class=\"token punctuation\">(</span><span class=\"token string\">\"password\"</span><span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><br>clientSocket<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span><span class=\"token string\">\"\\r\\n\"</span><span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><br>recv1 <span class=\"token operator\">=</span> clientSocket<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>recv1<span class=\"token punctuation\">)</span></code></pre>\n<p>得到回應</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token number\">334</span> UGFzc3dvcmQ6<br><span class=\"token number\">235</span> <span class=\"token number\">2.7</span>.0 Accepted</code></pre>\n<p>看到 Accepted 代表登入成功。</p>\n<h2 id=\"send-mail\"><a class=\"direct-link\" href=\"#send-mail\">#</a> Send Mail</h2>\n<p>到這裡就可以開始寫信了，使用 MAIL FROM: 標明寄件人，使用 RCPT TO: 標明收件人</p>\n<pre class=\"language-py\"><code class=\"language-py\">mailCommand <span class=\"token operator\">=</span> <span class=\"token string\">\"MAIL FROM: &lt;sender[@gmail.com](mailto:ken00535@gmail.com)>\\r\\n\"</span><span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>clientSocket<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>mailCommand<span class=\"token punctuation\">)</span><br>recv1 <span class=\"token operator\">=</span> clientSocket<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>recv1<span class=\"token punctuation\">)</span><br><span class=\"token keyword\">if</span> recv1<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token string\">'250'</span><span class=\"token punctuation\">:</span><br>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'250 reply not received from server.'</span><span class=\"token punctuation\">)</span><br><br>mailCommand <span class=\"token operator\">=</span> <span class=\"token string\">\"RCPT TO: &lt;[receiver@gmail.com](mailto:ken00535@gmail.com)>\\r\\n\"</span><span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>clientSocket<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>mailCommand<span class=\"token punctuation\">)</span><br>recv1 <span class=\"token operator\">=</span> clientSocket<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>recv1<span class=\"token punctuation\">)</span><br><span class=\"token keyword\">if</span> recv1<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token string\">'250'</span><span class=\"token punctuation\">:</span><br>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'250 reply not received from server.'</span><span class=\"token punctuation\">)</span></code></pre>\n<p>寄件人跟收件人填自己的帳號。</p>\n<p>接著用 DATA 表示信件內容</p>\n<pre class=\"language-py\"><code class=\"language-py\">dataCommand <span class=\"token operator\">=</span> <span class=\"token string\">'DATA\\r\\n'</span><span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>dataCommand<span class=\"token punctuation\">)</span><br>clientSocket<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>dataCommand<span class=\"token punctuation\">)</span><br>recv1 <span class=\"token operator\">=</span> clientSocket<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>recv1<span class=\"token punctuation\">)</span><br><span class=\"token keyword\">if</span> recv1<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token string\">'354'</span><span class=\"token punctuation\">:</span><br>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data 354 reply not received from server.'</span><span class=\"token punctuation\">)</span></code></pre>\n<p>收到</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token number\">354</span>  Go ahead d6sm6677367pju.8 - gsmtp</code></pre>\n<p>表示 Server 等著接收信件內容，這時可以填入正文。正文結尾要用 .\\r\\n</p>\n<pre class=\"language-py\"><code class=\"language-py\">message <span class=\"token operator\">=</span> <span class=\"token string\">'Hello, world\\r\\n.\\r\\n'</span><br>clientSocket<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><br>recv1 <span class=\"token operator\">=</span> clientSocket<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>recv1<span class=\"token punctuation\">)</span><br><span class=\"token keyword\">if</span> recv1<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token string\">'250'</span><span class=\"token punctuation\">:</span><br>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'end msg 250 reply not received from server.'</span><span class=\"token punctuation\">)</span></code></pre>\n<p>Gmail Server 就會幫忙寄出這封 SMTP 報文。</p>\n<h2 id=\"quit\"><a class=\"direct-link\" href=\"#quit\">#</a> Quit</h2>\n<p>完成後，不要忘記結束跟 Server 的連線，使用 QUIT</p>\n<pre class=\"language-py\"><code class=\"language-py\">quitCommand <span class=\"token operator\">=</span> <span class=\"token string\">'QUIT\\r\\n'</span><span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>clientSocket<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span>quitCommand<span class=\"token punctuation\">)</span><br>recv1 <span class=\"token operator\">=</span> clientSocket<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>recv1<span class=\"token punctuation\">)</span><br><span class=\"token keyword\">if</span> recv1<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> <span class=\"token string\">'221'</span><span class=\"token punctuation\">:</span><br>    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'quit 221 reply not received from server.'</span><span class=\"token punctuation\">)</span></code></pre>\n<p>打開 Gmail，看看成果</p>\n<p><img src=\"/img/posts/2019/send-gmail-with-python/gmail-3.png\" alt=\"\"></p>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>簡單用 Python 跑一次 SMTP 的流程，其實就是不斷寫進各種指令，看看會吐什麼出來，好像有點造輪子的感覺？這類基礎打磨好，對熟悉網路通訊協議很有幫助。如果只是要寫應用，Python 有提供 smtplib，可以 call method 直接搞定。或者不一定要用 Python，直接用 telnet 跟 Server 連線也是個方式。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"http://yhhuang1966.blogspot.com/2018/10/python-gmail.html\">Python 學習筆記 : 以 Gmail 寄送郵件的方法 (一)</a></li>\n<li><a href=\"https://support.google.com/mail/answer/7126229?hl=zh-Hant\">Gmail 說明</a></li>\n<li><a href=\"https://tools.ietf.org/html/rfc821\">RFC 821</a></li>\n</ul>\n",
      "date_published": "2019-12-06T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2019/use-grafana-to-show-prometheus-data/",
      "url": "https://blog.kenwsc.com/posts/2019/use-grafana-to-show-prometheus-data/",
      "title": "監控節點的度量指標：Grafana 串接 Prometheus",
      "content_html": "<p>在<a href=\"https://blog.kenwsc.com/posts/2019/use-prometheus-to-monitor-end-devices/\">前面的討論</a>中，我們可以用 Prometheus 去監控 End Devices，但 Prometheus 內建的 Dashboard 只是為了開發用，缺乏許多進階功能，在真正需要資料視覺化時並不方便。因此 Prometheus 通常會跟 Grafana 搭配使用。</p>\n<p>Grafana 是一套開源的 Dashboard 平台，之前開發產品時，有用過 Grafana 來呈現 Database 中的資料。其實用起來還是偏 Monitor Host，並不適合用在 Domain Data Visualization，但在開發初期，我們可以先借用 Grafana 的呈現能力來確認方向（反正開發初期規格會一直修改，重要的是工具能否快速調整，實不實用倒是其次）。</p>\n<h2 id=\"install-grafana\"><a class=\"direct-link\" href=\"#install-grafana\">#</a> Install Grafana</h2>\n<p>跟 Prometheus 一樣，用 docker 來安裝</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">docker run -p <span class=\"token number\">3000</span>:3000 --user root --name grafana -v <span class=\"token string\">\"<span class=\"token environment constant\">$PWD</span>\"</span>/docker/grafana:/var/lib/grafana grafana/grafana <span class=\"token operator\">&amp;</span></code></pre>\n<p>用 -p 將 port forward 到 3000；用 -v 將 grafana 內的資料 bind 到家目錄的資料夾。</p>\n<p>安裝完成後，在瀏覽器輸入 URL，應該能看到登入畫面</p>\n<p><img src=\"/img/posts/2019/use-grafana-to-show-prometheus-data/grafana-1.png\" alt=\"\"></p>\n<h2 id=\"setup-data-source\"><a class=\"direct-link\" href=\"#setup-data-source\">#</a> Setup Data Source</h2>\n<p>輸入預設的帳號密碼 admin:admin 後登入</p>\n<p><img src=\"/img/posts/2019/use-grafana-to-show-prometheus-data/grafana-2.png\" alt=\"\"></p>\n<p>需要在 Grafana 中加入 Data source，Grafana 才知道要去哪裡抓資料，點選 Add data source 的圖示</p>\n<p><img src=\"/img/posts/2019/use-grafana-to-show-prometheus-data/grafana-3.png\" alt=\"\"></p>\n<p>第一個就是 Prometheus，不用猶豫，點下去</p>\n<p><img src=\"/img/posts/2019/use-grafana-to-show-prometheus-data/grafana-4.png\" alt=\"\"></p>\n<p>在 URL 中輸入 Promethues 的 URL，port 沒改的話就是 9090。儲存並測試。</p>\n<h2 id=\"create-dashboard\"><a class=\"direct-link\" href=\"#create-dashboard\">#</a> Create Dashboard</h2>\n<p>有了資料來源後，要緊接著加入 Dashboard，Grafana 有提供 Prometheus 的範例 Dashboard，我們來看看</p>\n<p><img src=\"/img/posts/2019/use-grafana-to-show-prometheus-data/grafana-5.png\" alt=\"\"></p>\n<p>點選上方的 Dashboards 分頁，加入預設的 Dashboard</p>\n<p><img src=\"/img/posts/2019/use-grafana-to-show-prometheus-data/grafana-6.png\" alt=\"\"></p>\n<p>華麗的 Dashboard 就跑出來了！是不是很簡單！雖然這張表的數據不是我們要的，但光看就是很威啊。</p>\n<h2 id=\"add-panel\"><a class=\"direct-link\" href=\"#add-panel\">#</a> Add Panel</h2>\n<p>有了範例後，參照 Grafana 的說明慢慢手動調整各個 Panel，就能調出想要的效果啦。假設今天想 Monitor end devices 的 CPU usage，我們可以加入一個新的 Panel</p>\n<p><img src=\"/img/posts/2019/use-grafana-to-show-prometheus-data/grafana-7.png\" alt=\"\"></p>\n<p>用 Add Query 加入查詢式</p>\n<p><img src=\"/img/posts/2019/use-grafana-to-show-prometheus-data/grafana-8.png\" alt=\"\"></p>\n<p>查詢式用的是 Prometheus 的查詢語言 PromQL，照樣輸入</p>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token number\">100</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>avg <span class=\"token keyword\">by</span> <span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>irate<span class=\"token punctuation\">(</span>node_cpu_seconds_total{job<span class=\"token operator\">=</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">mode</span><span class=\"token operator\">=</span><span class=\"token string\">\"idle\"</span>}<span class=\"token punctuation\">[</span><span class=\"token number\">5</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span></code></pre>\n<p><img src=\"/img/posts/2019/use-grafana-to-show-prometheus-data/grafana-9.png\" alt=\"\"></p>\n<p>查詢結果就自動變成圖表了。</p>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>以 Dashboard 來講，Grafana 真的很強大，呈現的樣式多，查詢語言容易上手，但是 Grafana 不適合用來進行資料處理，如果需要呈現處理後的資料，而查詢語言本身又沒有相關的聚合指令的話，記得先處理完後再丟進 Database，或者在 Database 跟 Grafana 中間加入一個中間層，不要用 Grafana 硬幹。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"https://blog.techbridge.cc/2019/08/26/how-to-use-prometheus-grafana-in-flask-app/\">使用 Prometheus 和 Grafana 打造 Flask Web App 監控預警系統</a></li>\n<li><a href=\"https://grafana.com/\">Grafana Labs</a></li>\n</ul>\n",
      "date_published": "2019-11-30T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2019/use-commitizen-to-write-graceful-git-comment/",
      "url": "https://blog.kenwsc.com/posts/2019/use-commitizen-to-write-graceful-git-comment/",
      "title": "輕鬆上手約定式提交：Commitizen 初體驗",
      "content_html": "<p>最近參加 <a href=\"https://www.facebook.com/DevOpsTaiwan/?__xts__%5B0%5D=68.ARDEgwToQAGuv9hG3_bq6XWyLfuKwC8UtMvzV5WLsG4UpdFV7OX5T7j3D5mDFIFc-g4fw6AmpuWS6Q2lXlGOX63ewQsP-Zr28ToevHy_ys6mbYIQw_XhaPLa9vdayvCkwV0GiPgJ0ex-m3cPNb0BEO4O-psJC4pcRo4QwsG10-DYNJW9TVMZp6fUQk7vJwiYvSYwwKUEfySzN7acg1qnTyTqq9gfhp6PH4T_wyR_qcA5sjwkmHklTSZs5tYXRJv_hS7p72UmGZc9AGktwZ3HKiuCxdmc3fVK2l9lRASxzyPAC4qWVPEYRF7eScGeOprzdFkfnkbmkoCKqappUDmFhHrXq5ONVNSXCXC_ltxFT-TWwPyFeLJk5o0Cqe0&amp;__xts__%5B1%5D=68.ARAcpv3SzZ6EJSKKfcow3owDtiyMig-u6PbVyaWDvjd8xNckpS8mKdrSgY8LjHquhuMgtjC9T36r5IdZkW79QMhDBVs-dFX-ejRugNm4slqIlj7Z0NFmlSotqiDtbmRivf8CPNkFGHvms-BdA1925rc4Qss3OXhWVaAF53i2MtAqTdC4NwOdN0RbjRT2loQHnkLFnSqk-QU-YDNG&amp;__tn__=K-R&amp;eid=ARAGF0O3M8GMJQ8AvevMsEgZ1JRpx_HAz-w9szWyv3wn99ZFociIgks68rbjUVVQoBUFPAtPcnDLvKR9&amp;fref=mentions\">DevOps Meetup</a> 的活動，Speaker 提到團隊使用 Commitizen 這套工具來統一提交訊息的風格，當場就有種醍醐灌頂的感覺。我們團隊前陣子才 Suffer 在 Commit Style 分歧，知識管理效率低落，有時只有 commit 本人能看懂，而使用共同模板又太浪費時間，跟 Git 鼓勵 commit 的精神背道而馳。聽完後，真的是相見恨晚，完全命中我的痛點。</p>\n<p>Commitizen 是由 AngularJS 的規範衍伸而來，各團隊可以依照需求自行調整，我們 Step by Step 來看看 Commitizen 的效果如何。</p>\n<h2 id=\"install-node.js\"><a class=\"direct-link\" href=\"#install-node.js\">#</a> Install Node.js</h2>\n<p>因為 Commitizen 是使用 Node.js 開發，不免俗的，要裝一下 Node.js，Ubuntu 的安裝方式是</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> nodejs<br><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> <span class=\"token function\">npm</span></code></pre>\n<p>確認是否有安裝完成</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken@ken-Lenovo-ideapad-330-15ICH:~/git/git$ node -v<br>v8.10.0<br>ken@ken-Lenovo-ideapad-330-15ICH:~/git/git$ <span class=\"token function\">npm</span> -v<br><span class=\"token number\">3.5</span>.2</code></pre>\n<h2 id=\"install-commitizen\"><a class=\"direct-link\" href=\"#install-commitizen\">#</a> Install Commitizen</h2>\n<p>接著使用 Node.js 的 Package Management 工具 npm 來安裝 Commitizen</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> -g commitizen<br><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'{ \"path\": \"cz-conventional-changelog\" }'</span> <span class=\"token operator\">></span> ~/.czrc</code></pre>\n<p>-g 是全域安裝的意思，如果沒有需要針對 Project 制定 Style，用全域安裝即可，.czrc 則是用來設定 template 的路徑。</p>\n<h2 id=\"git-format\"><a class=\"direct-link\" href=\"#git-format\">#</a> Git Format</h2>\n<p>在預設的 format 中，commit comment 由三個部分組成</p>\n<pre><code>&lt;head&gt;\n&lt;body&gt;\n&lt;footer&gt;\n</code></pre>\n<p>讓我們看一個簡單的例子</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">commit 4030e040b6044de68b2750702a5b6065c887960c<br>Author: kenwschen <span class=\"token operator\">&lt;</span>ken*****@<span class=\"token punctuation\">[</span>gmail.com<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>mailto:ken00535@gmail.com<span class=\"token punctuation\">)</span><span class=\"token operator\">></span><br>Date:   Thu Nov <span class=\"token number\">28</span> <span class=\"token number\">22</span>:51:44 <span class=\"token number\">2019</span> +0800<br><br>feat<span class=\"token punctuation\">(</span>libhello<span class=\"token punctuation\">)</span>: <span class=\"token function\">add</span> hello <span class=\"token function\">file</span><br><br>hello, this is a longer description<br><br>fix <span class=\"token comment\">#100</span></code></pre>\n<p>第一行是 head，也就是 title，通常會由</p>\n<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n</code></pre>\n<p>在本例中可以看成這個 commit 為新增功能(feature)，更改的 module 是 libhello，簡單描述是 add hello file。</p>\n<p>中間行是 body，代表詳細的描述，通常會說明要解決的問題是什麼，具體做法是什麼等等。</p>\n<p>最後一行是 footer，通常會標明相關的 issue，如果沒有將 issue 跟 git 結合在一起的話，footer 可以不標。</p>\n<h2 id=\"git-cz\"><a class=\"direct-link\" href=\"#git-cz\">#</a> Git cz</h2>\n<p>實際執行 Commitizen，使用 git cz 來取代 git commit</p>\n<p><img src=\"/img/posts/2019/use-commitizen-to-write-graceful-git-comment/commitizen-1.png\" alt=\"\"></p>\n<p>可以看到，Commitizen 會很貼心顯示選單讓 user 選擇，只要照著問題跟選單將答案填入就好，就是這麼簡單。</p>\n<p>來看一下提交的結果</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken@ken-Lenovo-ideapad-330-15ICH:~/git$ <span class=\"token builtin class-name\">echo</span> hello <span class=\"token operator\">></span> hello     <br>ken@ken-Lenovo-ideapad-330-15ICH:~/git$ <span class=\"token function\">git</span> <span class=\"token function\">add</span> <span class=\"token builtin class-name\">.</span>              <br>ken@ken-Lenovo-ideapad-330-15ICH:~/git$ <span class=\"token function\">git</span> cz                 <br>cz-cli@4.0.3, cz-conventional-changelog@3.0.1                  <br>                                                                <br>? Select the <span class=\"token builtin class-name\">type</span> of change that you're committing: feat:        A new feature                                                     <br>? What is the scope of this change <span class=\"token punctuation\">(</span>e.g. component or <span class=\"token function\">file</span> name<span class=\"token punctuation\">)</span>: <span class=\"token punctuation\">(</span>press enter to skip<span class=\"token punctuation\">)</span> libhello                                   <br>? Write a short, imperative tense description of the change <span class=\"token punctuation\">(</span>max <span class=\"token number\">84</span> chars<span class=\"token punctuation\">)</span>:                                                        <br>    <span class=\"token punctuation\">(</span><span class=\"token number\">14</span><span class=\"token punctuation\">)</span> <span class=\"token function\">add</span> hello <span class=\"token function\">file</span>                                               <br>? Provide a longer description of the change: <span class=\"token punctuation\">(</span>press enter to skip<span class=\"token punctuation\">)</span><br>    hello, this is a longer description<br>? Are there any breaking changes? No<br>? Does this change affect any <span class=\"token function\">open</span> issues? No<br><span class=\"token punctuation\">[</span>master 2e1ea38<span class=\"token punctuation\">]</span> feat<span class=\"token punctuation\">(</span>libhello<span class=\"token punctuation\">)</span>: <span class=\"token function\">add</span> hello <span class=\"token function\">file</span><br>    <span class=\"token number\">1</span> <span class=\"token function\">file</span> changed, <span class=\"token number\">1</span> insertion<span class=\"token punctuation\">(</span>+<span class=\"token punctuation\">)</span><br>    create mode <span class=\"token number\">100644</span> hello<br><br>ken@ken-Lenovo-ideapad-330-15ICH:~/git$ <span class=\"token function\">git</span> log<br>commit 2e1ea3868dcf972c2499378ee9d5b3ac7ab654b6 <span class=\"token punctuation\">(</span>HEAD -<span class=\"token operator\">></span> master<span class=\"token punctuation\">)</span><br>Author: kenwschen <span class=\"token operator\">&lt;</span><span class=\"token punctuation\">[</span>ken*****@gmail.com<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>mailto:ken00535@gmail.com<span class=\"token punctuation\">)</span><span class=\"token operator\">></span><br>Date:   Fri Nov <span class=\"token number\">29</span> 00:40:31 <span class=\"token number\">2019</span> +0800<br><br>feat<span class=\"token punctuation\">(</span>libhello<span class=\"token punctuation\">)</span>: <span class=\"token function\">add</span> hello <span class=\"token function\">file</span><br><br>hello, this is a longer description</code></pre>\n<p>是不是太美了！</p>\n<h2 id=\"customize-format\"><a class=\"direct-link\" href=\"#customize-format\">#</a> Customize Format</h2>\n<p>如果專案有自訂格式，例如需要標註修改方式、修改目的等等，可以怎麼做？Commitizen 支援許多模板，其中 cz-customizable 有讓 user 自訂選項的彈性，先安裝起來</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">npm</span> <span class=\"token function\">install</span> -g cz-customizable<br><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">'{ \"path\": \"cz-customizable\" }'</span> <span class=\"token operator\">></span> ~/.czrc</code></pre>\n<p>將配置項的範例複製到家目錄</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cp</span> /usr/local/lib/node_modules/cz-customizable/cz-config-EXAMPLE.js ~/.cz-config.js</code></pre>\n<p>打開配置文件，可以看到其中有許多配置設定，假設現在需要新增一個互動問答，讓 user 輸入 commit 的 purpose，可以在其中加入</p>\n<pre class=\"language-js\"><code class=\"language-js\">    messages<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><br>        type<span class=\"token operator\">:</span> <span class=\"token string\">\"Select the type of change that you're committing:\"</span><span class=\"token punctuation\">,</span><br>        scope<span class=\"token operator\">:</span> <span class=\"token string\">'\\nDenote the SCOPE of this change (optional):'</span><span class=\"token punctuation\">,</span><br>        customScope<span class=\"token operator\">:</span> <span class=\"token string\">'Denote the SCOPE of this change:'</span><span class=\"token punctuation\">,</span><br>        subject<span class=\"token operator\">:</span> <span class=\"token string\">'Write a SHORT, IMPERATIVE tense description of the change:\\n'</span><span class=\"token punctuation\">,</span><br>        body<span class=\"token operator\">:</span> <span class=\"token string\">'Provide a LONGER description of the change (optional). Use \"|\" to break new line:\\n'</span><span class=\"token punctuation\">,</span><br>        <span class=\"token operator\">**</span>bodyPurpose<span class=\"token operator\">:</span> <span class=\"token string\">'The purpose of the change:\\n'</span><span class=\"token punctuation\">,</span><span class=\"token operator\">**</span><br>        breaking<span class=\"token operator\">:</span> <span class=\"token string\">'List any BREAKING CHANGES (optional):\\n'</span><span class=\"token punctuation\">,</span><br>        footer<span class=\"token operator\">:</span> <span class=\"token string\">'List any ISSUES CLOSED by this change (optional). E.g.: #31, #34:\\n'</span><span class=\"token punctuation\">,</span><br>        confirmCommit<span class=\"token operator\">:</span> <span class=\"token string\">'Are you sure you want to proceed with the commit above?'</span><span class=\"token punctuation\">,</span><br>      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></code></pre>\n<p>其中 bodyPurpose 這行是新加入的選項。</p>\n<p>接著修改問句文件</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">vi</span> /usr/local/lib/node_modules/cz-customizable/questions.js</code></pre>\n<p>在其中加入 bodyPurpose</p>\n<pre class=\"language-js\"><code class=\"language-js\">    <span class=\"token operator\">...</span><br>    messages<span class=\"token punctuation\">.</span>body <span class=\"token operator\">=</span><br>          messages<span class=\"token punctuation\">.</span>body <span class=\"token operator\">||</span> <span class=\"token string\">'Provide a LONGER description of the change (optional). Use \"|\" to break new line:\\n'</span><span class=\"token punctuation\">;</span><br>        <span class=\"token operator\">**</span>messages<span class=\"token punctuation\">.</span>bodyPurpose <span class=\"token operator\">=</span> messages<span class=\"token punctuation\">.</span>bodyPurpose <span class=\"token operator\">||</span> <span class=\"token string\">'The purpose of the change:\\n'</span><span class=\"token punctuation\">;</span><span class=\"token operator\">**</span><br>        messages<span class=\"token punctuation\">.</span>breaking <span class=\"token operator\">=</span> messages<span class=\"token punctuation\">.</span>breaking <span class=\"token operator\">||</span> <span class=\"token string\">'List any BREAKING CHANGES (optional):\\n'</span><span class=\"token punctuation\">;</span><br>    <span class=\"token operator\">...</span><br><br>    <span class=\"token operator\">...</span><br>          <span class=\"token punctuation\">{</span><br>            type<span class=\"token operator\">:</span> <span class=\"token string\">'input'</span><span class=\"token punctuation\">,</span><br>            name<span class=\"token operator\">:</span> <span class=\"token string\">'body'</span><span class=\"token punctuation\">,</span><br>            message<span class=\"token operator\">:</span> messages<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">,</span><br>          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><br>          <span class=\"token operator\">**</span><span class=\"token punctuation\">{</span><br>            type<span class=\"token operator\">:</span> <span class=\"token string\">'input'</span><span class=\"token punctuation\">,</span><br>            name<span class=\"token operator\">:</span> <span class=\"token string\">'bodyPurpose'</span><span class=\"token punctuation\">,</span><br>            message<span class=\"token operator\">:</span> messages<span class=\"token punctuation\">.</span>bodyPurpose<span class=\"token punctuation\">,</span><br>          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token operator\">**</span><br>    <span class=\"token operator\">...</span></code></pre>\n<p>然後修改 commit 生成文件，將 bodyPurpose 加入</p>\n<pre class=\"language-js\"><code class=\"language-js\">    <span class=\"token keyword\">let</span> body <span class=\"token operator\">=</span> <span class=\"token function\">wrap</span><span class=\"token punctuation\">(</span>answers<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">,</span> wrapOptions<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span><br>    <span class=\"token operator\">**</span>body <span class=\"token operator\">=</span> body <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span><span class=\"token function\">wrap</span><span class=\"token punctuation\">(</span>answers<span class=\"token punctuation\">.</span>bodyPurpose<span class=\"token punctuation\">,</span> wrapOptions<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token operator\">**</span><br>    body <span class=\"token operator\">=</span> <span class=\"token function\">addBreaklinesIfNeeded</span><span class=\"token punctuation\">(</span>body<span class=\"token punctuation\">,</span> config<span class=\"token punctuation\">.</span>breaklineChar<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>現在來看一下修改的成果</p>\n<p><img src=\"/img/posts/2019/use-commitizen-to-write-graceful-git-comment/commitizen-2.png\" alt=\"\"></p>\n<p>而實際的 log 是</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">commit 3cc8c9aa4a9084fb4b8faa651d98b5376f24e4d6 <span class=\"token punctuation\">(</span>HEAD -<span class=\"token operator\">></span> master<span class=\"token punctuation\">)</span><br>Author: kenwschen <span class=\"token operator\">&lt;</span><span class=\"token punctuation\">[</span>kenxxxxx@gmail.com<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>mailto:ken00535@gmail.com<span class=\"token punctuation\">)</span><span class=\"token operator\">></span><br>Date:   Fri Nov <span class=\"token number\">29</span> <span class=\"token number\">19</span>:56:58 <span class=\"token number\">2019</span> +0800<br><br>feat<span class=\"token punctuation\">(</span>libhello<span class=\"token punctuation\">)</span>: <span class=\"token function\">add</span> hello <span class=\"token function\">file</span><br><br><span class=\"token function\">add</span> a new <span class=\"token function\">file</span> to <span class=\"token builtin class-name\">test</span> commitizen tool. hello is a lib that can say <span class=\"token string\">\"hello\"</span></code></pre>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>有時候程式寫一寫，會忘記升級自己的工具，很多時候團隊遇到的問題不是人的問題，而是工具的問題，我們應該要盡量 align 目標，用工具時時提醒出發點在哪。commit comment 原本是為了溝通而存在，而 Commitizen 可以幫我們更好地去做這件事。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"https://github.com/commitizen/cz-cli\">Commitizen GitHub</a></li>\n<li><a href=\"https://github.com/leonardoanalista/cz-customizable\">cz-customizable GitHub</a></li>\n</ul>\n",
      "date_published": "2019-11-29T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2019/use-prometheus-to-monitor-end-devices/",
      "url": "https://blog.kenwsc.com/posts/2019/use-prometheus-to-monitor-end-devices/",
      "title": "監控節點的度量指標：Prometheus 入門",
      "content_html": "<p>Prometheus 是一套開源的監控系統，常常搭配雲端，監控服務運行狀態。今年 COSCUP 有一位 Speaker 將它用於 End-Devices 的監控，看起來非常有意思。透過這套系統，我們能將各處節點的資訊整合於統一的平台，讓 Operation 監控服務，避免服務中斷導致價值鍊中斷，同時這些數據也能提供給 Developer，作為後續改善的依據。</p>\n<p>Prometheus 的基本原理是用 HTTP 定期抓取監控端（target）的資料，target 上會有 exporter，將符合 Prometheus 定義的資訊輸出到 HTTP API，Prometheus 拉取後就能將它顯示於 Dashboard。</p>\n<h2 id=\"install-prometheus\"><a class=\"direct-link\" href=\"#install-prometheus\">#</a> Install Prometheus</h2>\n<p>安裝有兩個方式，可以用 binary 安裝或是用 docker 安裝，為隔離與管理方便，這邊選擇使用 docker 安裝</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">docker run --name prometheus -d -p <span class=\"token number\">9090</span>:9090 quay.io/prometheus/prometheus </code></pre>\n<p>記得將 container port forward 到 host 的 port，讓外面可以使用。</p>\n<p>安裝好後，在瀏覽器輸入 Prometheus server 的 IP，應該可以看到 Prometheus 自帶的 GUI，如下</p>\n<p><img src=\"/img/posts/2019/use-prometheus-to-monitor-end-devices/prom-1.png\" alt=\"\"></p>\n<p>Expression 可以輸入 Prometheus 的查詢 PromQL，Graph 會依照 PromQL 顯示對應的採集資料，這些採集資料稱為 Metric，up 這個 Metric 表示對應的採集實例(instance)狀態，當 up 值為 1，表示 exporter instance 正常運作。</p>\n<h2 id=\"install-node-exporter\"><a class=\"direct-link\" href=\"#install-node-exporter\">#</a> Install Node Exporter</h2>\n<p>當要抓取不同 target 或更詳細的資料時，會需要一套 exporter 將資料收集起來，方便 Prometheus server 拉取。Node Exporter 這個 Project 就是要做這件事。它是用 Go 語言寫成，沒有相依性問題，直接下載後就能執行</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> -OL <span class=\"token punctuation\">[</span>https://github.com/prometheus/node_exporter/releases/download/v0.18.1/node_exporter-0.18.1.linux-amd64.tar.gz<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>https://github.com/prometheus/node_exporter/releases/download/v0.18.1/node_exporter-0.18.1.linux-amd64.tar.gz<span class=\"token punctuation\">)</span><br><span class=\"token function\">tar</span> -xzf node_exporter-0.18.1.linux-amd64.tar.gz<br><span class=\"token function\">cp</span> node_exporter-0.18.1.linux-amd64/node_exporter /usr/local/bin/<br>node_exporter</code></pre>\n<p>下載時請依照自己的作業系統下載對應版本，我們下載 Linux 版後放到安裝目錄，執行</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken@ken-Lenovo-ideapad-330-15ICH:~/git/promethus$ node_exporter<br><br>INFO<span class=\"token punctuation\">[</span>0000<span class=\"token punctuation\">]</span> Starting node_exporter <span class=\"token punctuation\">(</span>version<span class=\"token operator\">=</span><span class=\"token number\">0.18</span>.1, <span class=\"token assign-left variable\">branch</span><span class=\"token operator\">=</span>HEAD, <span class=\"token assign-left variable\">revision</span><span class=\"token operator\">=</span>3db77732e925c08f675d7404a8c46466b2ece83e<span class=\"token punctuation\">)</span>  <span class=\"token assign-left variable\">source</span><span class=\"token operator\">=</span><span class=\"token string\">\"node_exporter.go:156\"</span>                                  <br>INFO<span class=\"token punctuation\">[</span>0000<span class=\"token punctuation\">]</span> Build context <span class=\"token punctuation\">(</span>go<span class=\"token operator\">=</span>go1.12.5, <span class=\"token assign-left variable\">user</span><span class=\"token operator\">=</span>root@b50852a1acba, <span class=\"token assign-left variable\">date</span><span class=\"token operator\">=</span><span class=\"token number\">20190604</span>-16:41:18<span class=\"token punctuation\">)</span>  <span class=\"token assign-left variable\">source</span><span class=\"token operator\">=</span><span class=\"token string\">\"node_exporter.go:157\"</span>              <br>INFO<span class=\"token punctuation\">[</span>0000<span class=\"token punctuation\">]</span> Enabled collectors:                           <span class=\"token assign-left variable\">source</span><span class=\"token operator\">=</span><span class=\"token string\">\"node_exporter.go:97\"</span>                         <br>INFO<span class=\"token punctuation\">[</span>0000<span class=\"token punctuation\">]</span>  - arp                                        <span class=\"token assign-left variable\">source</span><span class=\"token operator\">=</span><span class=\"token string\">\"node_exporter.go:104\"</span>                        <br>INFO<span class=\"token punctuation\">[</span>0000<span class=\"token punctuation\">]</span>  - bcache                                     <span class=\"token assign-left variable\">source</span><span class=\"token operator\">=</span><span class=\"token string\">\"node_exporter.go:104\"</span>                        <br>INFO<span class=\"token punctuation\">[</span>0000<span class=\"token punctuation\">]</span>  - bonding                                    <span class=\"token assign-left variable\">source</span><span class=\"token operator\">=</span><span class=\"token string\">\"node_exporter.go:104\"</span><br><span class=\"token punctuation\">..</span>.</code></pre>\n<p>Node Exporter 預設的 port 是 9100，在瀏覽器上輸入後，可以看到</p>\n<p><img src=\"/img/posts/2019/use-prometheus-to-monitor-end-devices/prom-2.png\" alt=\"\"></p>\n<p>底下的 Metrics 就是採集到的 Metrics，點開來會看到 Node Exporter 有採集的資訊</p>\n<pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token comment\"># HELP go_gc_duration_seconds A summary of the GC invocation durations.</span><br><span class=\"token comment\"># TYPE go_gc_duration_seconds summary</span><br><span class=\"token key attr-name\">go_gc_duration_seconds{quantile</span><span class=\"token punctuation\">=</span><span class=\"token value attr-value\">\"0\"} 1.4124e-05</span><br><span class=\"token key attr-name\">go_gc_duration_seconds{quantile</span><span class=\"token punctuation\">=</span><span class=\"token value attr-value\">\"0.25\"} 3.1017e-05</span><br><span class=\"token key attr-name\">go_gc_duration_seconds{quantile</span><span class=\"token punctuation\">=</span><span class=\"token value attr-value\">\"0.5\"} 0.000118785</span><br><span class=\"token key attr-name\">go_gc_duration_seconds{quantile</span><span class=\"token punctuation\">=</span><span class=\"token value attr-value\">\"0.75\"} 0.000144924</span><br><span class=\"token key attr-name\">go_gc_duration_seconds{quantile</span><span class=\"token punctuation\">=</span><span class=\"token value attr-value\">\"1\"} 0.000173711</span><br>go_gc_duration_seconds_sum 0.000581784<br>go_gc_duration_seconds_count 6<br><span class=\"token comment\"># HELP go_goroutines Number of goroutines that currently exist.</span><br><span class=\"token comment\"># TYPE go_goroutines gauge</span><br>go_goroutines 7<br><span class=\"token comment\"># HELP go_info Information about the Go environment.</span><br><span class=\"token comment\"># TYPE go_info gauge</span><br><span class=\"token key attr-name\">go_info{version</span><span class=\"token punctuation\">=</span><span class=\"token value attr-value\">\"go1.12.5\"} 1</span><br><span class=\"token comment\"># HELP go_memstats_alloc_bytes Number of bytes allocated and still in use.</span><br><span class=\"token comment\"># TYPE go_memstats_alloc_bytes gauge</span><br>go_memstats_alloc_bytes 1.942816e+06<br>...</code></pre>\n<h2 id=\"install-node-exporter-2\"><a class=\"direct-link\" href=\"#install-node-exporter-2\">#</a> Install Node Exporter</h2>\n<p>要將新增的 instance 告知 Prometheus server，讓 server 去拉取，就要去修改 server 的 config 檔，因為我們前面是用 docker 來執行，因此要先進到 container 內。其實更好的辦法應該是讓 container 跟外部的 config 檔同步，但我們先關注在 Prometheus 的操作上</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">docker <span class=\"token builtin class-name\">exec</span> -it prometheus <span class=\"token function\">sh</span></code></pre>\n<p>打開 config file</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> /etc/prometheus/<br><span class=\"token function\">vi</span> prometheus.yml</code></pre>\n<p>在最下面加入新的 Job</p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># A scrape configuration containing exactly one endpoint to scrape:</span><br><span class=\"token comment\"># Here it's Prometheus itself.    </span><br><span class=\"token key atrule\">scrape_configs</span><span class=\"token punctuation\">:</span>     <br>    <span class=\"token comment\"># The job name is added as a label `job=&lt;job_name>` to any timeseries scraped from this config.       </span><br>    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">job_name</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'prometheus'</span>          <br>      <span class=\"token comment\"># metrics_path defaults to '/metrics'  </span><br>      <span class=\"token comment\"># scheme defaults to 'http'.                          </span><br>      <span class=\"token key atrule\">static_configs</span><span class=\"token punctuation\">:</span>             <br>      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">targets</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'localhost:9090'</span><span class=\"token punctuation\">]</span><br>                    <br>    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">job_name</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'node'</span><br>      <span class=\"token key atrule\">static_configs</span><span class=\"token punctuation\">:</span><br>      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">targets</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'172.17.0.1:9100'</span><span class=\"token punctuation\">]</span></code></pre>\n<p>在 Prometheus 的術語中，Job 表示一組任務，任務中可能包括對好幾個 instance 的採集。上面新增一組 Job 稱為 node，對 172.17.0.1:9100 這個 instance 進行採集。</p>\n<p>設定完成後重啟 promethus</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">docker container restart prometheus</code></pre>\n<p>打開瀏覽器的 UI，可以看到出現新的 instance</p>\n<p><img src=\"/img/posts/2019/use-prometheus-to-monitor-end-devices/prom-3.png\" alt=\"\"></p>\n<h2 id=\"query-cpu-usage\"><a class=\"direct-link\" href=\"#query-cpu-usage\">#</a> Query CPU Usage</h2>\n<p>假設我們要查詢 instance 的 CPU 使用率，可以怎麼做？我們可以由 Node Exporter 的說明中，看到 node_cpu_seconds_total 這項 metric 是 cpu 花費在特定模式的秒數。</p>\n<p>於是使用 PromQL 的內建函數 irate(v[time])，來取得數據的在時間區段的瞬間增長率，由於 CPU 在時間區段使用的時間秒數就是 CPU 的使用率，如此一來，就能取得使用率數值。</p>\n<p>最後，使用 PromQL 的聚合操作 avg，來將各 CPU 的數值合併，取其平均，聚合的規則是以各 instance 為聚合單位。</p>\n<p>結合所有查詢式如下</p>\n<pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token number\">100</span> <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>avg <span class=\"token keyword\">by</span> <span class=\"token punctuation\">(</span>instance<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>irate<span class=\"token punctuation\">(</span>node_cpu_seconds_total{job<span class=\"token operator\">=</span><span class=\"token string\">\"node\"</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">mode</span><span class=\"token operator\">=</span><span class=\"token string\">\"idle\"</span>}<span class=\"token punctuation\">[</span><span class=\"token number\">5</span>m<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span></code></pre>\n<p>job 跟 mode 是 metric 的 label，扣掉 idle 所佔的使用率後，剩下的使用率就是 CPU 使用率了，按下執行後，Graph 就跑出來啦</p>\n<p><img src=\"/img/posts/2019/use-prometheus-to-monitor-end-devices/prom-4.png\" alt=\"\"></p>\n<h2 id=\"monitor-pri\"><a class=\"direct-link\" href=\"#monitor-pri\">#</a> Monitor PRi</h2>\n<p>確認主機的資訊能拉取後，如法炮製到 RPi 上，安裝 Node Exporter，Model B 的架構是 armv6</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">pi@raspberrypi:~/prometheus $ <span class=\"token function\">wget</span> <span class=\"token punctuation\">[</span>https://github.com/prometheus/node_exporter/releases/download/v0.18.1/node_exporter-0.18.1.linux<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>https://github.com/prometheus/node_exporter/releases/download/v0.18.1/node_exporter-0.18.1.linux<span class=\"token punctuation\">)</span><br>-armv6.tar.gz<br>pi@raspberrypi:~/prometheus $ <span class=\"token function\">tar</span> -zxvf node_exporter-0.18.1.linux-armv6.tar.gz<br>pi@raspberrypi:~/prometheus $ <span class=\"token builtin class-name\">cd</span> node_exporter-0.18.1.linux-armv6/<br>pi@raspberrypi:~/prometheus/node_exporter-0.18.1.linux-armv6 $ ./node_exporter</code></pre>\n<p>修改 prometheus.yml，加入新的 instance</p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># A scrape configuration containing exactly one endpoint to scrape:</span><br><span class=\"token comment\"># Here it's Prometheus itself.</span><br><span class=\"token key atrule\">scrape_configs</span><span class=\"token punctuation\">:</span><br>  <span class=\"token comment\"># The job name is added as a label `job=&lt;job_name>` to any timeseries scraped from this config.</span><br>  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">job_name</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'prometheus'</span><br>    <span class=\"token comment\"># metrics_path defaults to '/metrics'</span><br>    <span class=\"token comment\"># scheme defaults to 'http'.</span><br>    <span class=\"token key atrule\">static_configs</span><span class=\"token punctuation\">:</span><br>      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">targets</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'localhost:9090'</span><span class=\"token punctuation\">]</span><br>  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">job_name</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'node'</span><br>    <span class=\"token key atrule\">static_configs</span><span class=\"token punctuation\">:</span><br>      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">targets</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'172.17.0.1:9100'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'192.168.5.10:9100'</span><span class=\"token punctuation\">]</span></code></pre>\n<p>刷新頁面，觀察結果</p>\n<p><img src=\"/img/posts/2019/use-prometheus-to-monitor-end-devices/prom-5.png\" alt=\"\"></p>\n<p>RPi 的 CPU 使用率快樂抖動中。</p>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>上張 Prometheus 的架構圖</p>\n<p><img src=\"/img/posts/2019/use-prometheus-to-monitor-end-devices/prom-6.jpg\" alt=\"\"></p>\n<p>Prometheus 整個生態系有許多組件，在這個 Demo 中，用到的是 Prometheus Server、WebUI、Exporter 等架構圖下半部分，其他不同組件也有各自的用途。使用 Prometheus，我們能夠 Monitor 服務運行的狀況，也可以用它來通知異常（在今年的 COSCUP 中，Line 的 Speaker 就用它來觀察會議室中的活動人數，免得有人借了會議室卻不使用）。</p>\n<p>如果你還在尋找維運工具，不妨試試看。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/91215371\">為什麼說 Prometheus 是足以取代 Zabbix 的監控神器？</a></li>\n<li><a href=\"https://songjiayang.gitbooks.io/prometheus/content/\">Prometheus 实战</a></li>\n<li><a href=\"https://www.inwinstack.com/2018/11/14/prometheus-introduction-1/\">Prometheus 介紹與基礎入門 (上)</a></li>\n<li><a href=\"https://yunlzheng.gitbook.io/prometheus-book/\">Prometheus-book</a></li>\n</ul>\n",
      "date_published": "2019-11-28T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2019/use-ansible-to-update-end-devices/",
      "url": "https://blog.kenwsc.com/posts/2019/use-ansible-to-update-end-devices/",
      "title": "配置即代碼：Ansible 入門",
      "content_html": "<p>之前負責產品研發時，常常需要因應客戶需求，更新終端裝置上的應用程式。因為終端裝置在廠區可能一次就是幾十幾百台，如果用手動更新大概當天就不用做事了。Ansible 這類組態管理(Configuration Management)軟體就是為此而生。相對於同類軟體，Ansible 的系統需求單純，只要 Client 端有安裝 Python 即可，很適合資源受限的嵌入式系統。</p>\n<p>這篇會用 Ansible 來模擬簡單的 Python 應用程式更新，看看它如何處理 Deployment 的問題。</p>\n<h2 id=\"install-ansible-and-setup-environment\"><a class=\"direct-link\" href=\"#install-ansible-and-setup-environment\">#</a> Install Ansible and Setup Environment</h2>\n<p>首先在 Server 端安裝 Ansible，如果你使用的是 Ubuntu 的話，只需要執行</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> ansible</code></pre>\n<p>同時，使用一台 Raspberry Pi Model B 來當成終端裝置，沒有 RPi 也可以用 VirtualBox + Vagrant 搭建虛擬機來使用。</p>\n<p><img src=\"/img/posts/2019/use-ansible-to-update-end-devices/rpi3-1.webp\" alt=\"\"></p>\n<p>因為 Ansible 是使用 SSH 進行遠端操作，記得要打開 RPi 上的 SSH</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> raspi-config</code></pre>\n<p><img src=\"/img/posts/2019/use-ansible-to-update-end-devices/rpi3-2.webp\" alt=\"\"></p>\n<p>選擇 Interfacing Options 後，打開 P2 SSH。</p>\n<p>最後要記得確認 RPi 上有 Python</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">python3 --version</code></pre>\n<h2 id=\"setup-host-information\"><a class=\"direct-link\" href=\"#setup-host-information\">#</a> Setup Host Information</h2>\n<p>我們必須告訴 Ansible 要連接的主機是哪些，相關資訊是什麼，這些 Client 端的裝置，在 Ansible 術語中稱為 Inventory。先假設工作目錄為 playbook，則先在該目錄下新增一個 hosts，來描述終端裝置</p>\n<pre><code>playbook/\n    hosts               *# inventory file for production servers*\n</code></pre>\n<p>該檔案內容為</p>\n<pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token key attr-name\">pi ansible_host</span><span class=\"token punctuation\">=</span><span class=\"token value attr-value\">192.168.5.10 ansible_user=pi</span></code></pre>\n<p>由內容可以知道，該裝置名稱是 pi，IP 是 192.168.5.10，而用來登入的使用者名稱為 pi。</p>\n<p>接著可以執行 Ansible 的測試命令 ping，當裝置收到後，會回應 pong，表示兩者間通訊正常</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># -i is inventory</span><br><span class=\"token comment\"># -m is command module</span><br><br>ken@ken-Lenovo-ideapad-330-15ICH:~/git/ansible/raspberry/playbooks$ ansible pi -i hosts -m <span class=\"token function\">ping</span><br>pi <span class=\"token operator\">|</span> SUCCESS <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span><br>    <span class=\"token string\">\"changed\"</span><span class=\"token builtin class-name\">:</span> false, <br>    <span class=\"token string\">\"ping\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"pong\"</span><br><span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"setup-ansible-config-file\"><a class=\"direct-link\" href=\"#setup-ansible-config-file\">#</a> Setup Ansible Config File</h2>\n<p>因為每台裝置需要寫 hosts 來對應會很麻煩，如果裝置有共通欄位，例如 RPi 的 remote_user 都是 pi，能不能使用共同文件來設定？Ansible 的 config 檔就是為了滿足這個需求。我們在工作目錄下加入 config</p>\n<pre><code>playbook/\n    hosts               *# inventory file for production servers\n    ansible.cfg         *# ansible config file*\n</code></pre>\n<p>檔案內容如下</p>\n<pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token header\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">defaults</span><span class=\"token punctuation\">]</span></span><br><span class=\"token key attr-name\">inventory</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">hosts</span><br><span class=\"token key attr-name\">remote_user</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">pi</span><br><span class=\"token key attr-name\">host_key_checking</span> <span class=\"token punctuation\">=</span> <span class=\"token value attr-value\">False</span></code></pre>\n<p>將預設的 inventory 指向 hosts，預設的 user 設為 pi，如此一來，inventory file 中就無需描述多餘資訊，hosts 可以改成</p>\n<pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token key attr-name\">pi ansible_host</span><span class=\"token punctuation\">=</span><span class=\"token value attr-value\">192.168.5.10</span></code></pre>\n<p>因為 config 檔中已經指定 inventory 為 hosts，之後執行 Ansible 時就不用指定 -i 了。這次使用另外一個 Ansible 的命令來看 uptime 的時間</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken@ken-Lenovo-ideapad-330-15ICH:~/git/ansible/raspberry/playbooks$ ansible pi -m <span class=\"token builtin class-name\">command</span> -a <span class=\"token function\">uptime</span><br>pi <span class=\"token operator\">|</span> SUCCESS <span class=\"token operator\">|</span> <span class=\"token assign-left variable\">rc</span><span class=\"token operator\">=</span><span class=\"token number\">0</span> <span class=\"token operator\">>></span><br>    <span class=\"token number\">16</span>:28:46 up  <span class=\"token number\">2</span>:48,  <span class=\"token number\">4</span> users,  load average: <span class=\"token number\">0.08</span>, <span class=\"token number\">0.05</span>, <span class=\"token number\">0.01</span></code></pre>\n<p>如上，可以看到 RPi 從啟動到下指令，中間經過 2:48。</p>\n<h2 id=\"write-a-playbook\"><a class=\"direct-link\" href=\"#write-a-playbook\">#</a> Write a Playbook</h2>\n<p>在前面的步驟中，我們透過 Ansible 對遠端裝置進行單次指令，但如果組態設定或部署需要一次進行多次指令的話，我們可以怎麼做？Ansible 有個工具稱為 playbook，類似劇本，只要 user 依照 yaml 格式編寫好，Ansible 就會根據 playbook 來執行指令。</p>\n<p>為了使用 playbook，在工作目錄中加入 playbook 的檔案</p>\n<pre><code>playbook/\n    hosts               *# inventory file for production servers\n    ansible.cfg         *# ansible config file\n    pi-update.yml       *# ansible playbook*\n</code></pre>\n<p>內容如下</p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Update python script<br>  <span class=\"token key atrule\">hosts</span><span class=\"token punctuation\">:</span> end<span class=\"token punctuation\">-</span>devices<br>  <span class=\"token key atrule\">become</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">True</span><br>  <span class=\"token key atrule\">tasks</span><span class=\"token punctuation\">:</span><br>  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> copy python file<br>    <span class=\"token key atrule\">copy</span><span class=\"token punctuation\">:</span> src=files/hello.py dest=/home/pi/ansible/hello.py mode=0644<br>  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> run python file<br>    <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> python3 /home/pi/ansible/hello.py</code></pre>\n<p>在這個 playbook 中，執行對象是 end-devices 這個 inventory 群組。這個 playbook 存在兩個 task，第一個用來將 <a href=\"http://hello.py\">hello.py</a> 這支 python 的 copy 到終端裝置；第二個用來執行終端裝置上的 python 程式。</p>\n<p>可以看到，inventory 由原先的 hosts 改為 end-devices，這是因為 inventory 可能是由多台機器組成的群組，因此我們改寫原先的 inventory file，將它變成</p>\n<pre class=\"language-ini\"><code class=\"language-ini\"><span class=\"token header\"><span class=\"token punctuation\">[</span><span class=\"token section-name selector\">end-devices</span><span class=\"token punctuation\">]</span></span><br><span class=\"token key attr-name\">pi ansible_host</span><span class=\"token punctuation\">=</span><span class=\"token value attr-value\">192.168.5.10</span></code></pre>\n<p>在開頭加入群組名稱。</p>\n<p>接著，在工作目錄創建要複製過去的檔案</p>\n<pre><code>playbook/\n    hosts               *# inventory file for production servers\n    ansible.cfg         *# ansible config file\n    pi-update.yml       *# ansible playbook\n    files/              *# files\n      hello.py\n</code></pre>\n<p><code>hello.py</code> 是個 python 的程式碼，用來印出 “Hello, world”</p>\n<pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, world\"</span><span class=\"token punctuation\">)</span></code></pre>\n<p>相關準備完成了，來看看執行的結果。執行 playbook 需要使用 ansible-playbook 這個命令</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken@ken-Lenovo-ideapad-330-15ICH:~/git/ansible/raspberry/playbooks$ ansible-playbook pi-update.yml<br><br>PLAY <span class=\"token punctuation\">[</span>Update python script<span class=\"token punctuation\">]</span> ********************************************************************<br><br>TASK <span class=\"token punctuation\">[</span>Gathering Facts<span class=\"token punctuation\">]</span> ********************************************************************<br>ok: <span class=\"token punctuation\">[</span>pi<span class=\"token punctuation\">]</span><br><br>TASK <span class=\"token punctuation\">[</span>copy python file<span class=\"token punctuation\">]</span> ********************************************************************<br>changed: <span class=\"token punctuation\">[</span>pi<span class=\"token punctuation\">]</span><br><br>TASK <span class=\"token punctuation\">[</span>run python file<span class=\"token punctuation\">]</span> ********************************************************************<br>changed: <span class=\"token punctuation\">[</span>pi<span class=\"token punctuation\">]</span><br><br>PLAY RECAP ********************************************************************<br>pi                  <span class=\"token builtin class-name\">:</span> <span class=\"token assign-left variable\">ok</span><span class=\"token operator\">=</span><span class=\"token number\">3</span>    <span class=\"token assign-left variable\">changed</span><span class=\"token operator\">=</span><span class=\"token number\">2</span>    <span class=\"token assign-left variable\">unreachable</span><span class=\"token operator\">=</span><span class=\"token number\">0</span>    <span class=\"token assign-left variable\">failed</span><span class=\"token operator\">=</span><span class=\"token number\">0</span></code></pre>\n<p>Ansible 會先收集裝置上的資訊，然後依照 playbook 來執行 task，changed 表示裝置被實際變動，由結果可看到 Ansible 將 <code>hello.py</code> 複製到 RPi 上，並且執行 python script。</p>\n<h2 id=\"add-debug-information\"><a class=\"direct-link\" href=\"#add-debug-information\">#</a> Add Debug Information</h2>\n<p>但是 <code>hello.py</code> 有印出 “Hello, world”，為什麼在執行結果沒看到呢？這是因為印出的資訊是在 RPi 上，如果要將輸出結果顯示到 Ansible 的結果中，可以修改 playbook 如下</p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Update python script<br>  <span class=\"token key atrule\">hosts</span><span class=\"token punctuation\">:</span> end<span class=\"token punctuation\">-</span>devices<br>  <span class=\"token key atrule\">become</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">True</span><br>  <span class=\"token key atrule\">tasks</span><span class=\"token punctuation\">:</span><br>  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> copy python file<br>    <span class=\"token key atrule\">copy</span><span class=\"token punctuation\">:</span> src=files/hello.py dest=/home/pi/ansible/hello.py mode=0644<br>  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> run python file<br>    <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> python3 /home/pi/ansible/hello.py<br>    <span class=\"token key atrule\">register</span><span class=\"token punctuation\">:</span> hello<br>  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">debug</span><span class=\"token punctuation\">:</span> var=hello</code></pre>\n<p>將 task 的結果用 register 註冊為 variable，再使用 debug 印出，方便除錯。</p>\n<p>好的，再執行一次 ansible-playbook</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken@ken-Lenovo-ideapad-330-15ICH:~/git/ansible/raspberry/playbooks$ ansible-playbook pi-update.yml<br><br>PLAY <span class=\"token punctuation\">[</span>Update python script<span class=\"token punctuation\">]</span> ********************************************************************<br><br>TASK <span class=\"token punctuation\">[</span>Gathering Facts<span class=\"token punctuation\">]</span> ********************************************************************<br>ok: <span class=\"token punctuation\">[</span>pi<span class=\"token punctuation\">]</span><br><br>TASK <span class=\"token punctuation\">[</span>copy python file<span class=\"token punctuation\">]</span> ********************************************************************<br>ok: <span class=\"token punctuation\">[</span>pi<span class=\"token punctuation\">]</span><br><br>TASK <span class=\"token punctuation\">[</span>run python file<span class=\"token punctuation\">]</span> ********************************************************************<br>changed: <span class=\"token punctuation\">[</span>pi<span class=\"token punctuation\">]</span><br><br>TASK <span class=\"token punctuation\">[</span>debug<span class=\"token punctuation\">]</span> ********************************************************************<br>ok: <span class=\"token punctuation\">[</span>pi<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span><br>    <span class=\"token string\">\"hello\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">{</span><br>        <span class=\"token string\">\"changed\"</span><span class=\"token builtin class-name\">:</span> true, <br>        <span class=\"token string\">\"cmd\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">[</span><br>            <span class=\"token string\">\"python3\"</span>, <br>            <span class=\"token string\">\"/home/pi/ansible/hello.py\"</span><br>        <span class=\"token punctuation\">]</span>, <br>        <span class=\"token string\">\"delta\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"0:00:00.779588\"</span>, <br>        <span class=\"token string\">\"end\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"2019-11-25 20:06:11.911999\"</span>, <br>        <span class=\"token string\">\"failed\"</span><span class=\"token builtin class-name\">:</span> false, <br>        <span class=\"token string\">\"rc\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token number\">0</span>, <br>        <span class=\"token string\">\"start\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"2019-11-25 20:06:11.132411\"</span>, <br>        <span class=\"token string\">\"stderr\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"\"</span>, <br>        <span class=\"token string\">\"stderr_lines\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>, <br>        <span class=\"token string\">\"stdout\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"Hello, world\"</span>, <br>        <span class=\"token string\">\"stdout_lines\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">[</span><br>            <span class=\"token string\">\"Hello, world\"</span><br>        <span class=\"token punctuation\">]</span><br>    <span class=\"token punctuation\">}</span><br><span class=\"token punctuation\">}</span><br><br>PLAY RECAP ********************************************************************<br>pi                 <span class=\"token builtin class-name\">:</span> <span class=\"token assign-left variable\">ok</span><span class=\"token operator\">=</span><span class=\"token number\">4</span>    <span class=\"token assign-left variable\">changed</span><span class=\"token operator\">=</span><span class=\"token number\">1</span>    <span class=\"token assign-left variable\">unreachable</span><span class=\"token operator\">=</span><span class=\"token number\">0</span>    <span class=\"token assign-left variable\">failed</span><span class=\"token operator\">=</span><span class=\"token number\">0</span></code></pre>\n<p>這次就可以看到 stdout 結果是 “Hello, world”，同時因為 <code>hello.py</code> 已經複製過了，第一個 task 狀態改為 ok，而非 changed。</p>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>初次上路，好在沒有翻車。Ansible 相對 expect 這類響應式腳本複雜不少，但需要的 cost 真的很低，只需要 python 就可以運行。優點是 framework 架構完整，修改性跟移植性高，當專案成長到一定規模，expect 維護起來很麻煩時，就可以考慮用 Ansible 來補充。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"https://www.tenlong.com.tw/products/9789864768264\">《Ansible：建置與執行》</a></li>\n<li><a href=\"https://docs.ansible.com/\">Ansible Documentation</a></li>\n<li><a href=\"https://medium.com/laraveldojo/%E8%AE%93%E6%82%A8%E5%AE%89%E5%BF%83%E5%9F%B7%E8%A1%8C-ansible-playbook-%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-2-856a60b19898?source=---------14------------------\">讓您安心執行 Ansible playbook 的小技巧（2）</a></li>\n</ul>\n",
      "date_published": "2019-11-26T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2019/use-vscode-to-remote-coding/",
      "url": "https://blog.kenwsc.com/posts/2019/use-vscode-to-remote-coding/",
      "title": "遠端開發環境架設：Web 版 VSCode",
      "content_html": "<p>手邊一些開發有使用 Flask，因為 Flask 是架在遠端 Server 上，如果本地開發後還要部署到遠端，等於中間多了一個步驟，切來切去很麻煩，所以在想，有沒有機會直接在遠端進行開發？Google 後發現有個 code-server，能用 VSCode 進行 Remote Coding，所以還等什麼呢，來試試看吧。</p>\n<h2 id=\"use-docker-to-deploy-code-server\"><a class=\"direct-link\" href=\"#use-docker-to-deploy-code-server\">#</a> Use Docker to Deploy code-server</h2>\n<p>依照 code-server 的 Github，我們可以使用 docker 來架設</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># -v bind docker folder to host's folder</span><br><span class=\"token comment\"># codercom/code-server:v2 is docker image</span><br><br>docker run -it -p <span class=\"token number\">127.0</span>.0.1:8080:8080 -v <span class=\"token string\">\"<span class=\"token variable\">${<span class=\"token environment constant\">HOME</span>}</span>/.local/share/code-server:/home/coder/.local/share/code-server\"</span> -v <span class=\"token string\">\"<span class=\"token environment constant\">$PWD</span>:/home/coder/project\"</span> codercom/code-server:v2</code></pre>\n<p>docker 會自動去 Docker Hub 將 image 抓下來設置，完成。</p>\n<p>好像有點簡單，用瀏覽器來看一下成果</p>\n<p><img src=\"/img/posts/2019/use-vscode-to-remote-coding/vscode-1.webp\" alt=\"\"></p>\n<p>看起來跟本機端的 VSCode 幾乎完全一樣啊！</p>\n<h2 id=\"use-binary\"><a class=\"direct-link\" href=\"#use-binary\">#</a> Use Binary</h2>\n<p>因為用 docker 真的太簡單了，沒有挑戰性，為了充篇幅，接著來看如果不使用 docker，要使用 binary 來執行的話，可以怎麼做。</p>\n<p>GitHub 同樣有 QuickStart Guide</p>\n<blockquote>\n<ol>\n<li>Visit the releases page and download the latest binary for your operating system.</li>\n<li>Unpack the downloaded file then run the binary.</li>\n<li>In your browser navigate to localhost:8080.</li>\n</ol>\n</blockquote>\n<p>我的電腦是 Linux，首先依照步驟，先去下載 binary</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">wget</span> <span class=\"token punctuation\">[</span>https://github.com/cdr/code-server/releases/download/2.1692-vsc1.39.2/code-server2.1692-vsc1.39.2-linux-x86_64.tar.gz<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>https://github.com/cdr/code-server/releases/download/2.1692-vsc1.39.2/code-server2.1692-vsc1.39.2-linux-x86_64.tar.gz<span class=\"token punctuation\">)</span></code></pre>\n<p>解壓縮並安裝到 /bin</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">tar</span> zxvf code-server2.1665-vsc1.39.2-linux-x86_64.tar.gz<br><span class=\"token builtin class-name\">cd</span> code-server2.1665-vsc1.39.2-linux-x86_64/<br><span class=\"token function\">mv</span> code-server ~/bin/<br><span class=\"token builtin class-name\">cd</span><br><span class=\"token builtin class-name\">source</span> .bashrc </code></pre>\n<p>接著執行</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken@ken-Lenovo-ideapad-330-15ICH:~$ code-server<br>info  Server listening on <span class=\"token punctuation\">[</span>http://localhost:8080<span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>http://localhost:8080<span class=\"token punctuation\">)</span><br>info    - Password is 803570ed676b5d026417da00<br>info      - To use your own password, <span class=\"token builtin class-name\">set</span> the PASSWORD environment variable<br>info      - To disable use <span class=\"token variable\"><span class=\"token variable\">`</span>--auth none<span class=\"token variable\">`</span></span><br>info    - Not serving HTTPS</code></pre>\n<p><img src=\"/img/posts/2019/use-vscode-to-remote-coding/vscode-2.webp\" alt=\"\"></p>\n<p>由瀏覽器可以看到登入頁面，輸入隨機產生的密碼後登入</p>\n<h2 id=\"set-password\"><a class=\"direct-link\" href=\"#set-password\">#</a> Set Password</h2>\n<p>由 Step 2 執行後的結果可以看到，在 code-server 預設上，每次執行會隨機產生一組密碼，要登入就需要輸入。這麼做雖然保障安全性，但是非常麻煩。所幸 code-server 會自行讀取環境變數來設置密碼，因此只需要將使用的密碼設定在環境變數，就能固定用這組密碼登入</p>\n<pre><code>export PASSWORD=&quot;******&quot;\ncode-server\n</code></pre>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>code-server 還有其他選項可以設定，就不一一細講了，有興趣可以自己翻GitHub。Remote coding 的優點在 GitHub 上也講得很清楚：</p>\n<blockquote>\n<ul>\n<li>Consistent environment: Code on your Chromebook, tablet, and laptop with a consistent dev environment. develop more easily for Linux if you have a Windows or Mac, and pick up where you left off when switching workstations.</li>\n<li>Server-powered: Take advantage of large cloud servers to speed up tests, compilations, downloads, and more. Preserve battery life when you're on the go since all intensive computation runs on your server.</li>\n</ul>\n</blockquote>\n<p>你可以在任何地點、任何裝置上，從上次暫停的部分繼續 coding；你可以使用雲端裝置的運算能力，協助你進行編譯、測試，而且省下裝置的電量。這意味著你可以移動－－只要有網路的話，所在的地方就是辦公室，不用限定在一格一格死氣沉沉的辦公間或是某張特定的桌子上。</p>\n<p>這很讓人振奮不是嗎？要說技術如何改變生活，我想這就是個例子。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"https://github.com/cdr/code-server\">GitHub: code-server</a></li>\n</ul>\n",
      "date_published": "2019-11-17T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2019/coding-by-your-smartphone/",
      "url": "https://blog.kenwsc.com/posts/2019/coding-by-your-smartphone/",
      "title": "全世界都是你的工作室：GCP 的雲端開發環境",
      "content_html": "<p>最近看到 Heron 的 Medium 在討論使用 iPad 來開發程式，深深被 Thin Client 給感動了。如果能從硬體裝置中解放，不用開發程式前還需要花費大把時間精力來架設環境，那我們就能更快驗證，更快學習，更快迭代，把時間花在重要而有價值的事上。</p>\n<p>Thin Client 的概念說來單純，我們可以將所有能連上網路的介面都可以當成終端，在傳統開發環境中，終端跟運算是放在同一台機器上，輸入完成後，使用機器的資源來進行運算，像是編譯程式、執行與提供服務；但自從有了雲端後，可以將這類運算都交由雲端處理，只要有個合用的終端介面能輸入與呈現資訊，就能得到運算結果。</p>\n<h2 id=\"apply-gcp-free-plan\"><a class=\"direct-link\" href=\"#apply-gcp-free-plan\">#</a> Apply GCP free plan</h2>\n<p>既然運算資源放在雲端，首先要申請一個雲端帳戶，這邊以 GCP 的免費方案為例，首先點選 GCP 的免費試用</p>\n<p><img src=\"/img/posts/2019/coding-by-your-smartphone/gcp-1.webp\" alt=\"\"></p>\n<p>GCP 的免費方案提供 $300 刀的額度，還有 12 個月的使用時間，可以使用 GCP 上所有服務，如果是小型或低成本的運算，甚至不用動到 $300 的費用。</p>\n<p>選擇國家/地區後，按[繼續]進入第二頁</p>\n<p><img src=\"/img/posts/2019/coding-by-your-smartphone/gcp-2.webp\" alt=\"\"></p>\n<p>第二頁要填入個人資訊，還需要一張信用卡卡號。依照 Google 的說法，信用卡是為了驗證身分。要注意 GCP 不支援 JCB，請用 Visa/Master Card 來申請。</p>\n<h2 id=\"create-project\"><a class=\"direct-link\" href=\"#create-project\">#</a> Create Project</h2>\n<p>進入 GCP 首頁後，可以先創建一個新的 Project，來放置要測試的東西，點選 Google Cloud Platform 旁的 Project 名稱，再點選跳出視窗右上角的 New Project</p>\n<p><img src=\"/img/posts/2019/coding-by-your-smartphone/gcp-3.webp\" alt=\"\"></p>\n<p>填入 Project name 跟要放置的 Folder，例如 Linux VM，完成 Project 的建置。</p>\n<p><img src=\"/img/posts/2019/coding-by-your-smartphone/gcp-4.webp\" alt=\"\"></p>\n<h2 id=\"create-vm-instance\"><a class=\"direct-link\" href=\"#create-vm-instance\">#</a> Create VM instance</h2>\n<p>有了 Project 後，可以在裡面創建需要的雲端服務，因為主要目的是驗證 Thin Client 是否可行，選擇創建一個 VM 實例來進行登入。要創建 VM 實例可以點選 Menu 中的 Compute Engine &gt; VM Instances，選擇 Create</p>\n<p><img src=\"/img/posts/2019/coding-by-your-smartphone/gcp-5.webp\" alt=\"\"></p>\n<p>Create 的選項有很多，參照 GCP 的免費方案說明，使用 Region 為 us-central1 (Iowa)，Machine Type 為 f1-micro</p>\n<p><img src=\"/img/posts/2019/coding-by-your-smartphone/gcp-6.webp\" alt=\"\"></p>\n<p>Boot Disk 看個人習慣，我平常用的環境是 Ubuntu 18.04 LTS，這邊選同樣的，如果有習慣 Debian 或其他 Distribution 的人，也可以自行選擇</p>\n<p><img src=\"/img/posts/2019/coding-by-your-smartphone/gcp-7.webp\" alt=\"\"></p>\n<p>點選[Create]，完成 VM 創建。</p>\n<h2 id=\"setup-ssh\"><a class=\"direct-link\" href=\"#setup-ssh\">#</a> Setup SSH</h2>\n<p>在終端安裝 SSH 的 Client，例如 Windows 常用的 putty，或者 Termius 這款 App。沒有 SSH Key 的人需要使用程式產生出 SSH Key，再將 Private Key 指定給 SSH Client，同時將 Public Key 放置到雲端。產生 Key 的步驟就不多說了，Windows 下的使用者可以用 PuTTYgen 來產生，Linux 使用者可以用 ssh-keygen。</p>\n<p>有 Public Key 後，要將它放到雲端，方便以後登入。選擇 Compute Engine 中的 Metadata，點選 SSH Keys，可以管理金鑰。點選 Add SSH keys 來加入自己的 Public Key</p>\n<p><img src=\"/img/posts/2019/coding-by-your-smartphone/gcp-8.webp\" alt=\"\"></p>\n<p>加入後回到 VM instances，查看對應的 External IP，使用 SSH Client 輸入 user@address，登入 VM instance，記得 user 是要 key 對應的 user，address 是要 External IP。驗證看看能否登入。</p>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>自從雲端的商業模式建立起來後，許多做法都會跟著改變，這是一個思維上的轉換，以前需要的東西有可能被淘汰掉，而新的需求會被創造出來。如果可以用 GCP 處理掉伺服器，我沒必要再去購買伺服器的硬體來自行架設網站，不但比較便宜，也省掉 Maintain 的 Effort。同時，高效能對 Laptop 也不會再是議題，取而代之的，應該是穩定而快速的網路服務配上輕便的終端顯示器。</p>\n<p>最後放張完成圖，紀念一下。</p>\n<p><img src=\"/img/posts/2019/coding-by-your-smartphone/gcp-9.webp\" alt=\"\"></p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"https://blog.heron.me/coding-on-ipad-d264c5c6325e\">拿 iPad 取代筆電做程式開發</a></li>\n<li><a href=\"https://cloud.google.com/free/docs/gcp-free-tier?hl=zh-tw\">GCP 免費方案</a></li>\n</ul>\n",
      "date_published": "2019-10-11T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2019/visualize-your-redmine-data/",
      "url": "https://blog.kenwsc.com/posts/2019/visualize-your-redmine-data/",
      "title": "掌握 Redmine 的活動指標：繪製熱度圖",
      "content_html": "<p>我們平常使用 Redmine 來管理專案，當需要進行 Review 或討論如何改善時，常常需要基於 Redmine 的數據。由這些數據分析，也能得知團隊執行狀況是否順利。但是 Redmine 本身並沒有整合 Dashboard 的功能，因此需要透過 RESTful API 來取得專案資料，再使用第三方軟體繪製成圖表。</p>\n<h2 id=\"%E5%AE%89%E8%A3%9D-python-redmine\"><a class=\"direct-link\" href=\"#%E5%AE%89%E8%A3%9D-python-redmine\">#</a> 安裝 python-redmine</h2>\n<p>由於 Python 是我熟悉的腳本語言，選擇用 Python 來進行 Proof of Concept，首先安裝相關的 Python 套件</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">python -m pip <span class=\"token function\">install</span> python-redmine</code></pre>\n<p>如果電腦有支援 pip 指令，可以直接用</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">pip3 <span class=\"token function\">install</span> python-redmine</code></pre>\n<p>來安裝。</p>\n<p>Windows 的 pip 使用可能跟 Ubuntu 不同，至少我還沒找到用法，這邊選擇用 option-m 的模組執行方式，來執行 python 內的 pip module，效果跟 pip 相同，只是命令比較不直覺。</p>\n<h2 id=\"%E7%99%BB%E5%85%A5-redmine\"><a class=\"direct-link\" href=\"#%E7%99%BB%E5%85%A5-redmine\">#</a> 登入 redmine</h2>\n<p>python-redmine 已經將 redmine 的 API 指令封裝成 python 的語法，直接調用即可，我們先使用帳號密碼登入 redmine</p>\n<pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">from</span> redminelib <span class=\"token keyword\">import</span> Redmine<br>redmine <span class=\"token operator\">=</span> Redmine<span class=\"token punctuation\">(</span><span class=\"token string\">'http://demo.redmine.org'</span><span class=\"token punctuation\">,</span> username<span class=\"token operator\">=</span><span class=\"token string\">'foo'</span><span class=\"token punctuation\">,</span> password<span class=\"token operator\">=</span><span class=\"token string\">'bar'</span><span class=\"token punctuation\">)</span></code></pre>\n<p>第一個參數填入 redmine 所在的 url，後面帶自己的帳號與密碼，如果無法登入，可以參考官網說明，請管理員將 REST API 打開。</p>\n<h2 id=\"%E5%8F%96%E5%BE%97-issue-%E5%88%97%E8%A1%A8\"><a class=\"direct-link\" href=\"#%E5%8F%96%E5%BE%97-issue-%E5%88%97%E8%A1%A8\">#</a> 取得 issue 列表</h2>\n<p>我的目標是取得 redmine 上的所有 issue。其中包含 assign 給我的 issue 量、我已經處理完成的 issue 量，藉此來觀察專案的成果。</p>\n<p>首先是 assign 給我的數量</p>\n<pre class=\"language-py\"><code class=\"language-py\">issues <span class=\"token operator\">=</span> redmine<span class=\"token punctuation\">.</span>issue<span class=\"token punctuation\">.</span><span class=\"token builtin\">filter</span><span class=\"token punctuation\">(</span><br>    project_id<span class=\"token operator\">=</span><span class=\"token string\">'demo'</span><span class=\"token punctuation\">,</span><br>    status_id<span class=\"token operator\">=</span><span class=\"token string\">'*'</span><span class=\"token punctuation\">,</span><br>    assigned_to_id<span class=\"token operator\">=</span>me<br><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Total opened count is: \"</span> <span class=\"token operator\">+</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span>issues<span class=\"token punctuation\">.</span>total_count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre>\n<p>filter 可以設定要取回的 issues 條件；我要取回的是在 demo 專案下、任意狀態、assign 給我的 issues。</p>\n<p>同樣的，我們也可以取得我已經完成的 issue</p>\n<pre class=\"language-py\"><code class=\"language-py\">issues_closed <span class=\"token operator\">=</span> redmine<span class=\"token punctuation\">.</span>issue<span class=\"token punctuation\">.</span><span class=\"token builtin\">filter</span><span class=\"token punctuation\">(</span><br>    project_id<span class=\"token operator\">=</span><span class=\"token string\">'demo'</span><span class=\"token punctuation\">,</span><br>    status_id<span class=\"token operator\">=</span><span class=\"token string\">'closed'</span><span class=\"token punctuation\">,</span><br>    assigned_to_id<span class=\"token operator\">=</span><span class=\"token string\">'me'</span><br><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Total closed count is: \"</span> <span class=\"token operator\">+</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span>issues_closed<span class=\"token punctuation\">.</span>total_count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre>\n<h2 id=\"%E7%95%AB%E5%87%BA-heatmap\"><a class=\"direct-link\" href=\"#%E7%95%AB%E5%87%BA-heatmap\">#</a> 畫出 Heatmap</h2>\n<p>接著，我希望可以將平常在 redmine 上的活動畫成 heatmap，畢竟對專案而言，活躍度是非常重要的指標，而活躍度的指標之一就是更新頻率。遍歷所有的 issue，查詢底下的 journal 是否是由我發出，如果是的話，在 heatmap data array 的對應欄位 +1，藉此統計活動狀況。</p>\n<pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">import</span> re<br><span class=\"token keyword\">import</span> datetime<br><span class=\"token keyword\">import</span> numpy<br>week_start <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>datetime<span class=\"token punctuation\">.</span>date<span class=\"token punctuation\">(</span><span class=\"token number\">2019</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>strftime<span class=\"token punctuation\">(</span><span class=\"token string\">\"%V\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><br>week_end <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>datetime<span class=\"token punctuation\">.</span>date<span class=\"token punctuation\">(</span><span class=\"token number\">2019</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">31</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>strftime<span class=\"token punctuation\">(</span><span class=\"token string\">\"%V\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><br>week_duration <span class=\"token operator\">=</span> week_end <span class=\"token operator\">-</span> week_start <span class=\"token operator\">+</span> <span class=\"token number\">1</span><br>journal_ken <span class=\"token operator\">=</span> <span class=\"token number\">0</span><br>data_arr <span class=\"token operator\">=</span> numpy<span class=\"token punctuation\">.</span>zeros<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> week_duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><br>p <span class=\"token operator\">=</span> re<span class=\"token punctuation\">.</span><span class=\"token builtin\">compile</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"(\\d{4})-(\\d{2})-(\\d{2})\"</span><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">for</span> issue <span class=\"token keyword\">in</span> issues<span class=\"token punctuation\">:</span><br>    <span class=\"token keyword\">for</span> resource <span class=\"token keyword\">in</span> issue<span class=\"token punctuation\">.</span>journals<span class=\"token punctuation\">.</span>_resources<span class=\"token punctuation\">:</span><br>        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> resource<span class=\"token punctuation\">[</span><span class=\"token string\">'user'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"Ken Chen\"</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">continue</span><br>        match <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>match<span class=\"token punctuation\">(</span>resource<span class=\"token punctuation\">[</span><span class=\"token string\">'created_on'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><br>        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>match<span class=\"token punctuation\">.</span>group<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">2019</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">continue</span><br>        journal_ken <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><br>        week <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>datetime<span class=\"token punctuation\">.</span>date<span class=\"token punctuation\">(</span><span class=\"token number\">2019</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>match<span class=\"token punctuation\">.</span>group<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>match<span class=\"token punctuation\">.</span>group<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>strftime<span class=\"token punctuation\">(</span><span class=\"token string\">\"%V\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><br>        weekday <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>datetime<span class=\"token punctuation\">.</span>date<span class=\"token punctuation\">(</span><span class=\"token number\">2019</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>match<span class=\"token punctuation\">.</span>group<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>match<span class=\"token punctuation\">.</span>group<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>strftime<span class=\"token punctuation\">(</span><span class=\"token string\">\"%w\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><br>        data_arr<span class=\"token punctuation\">[</span>weekday<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>week <span class=\"token operator\">-</span> week_start<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><br><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Total journal of Ken is: \"</span> <span class=\"token operator\">+</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span>journal_ken<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre>\n<p>week_start 、 week_end 、 week_duration 用來限制時間範圍，使用正則表達式來判斷 journal 的時間是否落在指定的區段， journal_ken 用來統計總數。</p>\n<p>得到資料陣列後，就能使用 seaborn 畫成圖</p>\n<pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">import</span> seaborn <span class=\"token keyword\">as</span> sns<span class=\"token punctuation\">;</span> sns<span class=\"token punctuation\">.</span><span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">import</span> matplotlib<span class=\"token punctuation\">.</span>pyplot <span class=\"token keyword\">as</span> plt<br>ax <span class=\"token operator\">=</span> sns<span class=\"token punctuation\">.</span>heatmap<span class=\"token punctuation\">(</span><br>    data_arr<br><span class=\"token punctuation\">)</span><br>plt<span class=\"token punctuation\">.</span>show<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<p><img src=\"/img/posts/2019/visualize-your-redmine-data/heatmap-1.webp\" alt=\"\"></p>\n<h2 id=\"%E4%BF%AE%E9%A3%BE-heatmap\"><a class=\"direct-link\" href=\"#%E4%BF%AE%E9%A3%BE-heatmap\">#</a> 修飾 Heatmap</h2>\n<p>預設圖片跟想要呈現的效果有段落差，如果直接拿出去，大概會立刻被打槍，這邊需要進行一些美化，使用 seaborn 的參數來調整</p>\n<pre class=\"language-py\"><code class=\"language-py\">data_masks <span class=\"token operator\">=</span> numpy<span class=\"token punctuation\">.</span>zeros<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> week_duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><br><span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>    <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>week_duration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>        <span class=\"token keyword\">if</span> data_arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span> data_masks<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><br>ax <span class=\"token operator\">=</span> sns<span class=\"token punctuation\">.</span>heatmap<span class=\"token punctuation\">(</span><br>    data_arr<span class=\"token punctuation\">,</span> <br>    cmap <span class=\"token operator\">=</span> <span class=\"token string\">'Blues'</span><span class=\"token punctuation\">,</span> <br>    mask<span class=\"token operator\">=</span>data_masks<span class=\"token punctuation\">,</span> <br>    yticklabels <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"Sun\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Mon\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Tue\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Wed\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Thu\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Fri\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"Sat\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <br>    linewidths <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <br>    square <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span><br>    cbar <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span><br><span class=\"token punctuation\">)</span><br>ax<span class=\"token punctuation\">.</span>set_ylim<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span><br>plt<span class=\"token punctuation\">.</span>show<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<p>修改顏色；加入遮罩遮掉值是 0 的區段；加入 y 軸標示；加粗格線；讓顯示的區塊為方形；拿掉色彩條。 ax.set_ylim 則是因為 matplotlib 本身的 Bug 會導致圖片只畫一半</p>\n<p><img src=\"/img/posts/2019/visualize-your-redmine-data/bug-1.webp\" alt=\"\"></p>\n<p>如果不想用開發中的版本，要不就等 3.1.2 版，要不就退回 3.1.0 版，要不就使用 ax.set_ylim 。我不太想動版本，只好乖乖使用指令來調整。</p>\n<p>當一切就緒後，我們就可以得到</p>\n<p><img src=\"/img/posts/2019/visualize-your-redmine-data/heatmap-2.webp\" alt=\"\"></p>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>稍微用 python 開個小小的 side project，就能體會到用 python 來驗證概念的威力。由於有完整的生態系，python 適合快速開發，快速驗證，很快就能知道自己的想法是否行得通，不用花費一堆時間蓋完基礎建設後，才發現由於需要的 API 沒開出來，導致專案 Fail。</p>\n<p>資料視覺化真的是很有意思的題目，如果有機會的話，很想將整個團隊的資料即時視覺處理，跑專案時只要進到戰情室就能一目了然。</p>\n<p>最後，我對 python 不支援 var++ 的用法有點意見，對 C 語言的工程師來講不太友善。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"http://www.redmine.org/\">Redmine</a></li>\n<li><a href=\"https://python-redmine.com/\">Python-Redmine</a></li>\n<li><a href=\"https://seaborn.pydata.org/generated/seaborn.heatmap.html\">seaborn.heatmap</a></li>\n</ul>\n",
      "date_published": "2019-08-31T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2019/using-physical-disc-with-virtualbox/",
      "url": "https://blog.kenwsc.com/posts/2019/using-physical-disc-with-virtualbox/",
      "title": "用 VirtualBox 開啟實體硬碟中的 Windows",
      "content_html": "<p>如果用 Linux 當開發環境，常常會碰到一個問題：因為一般企業使用的管理系統沒有 Linux 版本，導致有些操作必須使用 Windows 來完成。對於大部分的應用來說，在 VirtualBox 內安裝 Windows 可能就能解決，問題是，通常 VirtualBox 的 Windows 都是由工程師自行安裝，不是正式授權；再來，在 VirtualBox 內安裝 Windows，意味加上原來預設的 Windows，硬碟內要有兩套 Windows，這真的讓人很難接受，一套已經很佔空間了，居然還要兩套？</p>\n<p>於是我有個想法，要是 VirtualBox 可以用實體空間來開機的話，就能直接在 VirtualBox 執行原本配置的系統，如此一來，可以用 IT 已經安裝好的授權軟體不說，也省掉了後續資料交換的麻煩。Google 後發現還真的有這種應用，當然馬上試試看。</p>\n<h2 id=\"%E5%88%97%E5%87%BA%E5%88%86%E5%8D%80\"><a class=\"direct-link\" href=\"#%E5%88%97%E5%87%BA%E5%88%86%E5%8D%80\">#</a> 列出分區</h2>\n<p>首先因為是使用硬碟的資料，我們需要確認 Windows 安裝在哪個 Partition，使用 fdisk -l 列出所有 Partition 的狀態</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken:~$ <span class=\"token function\">sudo</span> <span class=\"token function\">fdisk</span> -l /dev/nvme0n1<br>Disk /dev/nvme0n1: <span class=\"token number\">119.2</span> GiB, <span class=\"token number\">128035676160</span> bytes, <span class=\"token number\">250069680</span> sectors<br>Units: sectors of <span class=\"token number\">1</span> * <span class=\"token number\">512</span> <span class=\"token operator\">=</span> <span class=\"token number\">512</span> bytes<br>Sector size <span class=\"token punctuation\">(</span>logical/physical<span class=\"token punctuation\">)</span>: <span class=\"token number\">512</span> bytes / <span class=\"token number\">512</span> bytes<br>I/O size <span class=\"token punctuation\">(</span>minimum/optimal<span class=\"token punctuation\">)</span>: <span class=\"token number\">512</span> bytes / <span class=\"token number\">512</span> bytes<br>Disklabel type: gpt<br>Disk identifier: 664C31C9-8F24-4D89-B16A-426FDCDBB716<br>Device             Start       End   Sectors  Size Type<br>/dev/nvme0n1p1      <span class=\"token number\">2048</span>    <span class=\"token number\">534527</span>    <span class=\"token number\">532480</span>  260M EFI System<br>/dev/nvme0n1p2    <span class=\"token number\">534528</span>    <span class=\"token number\">567295</span>     <span class=\"token number\">32768</span>   16M Microsoft reserved<br>/dev/nvme0n1p3    <span class=\"token number\">567296</span> <span class=\"token number\">111706111</span> <span class=\"token number\">111138816</span>   53G Microsoft basic data<br>/dev/nvme0n1p4 <span class=\"token number\">248020992</span> <span class=\"token number\">250068991</span>   <span class=\"token number\">2048000</span> 1000M Windows recovery environment<br>/dev/nvme0n1p5 <span class=\"token number\">111706112</span> <span class=\"token number\">112504831</span>    <span class=\"token number\">798720</span>  390M Linux filesystem<br>/dev/nvme0n1p6 <span class=\"token number\">112504832</span> <span class=\"token number\">144502783</span>  <span class=\"token number\">31997952</span> <span class=\"token number\">15</span>.3G Linux swap<br>/dev/nvme0n1p7 <span class=\"token number\">144502784</span> <span class=\"token number\">248020991</span> <span class=\"token number\">103518208</span> <span class=\"token number\">49</span>.4G Linux filesystem</code></pre>\n<p>可以看到 Windows 的資料位於 dev/nvme0n1</p>\n<h2 id=\"%E5%89%B5%E5%BB%BA-vmdk-%E6%AA%94\"><a class=\"direct-link\" href=\"#%E5%89%B5%E5%BB%BA-vmdk-%E6%AA%94\">#</a> 創建 VMDK 檔</h2>\n<p>接著，為了讓 VirtualBox 可以從實體硬碟開機，我們需要建立 vmdk 檔來表示實體硬碟。使用 VirtualBox 指令</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">ken:~$ <span class=\"token function\">sudo</span> VBoxManage internalcommands createrawvmdk -filename ~/vmdk/windows_10.vmdk -rawdisk /dev/nvme0n1p1<br>RAW <span class=\"token function\">host</span> disk access VMDK <span class=\"token function\">file</span> /home/ken/vmdk/windows_10.vmdk created successfully.</code></pre>\n<h2 id=\"%E5%89%B5%E5%BB%BA%E8%99%9B%E6%93%AC%E6%A9%9F\"><a class=\"direct-link\" href=\"#%E5%89%B5%E5%BB%BA%E8%99%9B%E6%93%AC%E6%A9%9F\">#</a> 創建虛擬機</h2>\n<p>再來，開啟 VirtualBox，用剛剛建好的 vmdk 檔來開機</p>\n<p><img src=\"/img/posts/2019/using-physical-disc-with-virtualbox/virtualbox-1.webp\" alt=\"\"></p>\n<p>這邊要注意，雖然我們的系統安裝在 SSD，使用的是 NVMe，但 VirtualBox 的 NVMe 似乎有問題，因此這邊選擇用 SATA</p>\n<p><img src=\"/img/posts/2019/using-physical-disc-with-virtualbox/virtualbox-2.webp\" alt=\"\"></p>\n<p>前面看到 nvme0n1 開頭是 EFI，因此記得要 Enable EFI</p>\n<p><img src=\"/img/posts/2019/using-physical-disc-with-virtualbox/virtualbox-3.webp\" alt=\"\"></p>\n<h2 id=\"%E5%95%9F%E5%8B%95%E8%99%9B%E6%93%AC%E6%A9%9F\"><a class=\"direct-link\" href=\"#%E5%95%9F%E5%8B%95%E8%99%9B%E6%93%AC%E6%A9%9F\">#</a> 啟動虛擬機</h2>\n<p>設定都完成後，只要開啟 Virtual Machine，應該能看到 GRUB 的畫面，選擇 Windows Boot Manager，進入 Windows，完工。</p>\n<p><img src=\"/img/posts/2019/using-physical-disc-with-virtualbox/virtualbox-4.webp\" alt=\"\"></p>\n<h2 id=\"%E5%B0%8F%E7%B5%90\"><a class=\"direct-link\" href=\"#%E5%B0%8F%E7%B5%90\">#</a> 小結</h2>\n<p>使用 VirtualBox 開啟 Windows 後，就能省掉很多資料交換的麻煩，但畢竟是 Virtual Machine，使用上不比 Native，可能會有些狀況；另外，我電腦的 Windows 跟 Ubuntu 開機都安裝在 SSD，要用 EFI 從 dev/nvme0n1 開機，但如果可以的話，最好將兩個系統切開，免得不小心開到 Ubuntu，造成資料損壞。</p>\n<h2 id=\"reference\"><a class=\"direct-link\" href=\"#reference\">#</a> Reference</h2>\n<ul>\n<li><a href=\"https://www.jamieweb.net/blog/booting-a-physical-windows-10-disk-using-virtualbox-on-linux/\">Booting a Physical Windows 10 Disk Using VirtualBox on Linux</a></li>\n<li><a href=\"https://www.serverwatch.com/server-tutorials/using-a-physical-hard-drive-with-a-virtualbox-vm.html\">Using a Physical Hard Drive with a VirtualBox VM</a></li>\n</ul>\n",
      "date_published": "2019-06-10T00:00:00-00:00"
    },{
      "id": "https://blog.kenwsc.com/posts/2019/setup-openwrt-on-virtualbox/",
      "url": "https://blog.kenwsc.com/posts/2019/setup-openwrt-on-virtualbox/",
      "title": "在 VirtualBox 上建置 Openwrt",
      "content_html": "<p>現在工作會用到 Openwrt 當開發平台，但用起來一直卡卡的，想找時間從頭操作一次，看能不能深入理解系統的運作，說起來工作的重點就是不斷追求 balance，既能符合商業需求，又能持續成長。趁著年假有空，來玩玩看 Openwrt 有什麼特色。</p>\n<p>首先是下載 Openwrt 並編譯，現在的 Openwrt 已經用 git 做版控，可以用 git clone 來放到自己的開發目錄</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> clone https://git.openwrt.org/openwrt/openwrt.git<br><span class=\"token builtin class-name\">cd</span> openwrt</code></pre>\n<p><img src=\"/img/posts/2019/setup-openwrt-on-virtualbox/console-1.webp\" alt=\"\"></p>\n<p>剛下載下來的 Source code 沒有包含相關的 package，例如 python、driver 等等，因為後續開發會需要用到，先使用 feeds來更新並安裝 package</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">./scripts/feeds update<br>./scripts/feeds <span class=\"token function\">install</span> -a</code></pre>\n<p>feeds是 Openwrt 內建的 script，如果想知道 command 的意思，可以用 help 。剛接觸 Linux 的人可能會不習慣看 help 來理解 command，可是用習慣之後，有問題能自己解，不用爬 Stack Overflow，對 Coding 幫助其實很大</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">./scripts/feeds -h<br><span class=\"token function\">install</span> <span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span>package<span class=\"token operator\">></span>: Install a package<br><span class=\"token punctuation\">..</span>.<br>update -a<span class=\"token operator\">|</span><span class=\"token operator\">&lt;</span>feedname<span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token operator\">></span>: Update packages and lists of feeds <span class=\"token keyword\">in</span> feeds.conf <span class=\"token builtin class-name\">.</span></code></pre>\n<p>由 help 內容可以知道，update 是更新追蹤的 package list； install 則是安裝 package，如果沒有安裝， menuconfing 時就會看不到相關的 package ，因此這邊全部裝起來</p>\n<p>接著進行環境準備，輸入 make defconfig 來檢查相關的 tool 有沒有 Ready，並產生設定文件 .config</p>\n<p>再來使用 make menuconfig 來選擇要編譯的 package，找不到 package 的話可以用 / 加關鍵字搜尋，搜尋有支援 regular exp 喔！這邊先選擇 python3 、LuCI 、GDB ， Target 用 x86 ，印象檔格式用 ext4</p>\n<p><img src=\"/img/posts/2019/setup-openwrt-on-virtualbox/console-2.webp\" alt=\"\"></p>\n<p>之後用 make -j8 全速編譯</p>\n<p><img src=\"/img/posts/2019/setup-openwrt-on-virtualbox/console-3.webp\" alt=\"\"></p>\n<p>編譯完得到映像壓縮檔，解壓縮</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">gunzip openwrt-x86-generic-combined-ext4.img.gz </code></pre>\n<p>得到映像檔，為了讓 VirtualBox 可以掛載，要用 vboxmanage轉換為 vdi 格式</p>\n<p>vboxmanage convertfromraw --format VDI openwrt-x86-generic-combined-ext4.img openwrt_x86.vdi<br>\n再來開啟 VirtualBox，建立 Virtual Machine</p>\n<p><img src=\"/img/posts/2019/setup-openwrt-on-virtualbox/vm-1.webp\" alt=\"\"></p>\n<p>選擇 Type 為 Linux ，版本為 Linux 2.6 / 3.x / 4.x (32-bit) ，一路 Next 完成掛載</p>\n<p>開啟 VirtualBox，可以看到</p>\n<p><img src=\"/img/posts/2019/setup-openwrt-on-virtualbox/vm-2.webp\" alt=\"\"></p>\n<p>完成！已經在 VirtualBox 上掛載剛剛編譯好的 Openwrt 了！</p>\n",
      "date_published": "2019-02-03T00:00:00-00:00"
    }
  ]
}
